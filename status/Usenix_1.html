<!DOCTYPE html>
<html lang="en">
<head><base href="https://rss-bridge.org/bridge01/" target="_blank">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/ >
    <meta name="description" content="RSS-Bridge" />
    <title>USENIX</title>
    <link href="static/style.css?2023-03-24" rel="stylesheet">
    <link rel="icon" type="image/png" href="static/favicon.png">

    
        <link
            href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Atom"
            title="Atom"
            rel="alternate"
            type="application/atom+xml"
        >
	
        <link
            href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Json"
            title="Json"
            rel="alternate"
            type="application/json"
        >
	
        <link
            href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Mrss"
            title="Mrss"
            rel="alternate"
            type="application/rss+xml"
        >
	
        <link
            href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Plaintext"
            title="Plaintext"
            rel="alternate"
            type="text/plain"
        >
	
        <link
            href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Sfeed"
            title="Sfeed"
            rel="alternate"
            type="text/plain"
        >
	
    <meta name="robots" content="noindex, follow">
</head>

<body>
    <div class="container">

        <h1 class="pagetitle">
            <a href="https://www.usenix.org/publications" target="_blank">USENIX</a>
        </h1>

        <div class="buttons">
            <a href="./#bridge-UsenixBridge">
                <button class="backbutton">← back to rss-bridge</button>
            </a>

                            <a href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Atom">
                    <button class="rss-feed">
                        Atom                    </button>
                </a>
                            <a href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Json">
                    <button class="rss-feed">
                        Json                    </button>
                </a>
                            <a href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Mrss">
                    <button class="rss-feed">
                        Mrss                    </button>
                </a>
                            <a href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Plaintext">
                    <button class="rss-feed">
                        Plaintext                    </button>
                </a>
                            <a href="?action=display&amp;bridge=UsenixBridge&amp;context=USENIX+%3Blogin%3A&amp;format=Sfeed">
                    <button class="rss-feed">
                        Sfeed                    </button>
                </a>
            
                    </div>

                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/gear-shift-hacks-uncovering-security-risks-wireless-technology-professional"
                    >Gear Shift Hacks: Uncovering the Security Risks of Wireless Technology in Professional Cycling</a>
                </h2>

                                    <time datetime="2024-10-11 00:00:00">
                        2024-10-11 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Maryam Motallebighomi</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In the heart of the Tour de France, arguably the most prestigious and challenging cycling race in the world, the race leader is climbing L’Alpe D’Huez, confidently ahead of the pack. But suddenly, the gear shifts up unexpectedly, slowing the rider and making them increase power to keep up their speed. No matter how much they adjust, the gears keep slipping into inefficient settings, disrupting their rhythm. At times, the gear shifters become entirely unresponsive. </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Is this a simple mechanical malfunction, or could it be a sign of something more insidious—perhaps the emergence of high-tech, illegal manipulations in competitive cycling?</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We researched what it would take to attack a wireless shifting system, and found that we could control a shifter or deny access to it. In this article, we explain how we did this and what shifter manufacturers might do to prevent these attacks.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/picture1.png?itok=38F-KUTL" width="670" height="374" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">The attacker records and replays the wireless signals between the shifter and derailleur.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Modern bicycles are cyber-physical systems that contain embedded computers and wireless links to enable new types of telemetry and control. The key motivating factors for moving away from traditional mechanical systems are the ability to gain insights about a rider's physical performance, better responsiveness in gear shifting, customizability of how the gear shifters operate, and easier setup and maintenance. </span></p><p><span></span><span>Among the latest innovations in cycling technology, wireless gear shifting stands out for its significant impact on bike control and rider safety. The system uses wireless links between the gear shifters and the derailleur </span><span>— </span>an electro-mechanical component that uses motors to move the chain between gears. Electronic control provides increased precision in shifts and is less prone to issues like cable stretch and contamination that plague mechanical gear shifting systems.</p><p>While wired electronic gear-shifting systems exist, the trend in the cycling industry is rapidly moving toward fully wireless solutions. Major manufacturers like Shimano, SRAM, and Campagnolo now all offer wireless shifting options. But now that the system is going wireless, we have new problems to contend with – particularly security risks. Any vulnerability in such a critical system can have serious consequences for rider safety and performance, especially in professional races. In high-speed events, where hundreds of riders are packed tightly in a peloton, sudden changes in a bike's performance can be catastrophic. If an attacker were to hack into the wireless shifting system of a subset of riders and shift the gears or jam the shifting operation, it could result in crashes and injuries. And in critical moments, such as steep climbs or rapid descents, losing control of gear shifting could mean losing not just the race, but control of the bike itself.</p><p><span>It is important to note that the sport of professional cycling has long struggled with the use of illegal performance-enhancing drugs. </span><span>Security vulnerabilities in one of the bike’s most critical components could offer an appealing alternative for those looking to compromise the integrity of </span><span> </span><span>the sport. Unlike the physical evidence left by doping, wireless attacks can be almost impossible to trace. With the advent of wireless gear shifting, it's crucial to adopt an adversary's perspective — professional bike races are highly competitive and adversarial, and any technology used must be robust enough to withstand attacks from motivated individuals.</span></p><h2><span>A TL;DR of the results</span></h2><p>To explore potential vulnerabilities, we focused on the Shimano 105 Di2 and Shimano DURA-ACE Di2 wireless shifting systems [<a href="#reference-9" rel="nofollow">9</a>]. Shimano, a leader in the bicycle control system industry with roughly 50% market share, provided an ideal case study for our investigation. We purchased a recent version of the control system and conducted a black box security analysis, capturing raw physical signals, observing their behavior during gear shifts, and analyzing the packet structure and content.</p><p>What we uncovered in our security analysis was surprising, especially considering the similarities to prior attacks on systems like passive keyless entry for cars [<a href="#reference-1" rel="nofollow">1</a>] and garage door openers [<a href="#reference-6" rel="nofollow">6</a>]. We discovered a record-and-replay attack that allows an unauthorized party to fully control gear shifting on a victim's bike from up to 10 meters away — without the need for any amplifiers. These attacks can trigger unexpected gear shifts in random patterns by manipulating the physical layer, completely bypassing the need to extract cryptographic secrets, making the attack independent of encryption.  This attack can be realized using commercial-off-the-shelf software-defined radios (SDR). The attacker only needs to record two signals — an upshift and a downshift. Additionally, we found that targeted jamming attacks could disable gear shifting on a specific bicycle without affecting others nearby.</p><p><span>The attacker only needs an SDR capable of transmitting and receiving signals in the 2.4 GHz band. All commercial off-the-shelf SDRs, such as the USRP B210, HackRF, PlutoSDR, and LimeSDR, are potential options for this purpose. In our proof-of-concept threat analysis, we used an USRP B210. An attacker may also opt for more advanced setup, e.g., using amplifiers to extend the attack range.</span><span> </span></p><h4><span>Responsible Disclosure and Disclaimer</span></h4><p><span>We notified Shimano about the vulnerabilities, along with detailed information on replicating the attacks, part numbers of the devices we tested, and a description of countermeasures that might be helpful in this context. Shimano has acknowledged these vulnerabilities and has released fixes to both professional racing teams and to individual customers. We emphasize that these identified attacks are unlikely to impact amateur or commuter cyclists; the real concern arises in high-stakes, adversarial environments, such as professional racing.</span></p><p><span> </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/picture2.png?itok=bFB52HUe" width="556" height="416" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Experimental setup comprising of the USRP B210, laptop, the Shimano gear shifters and derailleurs.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Attacker Strategy 1: Replay Attack</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>A replay attack in the wireless world is when an attacker intercepts and records signals during a legitimate action, then later retransmits them to carry out the same action on the system without authorization. Notably, the attacker does not need to understand the packet's format or contents to succeed. Replay attacks can even bypass encrypted protocols making them a versatile and concerning threat.</span></p><p><span>Therefore, to carry out a replay attack, the attacker only needs to capture the signal responsible for shifting gears. The key element of the attack is simply capturing a signal that corresponds to an upshift or downshift, which can then be retransmitted to force gear changes on the victim's bike.</span></p><p><span>Capturing these signals is straightforward. The attacker doesn’t need physical access to the bike; being within range is enough. In professional races, where riders are tightly packed, a bystander along the race route or even a team vehicle traveling alongside the peloton could easily record the gear-shifting signals in real time as the victim rider changes gears. In a matter of seconds, the attacker could capture both an upshift and a downshift signal, regardless of the current gear the bike is in, and later use them to trigger unauthorized shifts. The capture could also take place well before race day, such as during a team event or a practice session days or weeks in advance. This opens up various opportunities for an attacker to interfere with a rider’s performance using minimal equipment and without drawing attention. We note that the attack works irrespective of which gear the bike is currently in; thus, it is sufficient for the attacker to capture any upshift and any downshift signal.</span></p><p><span>We conducted replay attack experiments by testing how far the attacker’s transmitter could be from the bike’s rear derailleur while still successfully shifting gears. In our tests, we shifted through all eleven gears, from the lowest to the highest, at various distances. The results showed that we could consistently trigger unintended gear shifts from up to 9 meters away without any failures. At 10 meters, we successfully shifted 10 out of 11 times. Beyond this range, the signal weakened and the attack became unreliable. Importantly, these tests were done without any signal amplifiers, meaning this range represents the lower bound for how far an attacker could be from the target.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/picture3.png?itok=dpsTOzv5" width="846" height="510" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Replay attack success rate vs distance from the target system.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Attacker Strategy 2: Targeted Jamming Attack</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>A jammer works by transmitting radio frequency noise that disrupts wireless communication. How effective the jamming is depending on several factors, like the power of the device, the type of signal being jammed, environmental conditions, and the distance between the jammer and the receiver. There are ways to make jamming more targeted and efficient. For example, using directional antennas can focus the jamming signal on a specific area, reducing its impact on other surroundings. The success of jamming often comes down to how well it’s designed and how strategically it’s used, especially when directionality is a key factor.</span></p><p><span>We used the same SDR setup from our replay attack to transmit a jamming signal—specifically, a simple sinusoid—at 2.478 GHz, which is the frequency Shimano uses for its wireless communications. For our tests, we placed the shifter and derailleur one meter apart, which mirrors the typical setup on a bike, and then tested the jammer at different distances. When the jammer was within one meter of the derailleur, the gear-shifting system became completely non-functional, cutting off all communication. Beyond this range, the jammer still disrupted the signal, but didn’t fully disable the bike’s functionality. </span></p><p><span>However, this type of attack would affect every bike in the vicinity operating on the same frequency. We then shifted our focus to see if we could target a specific bike while leaving others nearby unaffected. This approach mirrors a real-world race scenario, where an attacker might want to disrupt only a specific rider’s bike while ensuring that friendly bikes remain fully functional. </span><span>In our study, we labeled two Shimano wireless gear-shifting sets as Bike1 and Bike2. We captured an upshifting signal from Bike1 and replayed it at different intervals using our USRP B210, while manually shifting gears on Bike2 nearby. Our results showed that when the interval was less than 112 µs (the length of one packet), Bike2 also stopped working due to interference. However, once the interval exceeded 112 µs, Bike2’s functionality returned, as there was enough time for command packets to transmit and receive acknowledgments. In short, when the attacker sends replay packets with a 112 µs interval, Bike1 is disabled while Bike2, or any other nearby bike, continues to function normally.</span></p><p><span> </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/picture4.png?itok=DBKoMvnO" width="686" height="412" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Gear Shifting Success Rate in Bike2 Relative to Packet Interval Timing from Bike1</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Discussion</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h3><span>Attacker device form-factor and cost</span></h3><p>In the current implementation of our signal capture and replay system, we utilize a setup comprising an SDR and a laptop. While effective, this configuration is not optimized for size or portability. However, with advancements in miniaturization and integrated circuit (IC) technology, it is feasible to reduce the size of the attack device significantly. By custom designing specific circuits, we can integrate a receiver, a modest amount of memory for signal storage, and a transmitter into a compact, single System on a Chip (SoC) or small circuit board. This miniaturization process makes the attack system more discreet and enhances its portability and deployment ease. For example, researchers demonstrated relay attacks [1] on passive keyless entry systems with SDRs costing more than $1500 in 2011. A few years later [<a href="#reference-8" rel="nofollow">8</a>], the same attack was demonstrated using $22.</p><p> </p><h3><span>Potential Countermeasures</span></h3><p>To mitigate replay attacks, a basic measure is to add timestamps to wireless messages exchanged, as it restricts message validity to a specific timeframe, making older, replayed messages invalid. However, this approach comes with challenges, particularly the need for precise time synchronization between devices, which can be difficult when devices don’t have reliable access to shared time sources. Another common defense is rolling codes, where each transmitted signal includes a unique, one-time-use code. This makes it much harder for an attacker to reuse captured signals, as both devices move to the next code after each transmission. While rolling codes greatly raise the difficulty of executing replay attacks, they aren't entirely foolproof against more sophisticated methods like code grabbing or delayed playback [<a href="#reference-3" rel="nofollow">3</a>, <a href="#reference-5" rel="nofollow">5</a>, <a href="#reference-7" rel="nofollow">7</a>]. </p><p>An alternate unconventional measure would be to implement distance-based restrictions that could add an important layer of security. Since legitimate interactions occur only between shifters and derailleurs within a limited range, restricting command acceptance to close proximity could be highly effective in reducing the likelihood of remote replay attacks. This method works on the assumption that attackers are more likely to operate from a distance. However, securely measuring distance poses its own challenges [<a href="#reference-2" rel="nofollow">2</a>]. Techniques like signal strength estimation or time-of-flight can be unreliable, especially in the fast-paced environment of competitive cycling. While this approach can help reduce the risk of replay attacks, it should not be seen as a standalone solution. Instead, it should be used in combination with other security measures, such as rolling codes or timestamps, to provide more comprehensive protection.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Final Remarks</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>As technology continues to spread into the world of competitive sports, the need for robust security threat analysis becomes all the more critical. Our research shows just how easily wireless gear-shifting systems can be compromised, potentially turning the tide of a race with a well-timed attack. In an era where every bit of performance matters, it's not just about the athletes anymore — keeping tech secure is just as important to ensure fair competition and safety on the track. The future of sports could very well depend on staying one step ahead of these evolving threats. </span></p><h3><span>Acknowledgements and Proof-of-concept Video</span></h3><p><span> </span><span>The work was partially supported by NSF grant 2144914. We thank Keith Wakeham and Virgyl Fernandes for their technical expertise in cycling components, Andreas Noack for his expert suggestions on URH. A proof-of-concept demo video can be found here &lt;</span><a href="https://www.youtube.com/watch?v=7Pgd-EpLtDg" rel="nofollow">https://www.youtube.com/watch?v=7Pgd-EpLtDg</a><span>&gt;</span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Aurélien Francillon, Boris Danev, and Srdjan Capkun. "Relay Attacks on Passive Keyless Entry and Start Systems in Modern Cars." In Network and Distributed System Security Symposium (NDSS), 2011.</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2]&nbsp;Aanjhan Ranganathan and Srdjan Capkun. "Are We Really Close? Verifying Proximity in Wireless Systems." In&nbsp;IEEE Security &amp; Privacy Magazine, Vol. 15, No. 3, pages 52–58, 2017.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3]&nbsp;Earlence Fernandes, Jaeyeon Jung, and Atul Prakash. "Security Analysis of Emerging Smart Home Applications." In IEEE Symposium on Security and Privacy (S&amp;P), 2016.</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Johannes Pohl and Andreas Noack. "Universal radio hacker: A suite for analyzing and attacking stateful wireless protocols." In&nbsp;12th USENIX Workshop on Offensive Technologies (WOOT), 2018.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Flavio D Garcia, Gerhard de Koning Gans, Ruben Muijrers, Peter Van Rossum, Roel Verdult, Ronny Wichers Schreur, and Bart Jacobs. "Dismantling MIFARE Classic." In&nbsp;13th European Symposium on Research in Computer Security (ESORICS), 2008.</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Ahmed Ghanem and Riham AlTawy. "Garage Door Openers: A Rolling Code Protocol Case Study." In&nbsp;19th Annual International Conference on Privacy, Security &amp; Trust (PST), 2022.</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Samy Kamkar. "KeySweeper." 2015.&nbsp;<a href="https://samy.pl/keysweeper/" rel="nofollow">https://samy.pl/keysweeper/</a></p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] "Just a Pair of These $11 Radio Gadgets Can Steal a Car." 2017.&nbsp;<a href="https://www.wired.com/2017/04/just-pair-11-radio-gadgets-can-steal-car/" rel="nofollow">https://www.wired.com/2017/04/just-pair-11-radio-gadgets-can-steal-car/</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] Shimano.&nbsp;"New Shimano 105 Di2 Delivers 12-Speed, Shifting and Wireless Performance."&nbsp;<a href="https://bike.shimano.com/en-US/information/news/new-shimano-105-di2-delivers-12-speed--shifting-and-wireless-per.html" rel="nofollow">https://bike.shimano.com/en-US/information/news/new-shimano-105-di2-delivers-12-speed--shifting-and-wireless-per.html</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">IoT</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/exploiting-smartphones"
                    >Exploiting Smartphones</a>
                </h2>

                                    <time datetime="2024-10-07 00:00:00">
                        2024-10-07 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Rik Farrow</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In my search to learn what people who visit usenix.org are most interested in, I noticed that a paper about Android was getting downloaded much more often than other Security'24 papers.  Maar et al [1] describes three years of Linux kernel exploits that can work against Android phones—if they don't have the latest kernel patches. I'll share what I learned from reading their paper, but I also want to discuss some other smartphone weaknesses.</span></p><div><p><span>Shortly after the first iPhone came out in 2007, I was contacted by Adam Penenberg, a journalist working for Fast Company magazine, and asked if I could create a video of me hacking the new iPhone. They would supply the iPhone, but I'd have to do the rest.</span></p></div><p><span>A quick online search determined that HD Moore's Metasploit, a pentesting set of applications, included a hack for Safari, the iPhone's (and Mac's) web browser. I taught myself how to use Metasploit and set up the attack. After running the exploit, I could watch Safari vanish from the iPhone's display when Safari visited the web interface setup with Metasploit. Then I could upload files and enter commands. The iPhone ran everything as root, so the remote access tool (RAT)  installed by exploit also ran as root.</span></p><p><span> I installed the BSD shell utilities, and spent time looking around. As a proof-of-concept, I also wrote a very short Objective C program that recorded ten seconds of audio and saved it as a file that I could copy back to the attacking system.</span></p><p><span>Some people doubted that I had taken over my iPhone, and the disappearance of Safari from the display hardly seems like proof [2]. I wrote a rebuttal that pointed out that the iPhones, and phones like them, were ripe for spyware. I outlined an attack using a laptop posing as local WiFi access to insert backdoors in my fictional scenario. These descriptions appear in the Fast Company article attributed to other folks, but those people could easily have had the same ideas that I did.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">The NSO Group</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>A little less than a decade after my brief iPhone adventure, the NSO Group was in the news [3]. Their Pegasys software had been found on the iPhones of more than a hundred journalists and political opponents of dictators. The software had been installed over the network, a 'zero-touch' attack, as the owner of the phone didn't need to participate by installing software or clicking on a link leading to malware. It's likely this was accomplished via a 'baseband' attack.</span></p><p><span>Smartphones include dozens of chips, all with processors: even some lithium batteries include simple processors to control charging.  For an example, check out the teardown diagram of the Pixel 6 [4], with 24 ICs on the front and back of the main board. The Samsung Shannon baseband chip handles communication with cell networks for voice and data.</span></p><div><p><span>I watched Natalie Silvanvich lecturing about the work that Google's Project Zero had done on exploiting Shannon baseband [5]. Natalie begins by explaining how mobile calls get setup using SIP before SDP gets used to set up digital transfers, such as streaming videos or receiving a text. While SIP gets processed by carriers' servers, essentially filtering or rewriting the protocols in use, SDP gets passed through to endpoints, and Natalie demonstrates how parsing SDP [6] can be exploited via simple overflows. She also mentions ways of disabling SELinux and no execution in read-only regions (R^X), defenses not covered in the Maar paper.</span></p><p> </p><p>I asked Natalie about the memory model of the smartphone that's the target in her talk. Natalies suggested that I take a look at a <a href="https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html" target="_blank" title="Project Zero blog post about iPhone 7" rel="nofollow">Project Zero blog post</a>, where they are exploring an iPhone 7 via a WiFi chip. Natalie told me that most smart phones have an IOMMU, that is, a device that manages access to main memory over a PCIe bus. If the IOMMU is properly configured, it permits DMA between each device (those 24 ICs mentioned eariler) and main memory. Natalie's talk is about how one might leverage what does get copied into main memory into an effective attack.</p></div><p><span>It's likely that the NSO group used baseband attacks for installing Pegasys, but it's just as possible they were using another hack, a kernel hack.  And that brings us back to Maar's paper.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Exploiting Android</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>I had picked Maar's paper out of the over 400 accepted Security'24 papers [7] as a possible candidate for a ;login: article, but passed over it because I found the first couple of sections of the paper too dry. I should have kept on reading.</span></p><div><p><span>Section 4, beginning on page 5, is where things started to get interesting to me. The authors describe what they call 'One-Day' exploits, because, unlike zero-day exploits, one-day exploits are known. They downloaded the exploits from public sources, like Project Zero, Blackhat or Github, then proceeded to test them against versions of Android. They built scripts to collect Android versions, including both source code (it's Linux and so should be published) and firmware. Then they built the code and ran it, or the firmware, on QEMU and tried the exploits against the various versions.</span></p></div><p><span>In section 4.1, the authors present a series of exploit techniques (ETs), listing ten different techniques used in the 26 exploits (all represented by CVEs) that they had collected.</span></p><div><p><span>In the next section, they cover the defenses that have been added to the Linux kernel to prevent most of these exploits from succeeding.</span></p></div><p><span>I really enjoyed this portion of the paper. It reminded me of the 'old days' in the 1990s where people commonly published exploits, including code and descriptions of them. In the paper, the descriptions are clear, and the explanations of the changes to the Linux kernel included to prevent these kernel exploits are also clearly written, sometimes including code examples.  Although I did have to read many parts of the paper more than once, I learned a lot about how exploits involving use-after-free (UAF), double-free (DF) or control flow work, and how simple changes can often, but not always, prevent these exploits from working.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Customized Android</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>The paper's authors’ main point was that most non-Google versions of Android are using much older versions of the Linux kernel that don't include these defense mechanisms. Vendors aren't using the latest Linux kernel because they have added their own customizations, often for security, that make upgrading to a current kernel version difficult. In a couple of cases, the processors included in the non-premium versions of Android phones are slow enough that key defenses, for example against using the unlink function of doubly-linked lists as a read or write gadget, slow down the working of the smartphone noticeably, so the vendors just leave this undone—opening up the smartphone to lots of older exploits in the name of performance.</span></p><p>I suggest reading this paper. The attacks and defenses discussed are relevant to anyone who uses an older Linux kernel. I did attempt to contact the paper's presenter but never heard back from him.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Spyware</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Before you get too paranoid about your own phone, most countries, via their teams of hackers, are not going to be interested enough to install spyware on your precious smartphone. Your ex (if you have one), on the other hand, who has physical access to your phone is a more likely perpetrator.</span></p><p><span>It's one thing to snoop on the Internet as the Chinese have allegedly been doing [8], as some of what one gets to collect is text that can be filtered for potentially interesting communications. But processing everything most people are doing on their smartphones would be an enormous waste of resources.  Targeted attacks, such as the ones used by owners of Pegasys, are on people of interest.</span></p><p><span>Smartphones, just like anything that has a processor and an operating system, are insecure. Computer scientists began working on security with MULTICS in the late 1960's, and operating systems and the hardware they run on have become increasingly complex over time. No one person can understand all of the Linux kernel, and forget about Windows being understandable. On top of that, operating systems are still written using insecure languages (C/C++), ones that allow manipulation of pointers (indirect memory access) by programmers, don't include array or string bound checking by default, and so on. Safe languages, like Rust and Go, are catching on, but are also harder to use than their unsafe brethren.</span></p><div><p><span>And then there's the hardware they run on, still patterned after the mainframe systems like MULTICS ran on. It's going to take time, and a lot of creative work, to have systems that might possibly be secure.</span></p></div></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Maar, L, Draschbacher, F., Lamster, L., Mangard, S., Defects-in-Depth: Analyzing the Integration of Effective Defenses against One-Day Exploits in Android Kernels: 33rd USENIX Security Symposium (USENIX Security 24) 2024: <a href="https://www.usenix.org/conference/usenixsecurity24/presentation/maar-defects">https://www.usenix.org/conference/usenixsecurity24/presentation/maar-def...</a></p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Penenberg, A., Hacking the iPhone: <a href="https://www.fastcompany.com/77064/hacking-iphone;" rel="nofollow">https://www.fastcompany.com/77064/hacking-iphone;</a> accessed October 2024</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] Amnesty International, Forensic Methodology Report: How to catch NSO Group’s Pegasus: <a href="https://www.amnesty.org/en/latest/research/2021/07/forensic-methodology-report-how-to-catch-nso-groups-pegasus/" rel="nofollow">https://www.amnesty.org/en/latest/research/2021/07/forensic-methodology-...</a></p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Google Pixel 6 Pro teardown: <a href="https://www.techinsights.com/blog/teardown/google-pixel-6-pro-teardown" rel="nofollow">https://www.techinsights.com/blog/teardown/google-pixel-6-pro-teardown</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Natalie Silvanovich, Google Zero team, How to hack Shannon baseband: <a href="https://www.youtube.com/watch?v=NnmAikOTHaA" rel="nofollow">https://www.youtube.com/watch?v=NnmAikOTHaA</a></p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] <a href="https://en.wikipedia.org/wiki/Session_Description_Protocol" rel="nofollow">https://en.wikipedia.org/wiki/Session_Description_Protocol</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] USENIX Security'24 Technical Sessions: <a href="https://www.usenix.org/conference/usenixsecurity24/technical-sessions">https://www.usenix.org/conference/usenixsecurity24/technical-sessions</a></p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Ilascu, I., AT&amp;T, Verizon Hacked: <a href="https://www.bleepingcomputer.com/news/security/atandt-verizon-reportedly-hacked-to-target-us-govt-wiretapping-platform/" rel="nofollow">https://www.bleepingcomputer.com/news/security/atandt-verizon-reportedly...</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">Operating Systems</li>
                                                    <li class="category">Linux</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/solving-first-mile-problem"
                    >Solving the First-Mile Problem</a>
                </h2>

                                    <time datetime="2024-09-30 00:00:00">
                        2024-09-30 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Joe Loughry</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We can take over control of a completely isolated—air gapped—computer from a distance. To do it, we used a very old idea: that flashes of light can disrupt electronics. The effect is controllable enough to execute arbitrary code on the target system, but a long way from being able to do it to an ordinary laptop. It solves a problem ignored by almost every report of defeat of air-gapped security: the problem of initial access. Think of Tom Cruise dangling from a wire in a computer room in the first <em>Mission Impossible</em> movie.</span></p><p>This article expands on the research paper presented at USENIX WOOT’24 [<a href="#reference-1" rel="nofollow">1</a>], which I collaborated with Kasper Rasmussen of the University of Oxford.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">(Impolite introduction)</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Every covert channel paper ever always seems to begin with the same implicit assumption:</span></p><blockquote>“Grant us the inside man.”</blockquote><div><span>We are asked to assume the system is already compromised. We’ve already bribed an operator, already tricked someone into plugging in a USB containing our malware—basically, assume we’ve already hacked into the system by conventional means first—and then after that, you can do the bit with the hovering drones.</span></div><div><span><br /></span></div><div><span>But that's begging the question. It doesn’t solve the first mile problem. How do you get into an air-gapped system that hasn't been gimmicked, one that wasn’t already listening for a signal?</span></div><div><span><br /></span></div><div><span>Just an ordinary computer, minding its own business.</span></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Background</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>What if you could do glitching attacks [<a href="#reference-2" rel="nofollow">2</a>] without access to the power supply? What if you could do laser fault injection [<a href="#reference-3" rel="nofollow">3</a>, <a href="#reference-4" rel="nofollow">4</a>, <a href="#reference-5" rel="nofollow">5</a>] without boiling nitric acid or grinding wheels, and no longer limited to a microscope stage?</p><p>We found this vulnerability because we went looking for it. Building on the long history of side channels [<a href="#reference-6" rel="nofollow">6</a>, <a href="#reference-7" rel="nofollow">7</a>, <a href="#reference-8" rel="nofollow">8</a>], it seemed reasonable that information might be able to flow into a system instead of leak out of it.</p><p><span>We have not reached the stage of a practical attack yet. We can show remote code execution, but only on haywired hardware. Our's is a measurement paper.</span></p><p>By way of analogy, if side channels are like mind reading, this is mind control.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Limitations and Impact</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>The vulnerability of inadvertently photosensitive electronic components directly connected to circuits carrying sensitive information is as old as the IBM 701 mainframe computer (in 1952) and as current as the Raspberry Pi 3 in 2016 [<a href="#reference-9" rel="nofollow">9</a>, <a href="#reference-10" rel="nofollow">10</a>, <a href="#reference-11" rel="nofollow">11</a>].</p><blockquote><em>Things went pretty well at the dedication, until the photographers started taking pictures of the hardware. As soon as the flashbulbs went off, the whole system came down. Following a few tense moments on the part of the engineering crew, we realized with some consternation that the light from the flashbulbs was erasing the information in the CRT memory. Suffice it to say that shortly thereafter the doors to the CRT storage frame were made opaque to the offending wavelengths.</em> [<a href="#reference-9" rel="nofollow">9</a>]</blockquote><p><span>We began from only being able to crash the system, and extended it to take over control remotely. Our approach works, in general, on shared communication buses, and depends entirely on where the hardware designer decided to put components. The attacker needs line-of-sight and detailed knowledge of the hardware and software running on the target.</span></p><p>It’s not the same as a classical covert channel, because there is no need to assume the existence of an insider threat; further, it eliminates any need to install malware on the target system ahead of time [<a href="#reference-12" rel="nofollow">12</a>, <a href="#reference-13" rel="nofollow">13</a>]. It’s not the same as optical fault injection, which is done under a microscope on decapped chips [<a href="#reference-3" rel="nofollow">3</a>, <a href="#reference-4" rel="nofollow">4</a>, <a href="#reference-5" rel="nofollow">5</a>]. Finally, it is not the same thing as Light Commands [<a href="#reference-14" rel="nofollow">14</a>, <a href="#reference-15" rel="nofollow">15</a>, <a href="#reference-16" rel="nofollow">16</a>], because we can take over control of a computer that wasn't already listening for a signal.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">(The headlines just write themselves.)</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><blockquote><p><em>"Critical Cybersecurity Vulnerability Found in Light-Up Dog Toys"</em></p></blockquote><p>So far, the vulnerability is exploitable on only one commercially available device we've found, a 5 mm RGB color changing LED commonly found in light-up toys [<a href="#reference-17" rel="nofollow">17</a>]. Hit it with a fast pulse of infrared at 900 nanometers, and it will reliably reset the sequence to red. The chip inside is believed to be a CDT3447 [<a href="#reference-18" rel="nofollow">18</a>] and it is not known whether the entry point is one of the RGB emitters or the silicon substrate of the chip itself, which is transparent to infrared wavelengths, as in the Raspberry Pi.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/check-engine-light.jpg?itok=v7FJlc94" width="250" height="159" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: A typical status indicator lamp, this one from a car.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Context</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>So the context here is status indicator lamps (Figure 1).</p><p><span>If you shine a <em>really</em> bright light on one of them, all that energy has to go somewhere. Would you believe it flows backwards into the electronics? Effects range all the way up to remote code execution. There are at least two different physical effects at work: a photoelectric effect and a photoconductive effect. It takes a fairly powerful laser to do it, because in addition to information, you are also supplying all the <strong>energy</strong> needed to run the electronics in reverse.</span></p><p><span>That last point is important. The energy levels involved here are high. These are absolutely not eye safe lasers. We take elaborate precautions around them including interlocks, protective goggles, warning signs, and radiation shielding. Be careful.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/reachability.jpg?itok=mXZrL54M" width="1440" height="660" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: Table 1 and Figure 17 from the paper [1], describing the architecture of an imaginary computer.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Arbitrary-ish Code</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>M5 is an imaginary computer with an extremely small instruction set, smaller even than RISC-V. In Figure 2, Table 1 shows the complete instruction set of this imaginary computer; on the right, Figure 17 shows which opcodes are reachable from other opcodes if you can only change binary zeros to ones.</span></p><p><span>The photoelectric effect lets us change a binary 0 to 1, but not to go the other way around. The photoconductive effect lets us change a binary 1 to 0—but not the other way around. This immediately suggests that the two effects might be used in concert, but there’s a problem: typically, electronic components respond only to one effect or the other, but not both.</span></p><p><span>This places some <em>fascinating</em> constraints on the attacker. Those binary numbers in Table 1 are all the possible assembly language instructions. If we assume the attacker can only change a binary 0 to 1, but can never go the other way around, then some of those instructions are reachable from other instructions, as you can tell from the graph on the right.</span></p><p><span>The attacker might be able to change a load instruction into a branch, or an add into a subtract, but can't change a branch into a store, or a divide into a compare, so we say the attacker can execute arbitrary-ish code. It’s a kind of weird machine. It’s easy to redirect a memory access up into high memory—just set the high bit of the address—so our attacker patiently watches the instruction stream go by, picking and choosing opcodes he can alter into the instructions he wants, slowly building up the desired program in high memory. Maybe it's not quite the program the attacker wanted, because certain bit patterns were unreachable, so the first thing the arbitrary-ish code does is run fixups on itself. Finally, we redirect a branch, and it's game over.</span></p><p><span>The attacker must be very careful not to crash the running program, because its memory accesses are needed for the subversion. If the target computer ever crashes, access is lost.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/m5.jpeg?itok=V2EVBW3U" width="1440" height="818" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3: Here is a physical implementation of the M5 computer architecture in the figure above. The black rackmount box is the computer, with control switches on the left, green bus indicator LEDs right of center, and the accumulator display on the right. The bundle of wires on top is the attacker, with four powerful lasers aimed point blank at the green bus LEDs. An array of photosensors is mounted just below the accumulator display to let the attacker watch.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Running on a Real Computer (sort of)</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>M5 is a fairly simple computer, but it’s complex enough to illustrate the difficulty of the attack. It implements the instruction set shown above. It’s a four-bit CPU, load/store architecture with one register called the accumulator, which is visible on the front panel—which is important. It's not RISC-V because we wanted the instruction reachability graph above to be small enough to be grasped, not a plate full of spaghetti.</span></p><p><span>Think of it as a factory automation controller, reading temperatures and pressures, turning motors on and off to open and close valves in a chemical process plant. Normal operation is shown by a regular scanning pattern on the accumulator lamps.</span></p><p>The attacker begins by watching the target system for a while, specifically the accumulator display (<a href="https://youtu.be/O8yOomANDTk" target="_blank" title="Attack against the M5 computer using lasers" rel="nofollow">video of the attack</a>). Before the attack can proceed, the attacker needs to learn the timing and establish a phase lock on the internal state of the CPU. This is possible because the accumulator display always changes at a particular microcode cycle, which might be different for different instructions that can change the value in the accumulator, but the attacker can tell the difference between those instructions by observing the direction and magnitude of the change. We assume the attacker has complete knowledge of the computer's architecture and the program that is running, but needs to synchronize timing with that program, right down to the microcode cycle. It takes about ten iterations through the program (sweeps of the accumulator display shown in the right four LEDs) to get a phase lock.</p><p><span>Timing is absolutely critical. Once the attacker has got a phase lock, the lasers begin firing, but at the green bus LEDs in the middle, not at the red accumulator LEDs on the right. This serves to illustrate the general principle that you’re not always watching the same LED you’re shooting at. It only takes a few seconds, but the regular scanning pattern on the accumulator LEDs is observed to have changed. It’s not doing the same regular left-to-right scanning pattern as before. That’s because the computer is now running a completely different program, one that we put there through the status indicator lamps.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/circuit_analysis.png?itok=np5aO4V0" width="1440" height="563" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4: Light emitting diode (LED) status indicators (left) can be reversed to drive the connected CMOS circuit low, in this case an I2C bus (right). In theory, CMOS logic levels always avoid the shaded area on the left side of the middle chart of voltage levels; in practice, we found the behavior of real CMOS devices to be more like the right side of the middle chart.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Circuit Analysis</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Analysis begins with the electrical schematic of the target device, looking for potentially susceptible components in electrically interesting places. This is another of the constraints on the attacker; we can't choose where LED indicators are or how they're connected, and that determines what the attacker can do. Not every indicator will do something useful if reversed.</span></p><div><p><span>Figure 4 shows one electronic component of interest. Light emitting diodes are interesting because they are a naked P–N junction, the basic building block of solid state electronics. The way they work is simple: you put electricity in, and light comes out—pink light, in this case. But there's a general principle in physics that any process that runs in one direction can usually be made to run in the other direction if you supply enough energy to make up for the difference in entropy.</span></p><p><span>When you put light into an LED, it comes out as electricity but in the opposite direction from the usual current flow that makes it light up. This violates important assumptions made by the circuit designer. We can force the voltage on a communication bus low—or high, depending on how the LED is connected—by hitting it from a distance with a laser.</span></p><p><span>If the eyes are the windows to the soul, then LED status indicators are a window into the electronics.</span></p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/measurement_apparatus.jpg?itok=aXc9yy5a" width="1440" height="792" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 5: Measurement apparatus. The orange acrylic is radiation shielding.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Measurements</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>The first question everyone always asks is, how far away can you do it? And the answer is, we don't know. Our's is a measurement paper, not developed into a practicable attack. We aimed it once, and then bolted everything down so it can't drift out of alignment. It's not my problem to figure out how to aim this thing. It's my problem to measure it.</span></p><p><span>So we built this infernal machine (Figure 5). It consists of a pair of linear actuators, the x axis one bolted crosswise atop the carriage of the y axis one, which lets us raster scan a focused laser across any desired component on the circuit board, stopping every fiftieth of a millimeter to measure the voltage on the communication bus. There’s a live I<sup>2</sup>C bus under there, and it’s communicating the whole time. Each linear actuator has a stepper motor, and there’s a bank of relays that lets us automatically vary the bus voltage and pull-up resistor value. Data collection is automatic, transmitted out by a serial connection over USB. The whole thing is controlled by an Arduino. I like Arduino; everything is C++, the hardware is bulletproof—it’s relatively difficult to accidentally fry the I/O pins—and it’s cheap.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/all_the_raw_data.png?itok=olnPGJOz" width="1440" height="442" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 6: Raw data (left) from the apparatus in the previous figure. Each scan is 5 mm high and 5 mm wide, fifty lines of fifty samples per line. The color indicates voltage on the I2C bus when the laser is firing; blue is 3.3 V, red is 0 V. Isovoltage contours (middle) help visualize the active area; the critical value, 2.0 volts, is delineated by the single isovolt contour on the right. Any hit by a laser inside that contour impresses a bit on the I2C bus.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Data Collection</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Here's what the raw data from one of those scans looks like (Figure 6). You're looking straight on at the LED; the big blue square is exactly five millimeters across. The curvy arc on the right hand side is an artifact of the dome lens on the LED, we think.</span></p><p><span>We can draw isovoltage contours (above, center) to begin to visualize how the voltage on the communication bus varies as the laser scans across the face of the LED. We're looking for the physical location where our laser can force the voltage on the circuit to go below the logic threshold.</span></p><p><span>The only one we're really interested in is the 2.0 volt contour line (Figure 6, right) because that's the value we found by experimentation to be the critical value. </span>This is the active area. Any hit by the laser inside that region alters the value of a bit. You can kind of see the outline of the square chip in the LED, or maybe that's just my imagination.</p><p><span>Anything outside that region is a miss. The size of the active area, in square millimeters, is a direct measure of how hard the target is to hit.</span></p><p><span>But there’s a problem.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">You can’t hit a target that isn’t there.</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Blinky lights are cool, but the hardware designer might not have put one where we need it, on the communication bus. And you can't shoot lasers at an LED that isn't there.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/microphotograph.jpeg?itok=VNKcQ9eP" width="1440" height="810" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 7: Electrostatic discharge (ESD) protection components on an I2C bus are similarly vulnerable, this time to an infrared laser. The microphotograph at upper left shows a magnified view of the tiny chip inside the board-mounted component at lower left, which is only 3 mm long. On the right is a complete set of scans made at 200 µm resolution of the ESD protection component shown here. Notice how the active area (in red) varies in size with logic family (5 V TTL in the top row, 1.8 V LVCMOS in the bottom row) and value of the pull-up resistor on the I2C bus (stronger pull-up to the left, weaker pull-up to the right).</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">It’s not only LEDs</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>But I don't want to give you the impression that it's only status indicators, or only LEDs; the definition of “accessible P–N junction” is wider than that. Figure 7 shows a microphotograph of the silicon chip inside an electrostatic discharge protection (ESD) component like the one at the lower left—which are found on shared communication buses, because they're susceptible to static electricity—and are even more sensitive than LEDs.</span></p><p><span>Here you can see the results of a lot of repeated runs against one of those. Notice how the active area, in red, gets larger as you move down the chart, and as you move toward the right. As the system voltage decreases, from 5 V TTL to 3.3 V CMOS, through 2.5 V low-voltage CMOS, by the time we get down to 1.8 volt LVCMOS, on the bottom row, we can force the value of a bit against any reasonable value of pull-up resistor. The values shown here bracket the range of pull-up resistor values, from 1 kΩ (fast, but power-hungry), to 2.2–4.7 kΩ (typical), to 10 kΩ (slow, but suitable for low-power devices that need to conserve battery). </span></p><p><span>Now we have a model that makes testable predictions. For any combination of LED color, laser wavelength, logic family, and pull-up resistor value, we can predict if it's reversible.</span></p><p>Note that the active area on the ESD protection component is quite a bit smaller than an LED. The chip is only about 125 microns across, and it’s off-center in the gap. So it's a challenging target to hit.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/beam_axis_rotation.jpg?itok=Xb8TnwrK" width="1038" height="954" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 8: Effect of elliptical beam axis rotation on the active area.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>It’s not isomorphic, either; Figure 8 shows the effect of elliptical beam axis rotation on the size of the active area. Recall from the microphotograph that the silicon chip is buried deep in a narrow slot between metal electrodes. Solid-state lasers emit an elliptical beam (corrected to circular with optics in more expensive lasers than the ones we have) and the semimajor axis of the elliptical beam pattern interacts with the narrow slot in interesting ways.</span></p><p>By the way, LEDs tend to respond best to short wavelength visible lasers, but we found the most effective laser wavelengths for silicon ESD protection components to be in the invisible infrared, outside visual range. This means the attack is stealthy.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Proof of Concept</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><a href="https://youtu.be/LgtlJqiiQAk" target="_blank" title="Video showing successful attack that changes the text output" rel="nofollow">This video</a> shows a working proof of concept, running on a live I<sup>2</sup>C bus. The controller is trying to write the message NORMAL OPERATION on the display; the laser is trying to write the message PROOF OF CONCEPT. The laser and the bus controller are fighting over the bus, and the laser is generally winning.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Summary and Conclusions</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Our's is a measurement paper, not a practical attack. It opens a whole new area of reverse side channel analysis, extending the concept of glitching to ranged attack. The bar is set: remote code execution. But what did we overlook? How far away is practicable? Given a 50 W source at 405 nm, if you need to put 5 mW within a 5 mm circle at the target, that gives you 40 dB of link budget, for atmospheric attenuation, refraction through window glass, and angle of incidence.</span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Joe Loughry and Kasper Rasmussen. "Basilisk: Remote code execution by laser excitation of P–N junctions without insider assistance”. In <em>18th USENIX WOOT Conference on Offensive Technologies (WOOT’24)</em>, pages 245–261, Philadelphia, 12–13 August 2024. <a href="https://www.usenix.org/conference/woot24/presentation/loughry">https://www.usenix.org/conference/woot24/presentation/loughry</a></p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Bret Giller. "Implementing Practical Electrical Glitching Attacks". In <em>Black Hat Europe,</em> Amsterdam, 10–13 November. <a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf" rel="nofollow">https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-...</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] D. H. Habing. “The use of lasers to simulate radiation-induced transients in semiconductor devices and circuits”. <em>IEEE Transactions on Nuclear Science</em>, <strong>12</strong>(5):91–100, 1965.</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Sergei P. Skorobogatov and Ross J. Anderson. “Optical fault induction attacks”. In <em>4th International Workshop on Cryptographic Hardware and Embedded Systems (CHES)</em>, Redwood Shores, California, USA, 13–15 August 2002.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Sam Beaumont and Larry Trowell. “Laser beams &amp; light streams: Letting hackers go pew pew, building affordable light-based hardware security tooling”. In <em>Black Hat USA</em>, Las Vegas, Nevada, 3–8 August 2024. https: //<a href="http://www.blackhat.com/us-24/briefings/schedule/index.html#laser-beams--light-streams-letting-hackers-go-pew-pew-building-affordable-light-based-hardware-security-tooling-39708" rel="nofollow">www.blackhat.com/us-24/briefings/schedule/index.html#laser-beams--light-...</a></p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Peter Wright. <em>Spycatcher: the candid autobiography of a senior intelligence officer.</em> New York: Viking Press, 1987. ISBN 978-0670820559</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] National Security Agency. "TEMPEST: a signal problem". <em>Cryptologic Spectrum</em>, 1972. <a href="https://web.archive.org/web/20130918021523/http://www.nsa.gov/public_info/_files/cryptologic_spectrum/tempest.pdf" rel="nofollow">https://web.archive.org/web/20130918021523/http://www.nsa.gov/public_inf...</a></p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Paul Kocher, Joshua Jaffe, and Benjamin Jun. "Differential Power Analysis". In <em>Proceedings of the 19th Annual International Cryptology Conference on Advances in Cryptology (CRYPTO 99)</em>, pages 388–398, Santa Barbara, California, 15–19 August 1999. <a href="https://paulkocher.com/doc/DifferentialPowerAnalysis.pdf" rel="nofollow">https://paulkocher.com/doc/DifferentialPowerAnalysis.pdf</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] D. E. Rosenheim. "Installation of the first production 701". <em>IEEE Annals of the History of Computing</em>, <strong>5</strong>(2):146–147, April–June 1983.</p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10] Kelly Fiveash. "'Camera-shy’ Raspberry Pi 2 suffers strange ‘XENON DEATH FLASH’ glitch. <em>The Register</em>, 8 February 2015. <a href="https://www.theregister.com/2015/02/08/raspberry_pi_2_camera_flash_glitch/" rel="nofollow">https://www.theregister.com/2015/02/08/raspberry_pi_2_camera_flash_glitch/</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-11"></a><p>[11] Paul Rako. "EEVblog #901 - Raspberry Pi 3 photoflash problem". 16 July 2016. <a href="https://www.youtube.com/watch?v=dDcsTnqVgWc" rel="nofollow">https://www.youtube.com/watch?v=dDcsTnqVgWc</a></p> </div><div class="field-item even"><a class="anchor" name="reference-12"></a><p>[12] Niclas Kühnapfel, Stefan Preußler, Maximilian Noppel, Thomas Schneider, Konrad Rieck, and Christian Wressnegger. “LaserShark: Establishing Fast, Bidirectional Communication into Air-Gapped Systems”. In <em>Proceedings of the 37th Annual Computer Security Applications Conference (ACSAC)</em>, pages 796–811, Online, 6–10 December 2021. DOI: 10.1145/3485832.348591.</p> </div><div class="field-item odd"><a class="anchor" name="reference-13"></a><p>[13] Mordechai Guri. “Mind The Gap: Can Air-Gaps Keep Your Private Data Secure?”. 6 September 2024. DOI: 10.48550/arXiv.2409.04190, or arXiv:2409.04190 [cs.CR].</p> </div><div class="field-item even"><a class="anchor" name="reference-14"></a><p>[14] Takeshi Sugawara, Benjamin Cyr, Sara Rampazzi, Daniel Genkin, and Kevin Fu. “Light Commands: Laser-Based Audio Injection Attacks on Voice-Controllable Systems”. Unpublished, 4 November, 2019. <a href="https://lightcommands.com/" rel="nofollow">https://lightcommands.com/</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-15"></a><p>[15] Sara Rampazzi, Benjamin Cyr, and Daniel Genkin. “Light Commands: Hacking Voice Assistants with Lasers”. In <em>Black Hat Europe 2020</em>, Virtual, 7–10 December 2020. <a href="https://www.blackhat.com/eu-20/briefings/schedule/index.html#light-commands-hacking-voice-assistants-with-lasers-21731" rel="nofollow">https://www.blackhat.com/eu-20/briefings/schedule/index.html#light-comma...</a></p> </div><div class="field-item even"><a class="anchor" name="reference-16"></a><p>[16] Andy Greenberg. “Hackers Can Use Lasers to ‘Speak’ to Your Amazon Echo or Google Home”. <em>Wired</em>, 4 December 2019. <a href="https://www.wired.com/story/lasers-hack-amazon-echo-google-home/" rel="nofollow">https://www.wired.com/story/lasers-hack-amazon-echo-google-home/</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-17"></a><p>[17] Shenzhen Xuancai Electronic Co., Ltd. “Color Changing LED”. Shen Zhen, China, 2011. <a href="http://cdn.sparkfun.com/datasheets/Components/LED/changingLED.pdf" rel="nofollow">http://cdn.sparkfun.com/datasheets/Components/LED/changingLED.pdf</a></p> </div><div class="field-item even"><a class="anchor" name="reference-18"></a><p>[18] Qipeng Semiconductor Co., Ltd. “CDT3447 3 LED Fade-in and fade-out output control IC, 2008”. <a href="http://www.bowin-ic.com.hk/IC/LED%20flasher%20IC/CDT3447.pdf" rel="nofollow">http://www.bowin-ic.com.hk/IC/LED%20flasher%20IC/CDT3447.pdf</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">Hardware</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/navigating-kubernetes-odyssey"
                    >Navigating the Kubernetes Odyssey</a>
                </h2>

                                    <time datetime="2024-09-04 00:00:00">
                        2024-09-04 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Raúl Benencia</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Bare Metal Days</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>ThousandEyes’ infrastructure has humble origins. Around the year 2010, our founders scavenged the first servers out of the recycling bins of bigger companies in Silicon Valley, and quickly set them to run in a garage in Mountain View. Against all odds, ThousandEyes grew: bigger customers, bigger contracts, and, of course, bigger reliability concerns. Having a proper infrastructure in place was in order, so the scavenged servers were repurposed and racked in a data center. A few years later, pricing and location compelled a migration to another data center close to the company's headquarters in downtown San Francisco.</span></p><p><span>Around 2015, ThousandEyes’s main infrastructure consisted of four racks with a bunch of servers, some of them running Xen on Debian, and our main application, a Software-as-a-Service (SaaS) offering, running on three Virtual Machines (VMs) behind a physical load balancer distributed between three of those racks–a standard setup at that time.</span></p><p><span>The company was growing faster than we could scale our infrastructure, so we had to design a solution for hyper-scaling. That's when Kubernetes came into the picture. Today, it sounds like the obvious solution, but when we started experimenting with it, we didn't know if it would live up to the hype. Our platform was made of, for the most part, monolithic applications. Our software footprint was small enough, and containerizing everything was a daunting but doable effort. This was our first big migration.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">The First Cluster</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Our first iteration of the cluster was running the now defunct CoreOS, with Kubernetes version 1.1.2; we named it<em> k8s1</em>. We hosted absolutely everything in our data center: Continuous Integration (CI) pipeline, Docker registry, etcd cluster, Kubernetes control plane. The original four racks expanded to a cage with ten racks. Each Kubernetes worker was a bare-metal server that had to be racked by our team and bootstrapped using <a href="https://github.com/thousandeyes/shoelaces" rel="nofollow">Shoelaces</a>, an in-house server bootstrapping automation tool we open-sourced years ago.</span></p><p><span>CoreOS was new to us; the rest of our fleet was running Ubuntu 14.04 at that time, and servers were configured using Puppet 3. Being new to the Kubernetes world and running containerized applications, we took the bait and chose that OS. It made perfect sense in theory: a container-optimized Operating System (OS) for a container orchestration system such as Kubernetes. In practice, it was not the right fit for us, as we did not find it flexible enough. Most components were configured at boot time with a configuration file known as cloud-init, which meant we were not able to use our existing Puppet code base. Additionally, running custom processes and kernel modules was not straightforward; for example, we went through painful debugging sessions to integrate CoreOS with our network file system at that time, GlusterFS. We decided to migrate the cluster to Ubuntu, enabling us to use our then-modern Puppet 5 code base present in the rest of our infrastructure. It was early 2018, and we were running Kubernetes version 1.5.4.</span></p><p><span>This migration was simple but painful. The preparation phase involved writing a few Puppet modules and rounding a few sharp edges in Ubuntu to befriend it with our Kubernetes setup. During the implementation phase, we had to remove each CoreOS worker from the load balancer, shut it down, and use Shoelaces to bootstrap the server again with the new operating system. Slowly but surely, we pulled the tablecloth out from under the dishes, and our developers barely felt it.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Jumping Ships</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We were a small team, busy and distracted by the myriad migrations and maintenance we were doing on the cluster itself, so we neglected to update <em>k8s1</em> for several versions. We were stuck in 1.5 and upstream was already in 1.13</span><span>—</span>a non-negligible version lag.</p><p><span>Additionally, our Continuous Integration and Continuous Delivery (CI/CD) pipeline was not robust when it came to Kubernetes manifests. We used to have an internal tool, triggered by Jenkins, that would deploy manifests for us whenever there was a commit with a change in a given directory within each of our git repos. This approach made drift detection extremely challenging, as there was no way to visualize it. Additionally, the tool was not robust and it would fail to recognize some Kubernetes resources, or even crash when trying to parse a Git commit message–the kind of issues one typically deals with when building internal tools. In such situations, one encounters a build-versus-buy dilemma. However, in our case, being early adopters, we had no choice but to build as there were no strong solutions available in the market.</span></p><p><span>These were some of the circumstances that propelled us to spin up a new cluster instead of updating the existing one. We named it <em>k8s2</em>, and at bootstrap time, it was running version 1.15.3 in Ubuntu servers managed by Puppet 5.</span></p><p><span>We decided to pair the migration to this cluster with a radical change in how we deployed our manifests. We switched to a GitOps-based approach using ArgoCD, choosing it due to its strong community and ease of visualizing and remediating drift. With the help of upper management, we recruited the whole engineering department for this effort. Each team owned its Kubernetes manifests in their own Git repositories with their own Git practices, making it impractical for a single team to do all the work. With this new approach, we moved Kubernetes manifests into a separate repository. Our workloads would now have an extra repository with just Kubernetes manifests—all of them buildable with kustomize, a Kubernetes native configuration management tool.</span></p><p><span>Mid-migration from <em>k8s1</em> to <em>k8s2</em>, we finally committed to something we knew had to happen sooner rather than later: migrating to a cloud provider.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Sailing to the Clouds</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Given the imminent expansion of our infrastructure, the need for another region in Europe, and a disaster recovery environment, using bare metal was no longer an option.</span></p><p><span>We needed to consider whether this decision to migrate to a cloud provider would change the course of our migration from <em>k8s1</em> to <em>k8s2</em> or if we would keep it the same way and only think about it once we finished. It was a trade-off we needed to consider. We decided to complete the migration to <em>k8s2</em> given that we had the momentum and know-how in place, and at that time, many things were unknown to us regarding Amazon Web Services (AWS), our chosen provider.</span></p><p><span>The main requirement was to use AWS <em>us-west-1</em> as our main region, given its close proximity to our data center in downtown San Francisco. There were, however, a couple limiting factors. Elastic Kubernetes Service (EKS), AWS' hosted Kubernetes product, was not available in that region, and the region only had two availability zones (AZs). Yet another trade-off to consider: do we wait for AWS to add EKS support? Or do we deploy our Puppet-managed cluster in Elastic Cloud Compute (EC2) instances?</span></p><p><span>We did not have a clear date from AWS and wanted a timeline we could control, so we decided to go via the difficult path and run Kubernetes directly on EC2s. We connected our data center and AWS <em>us-west-1</em> with AWS Direct Connect (a product that connects private on-prem networks with Virtual Private Clouds) and added Kubernetes workers on AWS.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig1_1.png?itok=vOv45rjM" width="1440" height="482" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1. EC2 workers communicating with the data center Kubernetes cluster.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>The AWS workers had taints so that our workloads wouldn't indiscriminately run in a different environment. “Taints” are node repellents that prevent pods from landing in that node. The counterpart to taints are “Tolerations”, which allow for pods to get scheduled despite the taints. Taints are applied to nodes, and tolerations to pods.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>$ kubectl describe no k8s2-1-a<br /> Name:               k8s2-1-a<br /> &lt;...&gt;<br /> Taints:             site=sfo2:NoSchedule</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 1. A Kubernetes node with taints.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Our first EC2 workers connected to the data center Kubernetes control plane. We later added control plane nodes in AWS that maintained communication with the etcd cluster in the data center (etcd is a strongly-consistent distributed data store which the Kubernetes control plane uses to store critical state). The AWS-based Kubernetes workers connected to the new AWS control plane. Data center workers would still connect to the data center control plane. Under the hood, all the control plane nodes were connected to the etcd cluster, which was still running in the data center, but not for much longer.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig2_0.png?itok=v8S1dew5" width="1440" height="482" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2. EC2 workers and control plane nodes communicating with the etcd cluster in the data center.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Migrating the etcd cluster was a different dance. We only had two AZs, but we needed three to ensure high availability, proper quorum, and avoid split-brain situations.</span></p><p>According to the etcd documentation [1], <em>"an etcd cluster needs a majority of nodes, a quorum, to agree on updates to the cluster state. For a cluster with n members, quorum is (n/2)+1. For any odd-sized cluster, adding one node will always increase the number of nodes necessary for quorum. Although adding a node to an odd-sized cluster appears better since there are more machines, the fault tolerance is worse since exactly the same number of nodes may fail without losing quorum but there are more nodes that can fail. If the cluster is in a state where it can’t tolerate any more failures, adding a node before removing nodes is dangerous because if the new node fails to register with the cluster (e.g., the address is misconfigured), quorum will be permanently lost."</em></p><p><span>We ended up bootstrapping one node in <em>us-west-2 </em>and two nodes in each <em>us-west-1</em> AZ, for a total of five. The Kubernetes control plane was configured to point only to the <em>us-west-1</em> etcd nodes. The synchronization with the fifth node happened in the background. This was not an ideal solution, but it worked well enough for us without incurring noticeable latency. In the unlikely event of a <em>us-west-1</em> AZ going down, latency would have slightly increased, especially under a constant stream of updates in the cluster. However, our cluster did not have that usage pattern, and ultimately, this increase would not have been significant enough to impact customers.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig3_0.png?itok=9ajc3CmS" width="1440" height="678" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3. Using an AZ in the us-west-2 region to achieve High Availability (HA) in etcd.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>A notable difference in our AWS setup was the use of auto-scaling groups. We no longer had to rack and bootstrap new workers whenever we needed to scale. Instead, we decided to designate one ASG per team to segregate costs and noisy neighbors. We would control this behavior with node selectors and tolerations.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>nodeSelector:<br />   asg: webapps<br /> tolerations:<br /> - key: &quot;asg&quot;<br />   operator: &quot;Equal&quot;<br />   value: &quot;webapps&quot;<br />   effect: &quot;NoSchedule&quot;</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 2. A workload specifying a node selector and tolerations.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In retrospect, this might not have been the brightest idea. These requirements can easily metastasize, and we were now requiring team members to add node selectors and tolerations to all their workloads. A better approach would have been to compute these fields automatically based on, for example, the namespace to which they belong.</span></p><p><span>Workloads were migrated progressively at each team's discretion. Such was our luck that, when we were about 70% done, AWS announced EKS support in <em>us-west-1</em>. We thought about bootstrapping a new managed cluster and completing the migration there, given that it could save us from throwaway work. However, we considered this tradeoff and decided to finish the existing migration, given that there were many uncertainties in how we would implement EKS. Additionally, our staging environment had already been migrated. Starting anew would mean an environmental disparity, putting us in a precarious situation. We concluded that sometimes it makes sense to do throwaway work in the name of reliability.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">New Waters</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>ThousandEyes was experiencing growth, with a significant portion of our customer base located in Europe. Thus, the latency we had to our platform in <em>us-west-1</em> was unacceptable, and expanding to a new region became paramount. We chose <em>eu-central-1</em>, a region with three AZs and full support for EKS.</span></p><p><span>We developed Terraform code to bootstrap an EKS cluster and mimic the per-team Autoscaling Groups (ASGs) we had in <em>k8s2</em>. Our vision was to spin up a ready-to-be-used cluster with a single pull request. In practice, we faced a few challenges that forced us to split the code into multiple layers: bootstrapping the cluster, installing core services via Terraform, and setting up load balancers.</span></p><p><span>In a relatively short amount of time, we had our new cluster, <em>eks1</em>, ready to be used. Our engineers were able to spin up their services, and shortly after, we started serving some of our customers in our EU region.</span></p><p><span>Shortly after our first EKS cluster was ready, we started receiving requests for more clusters: disaster recovery, team-specific, tool-specific, etc. We used each cluster to improve our bootstrapping process. Our Infrastructure as Code (IaC) modules allowed us to have cookie-cutter EKS clusters relatively quickly.</span></p><p><span>It was clear that we needed to manage these clusters uniformly, and for the most part, we could do so. For example, if we needed to update cluster-autoscaler in all our clusters, a single commit would have sufficed. However, there was still one outlier.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">The Anchor</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Even though we were running close to ten EKS clusters at that time, our main cluster, <em>k8s2</em>, which hosted our SaaS platform, continued to serve customers. Our small team, responsible for all our Kubernetes infrastructure, shifted its focus to developing EKS modules. Consequently, the maintenance of <em>k8s2</em> was relegated to a secondary priority. Once again, our main cluster became outdated, lagging several minor versions behind the EKS clusters.</span></p><p><span>Our ideal scenario was clear: we aimed to run everything seamlessly on EKS under uniform management. Faced with a new trade-off, we chose to focus our limited time on designing a migration to EKS rather than coordinating an upgrade in <em>k8s2</em>. As a consequence, inconsistencies between our environments started pouring in like rain due to deprecated APIs and new features. We handled those inconsistencies with kustomize patches.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>patchesJson6902:<br />   - target:<br />       group: networking.k8s.io<br />       version: v1<br />       kind: &#039;Ingress&#039;<br />       name: &#039;.*&#039;<br />     patch: |-<br />       - op: replace<br />         path: &quot;/apiVersion&quot;<br />         value: networking.k8s.io/v1beta1</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 3. Patching a manifest to use an earlier version of the Ingress API.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>This situation wasn’t sustainable and could quickly spiral out of control. Our main cluster, <em>k8s2</em>, was anchoring us to technical debt. </span></p><p><span>To compound the issue, <em>k8s2</em> had a hard limit of 256 nodes. We were using Flannel as our network fabric, with the default size for its pod CIDR network:  /16.  Out of that network, each node would get its own /24, accounting for a total of 256 nodes. We were already using over 200, and although we had some room for growth, it was a looming concern.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">The Gangway</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>There we were again, having to coordinate a new cluster-to-cluster migration. It felt like we had to migrate <em>k8s1</em> to <em>k8s2</em> all over again, but we were in a different state this time.</span></p><p><span>Throughout our Kubernetes journey, two important things happened. We scaled at a cluster level, running hundreds of services, and the teams using the cluster grew. We could not make this migration the same way because tracking execution across all our teams would have been a nightmare. Instead, we used this as an opportunity to create homegrown tooling and automate.</span></p><p><span>We always lacked the right “excuse” to implement a service mesh, but we seized the migration as the perfect opportunity to do so. This change would allow our services to communicate with each other regardless of the cluster in which they reside. After a few weeks of research, we settled on using Istio. </span></p><p><span>In our opinion, it had the right balance between project maturity and community support. We learned the ropes and installed it in <em>k8s2</em>. Additionally, we bootstrapped a new EKS cluster, <em>eks1</em>, in the same region and connected the clusters using an east-west gateway.</span></p><p><span>However, we still had to incorporate our services into the mesh. We did this semi-manually, namespace by namespace:</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>if [ &quot;$OP&quot; == &quot;enable&quot; ]; then<br />   kubectl label --overwrite ns &quot;$NS&quot; istio.io/rev=$ISTIO_REVISION<br /> elif  [ &quot;$OP&quot; == &quot;disable&quot; ]; then<br />   kubectl label ns &quot;$NS&quot; istio.io/rev-<br /> fi</p> <p>if [ &quot;$RESTART&quot; == &quot;true&quot; ]; then<br />   for i in $(kubectl -n &quot;$NS&quot; get deploy --no-headers | grep -v &#039;0/0&#039; | cut -d&#039; &#039; -f1); do<br />     kubectl -n &quot;$NS&quot; rollout restart deploy &quot;$i&quot;<br />   done<br /> fi</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 4. A script to enable/disable Istio and optionally restart workloads.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We started parallel workloads in <em>eks1</em>, but we needed to make sure validations were done before they started receiving traffic. To control these knobs, we leveraged Istio's traffic control primitives. We set a DestinationRule for each workload to define subsets based on the network they were part of.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>apiVersion: networking.istio.io/v1beta1<br /> kind: DestinationRule<br /> metadata:<br />   name: webapps-ing-ctrl.webapps.svc.cluster.local<br /> spec:<br />   host: webapps-ing-ctrl.webapps.svc.cluster.local<br />   subsets:<br />     - labels:<br />         topology.istio.io/network: k8s2.prd.sfo2<br />       name: k8s2<br />     - labels:<br />         topology.istio.io/network: eks1.prd.sfo2<br />       name: eks1</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 5. A DestinationRule to define workload&#039;s subsets.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Additionally, we used a VirtualService for each workload to control which cluster was serving requests. This approach enabled us to slowly ramp up workloads into <em>eks1</em> to validate that our platform was working as expected before committing all the traffic.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>apiVersion: networking.istio.io/v1beta1<br /> kind: VirtualService<br /> metadata:<br />   name: webapps-ing-ctrl.webapps.svc.cluster.local<br /> spec:<br />   hosts:<br />     - webapps-ing-ctrl.webapps.svc.cluster.local<br />   http:<br />     - route:<br />         - destination:<br />             host: webapps-ing-ctrl.webapps.svc.cluster.local<br />             subset: k8s2<br />           weight: 0<br />         - destination:<br />             host: webapps-ing-ctrl.webapps.svc.cluster.local<br />             subset: eks1<br />           weight: 100</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 6. A VirtualService to control workload&#039;s traffic.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Given that we had to do this dance for each workload, we automated the process by generating these manifests programmatically.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>$ ./bin/generate-migration-manifests \<br />     --src-env-dir environments/staging/us-west-1/k8s2/ \<br />     --dst-env-dir environments/staging/us-west-1/eks1/ \<br />     --kube-ctx k8s2.stg.sfo2 \<br />     --ns agent --svc agent-service<br /> [+] Generating yaml for agent-service.agent in environments/staging/us-west-1/k8s2/agent/agent-service.yaml<br /> [+] Generating yaml for agent-service.agent in environments/staging/us-west-1/eks1/agent/agent-service.yaml</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Code 7. Automated generation of traffic control manifests.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We executed this migration across several weeks, focusing on one namespace at a time. We decided not to do the entire migration in staging and to do it later in production instead because we knew it was a big effort that would span weeks if not months, and we could not afford to lose parity between our environments. </span></p><p><span>Instead, we migrated a namespace in staging, validated it, and then migrated the same namespace in production. Some namespaces were bigger and more difficult than others, and we would take several days to complete the migration safely. During a namespace migration, the owning team was interrupted minimally to validate that their services were acting normally. We were able to use Istio metrics to validate that the traffic was going to the new cluster, as shown in Figure 4. </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig4_0.png?itok=bqMrwWxa" width="1440" height="681" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4. Using Istio metrics to visualize the cluster switch.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>sum by (app, destination_cluster)(rate(istio_requests_total{destination_workload_namespace=&quot;accounting&quot;,dc=~&quot;dc1|sfo2&quot;}[1h]))</p> </div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Metrics query used to visualize the cluster switch.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Not everything was smooth sailing. On a few occasions, we had to revert a whole day’s worth of work due to problems running the workloads in <em>eks1</em>. On one occasion, we noticed lag piling up on one of our Kafka clusters. Kafka, a distributed event streaming platform, was holding up events, and the just-migrated workloads in <em>eks1</em> were not processing them fast enough. After rolling back and analyzing what went wrong, we realized that the ASG in <em>eks1</em> had a weaker instance type than what we were using in <em>k8s2</em>. Once fixed, we retried that migration, and the new workers in <em>eks1</em> were able to withstand the pressure from the Kafka workloads.</span></p><p><span>Another issue arose due to mismatched configurations between the nodes. Our <em>k8s2 </em>nodes had a specific TCP keepalive time that was required to interact with a database. That <em>k8s2</em> configuration was deep in our Puppet code, and we missed setting it on our managed <em>eks1</em> nodes. As a result, some pods were timing out in their connections to the database. Naturally, porting said configuration solved the issue.</span></p><p><span>An additional mishap occurred due to mismatched security groups. A few pods needed to interact with parts of our infrastructure not hosted in Kubernetes and were failing to do so because we missed adding eks1 nodes to their allow-list. Once we identified this situation, we looked for all security groups where <em>k8s2</em> nodes were being allowed, and we also added <em>eks1</em> nodes to make sure that no other migrated workload would hit the same problem.</span></p><p><span>And so, with this approach, even though we faced a few rough patches along the way, we were able to migrate a cluster used by 20+ teams with hundreds of workloads without involving the whole engineering department. We gracefully got away from the old cluster and docked into the safe harbor of our new infrastructure. We left <em>k8s2</em> safely, which served us well until the very end.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Epilogue</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In this article I presented a real-life scenario of an early Kubernetes adopter who significantly expanded their organization and workloads over time. If the team is small, a delicate balance must be kept between sustainably modernizing the infrastructure versus keeping the lights on with day-2 operations. Behind Kubernetes lies a sea of complexity. Managed clusters offer a degree of automation but do not serve as a panacea. Even with these, cluster administrators must ensure manifests remain valid across updates. In a small cluster with few users, the responsibility of updating these manifests can fall to their owners. In larger clusters, automation becomes crucial to avoid a coordination nightmare.</span></p><p><span>I've often read, with quiet envy, about people smoothly upgrading and migrating entire Kubernetes clusters using a blue-green approach or other sparkly techniques. While I'm convinced of its feasibility, not every organization possesses the necessary maturity to do so. Ours certainly didn't. The trade-offs we chose were appropriate for our circumstances, considering the diversity of our workloads and the tools and techniques available to us at the time. As we navigate these complexities, we keep learning, improving, and moving forward—step by step, cluster by cluster.</span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] etcd Frequently Asked Questions.&nbsp;<a href="https://etcd.io/docs/v3.3/faq/ " rel="nofollow">https://etcd.io/docs/v3.3/faq/ </a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">SRE</li>
                                                    <li class="category">Cloud</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/artificial-intelligence-and-new-economics-cyberattacks"
                    >Artificial Intelligence and the New Economics of Cyberattacks</a>
                </h2>

                                    <time datetime="2024-08-29 00:00:00">
                        2024-08-29 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Vaibhav Garg</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Information security is hard in part because of the underlying</span> economics of attack and defense. Different economic models result in distinct equilibria: some favor attackers, whereas others advantage defenders. These equilibrium positions may change with the introduction of powerful new Large Language Models (LLMs).</p><p>In this article we investigate three key impacts of these AI-based disruptions. First, emerging Artificial Intelligence (AI) capabilities may increase both the number of attackers as well as the types of cybercrime they engage in. Second, we discuss how these capabilities will be developed by a small set of players, which will potentially increase concentration in cybercriminal markets. Third, finally as both attackers and defenders attempt to use AI, the asymmetry between attackers and defenders will decrease. Thus, we show how AI will impact the economic functioning of cybercrime markets.</p><h2>1. Introduction</h2><p>In Isaac Asimov’s famous Foundation Series [<a href="#reference-1" target="_blank" title="1" rel="nofollow">1</a>], the protagonist Harry Sheldon was able to  model, and thus predict, humanity’s future until the emergence of a new unforeseen  ‘technology’ in the form of mutants. Similarly, the emergence of Generative AI and  associated Large Language Models (LLMs) threaten to disrupt our traditional understanding  of Cybersecurity Economics, particularly the models of cyberattack and cyber defense. AI  may therefore fundamentally reshape the structure of cybercriminal organizations and  markets.</p><p>This transformation may then in turn impinge or assist defender efforts. Consider that LLMs may be used to generate more convincing social engineering attacks  (e.g., phishing emails), reduce the effort to build malware (e.g., by automatically writing  code), or be used to generate attacks by highly sophisticated persistent threat actors,  previously exclusive in the domain of nation state attackers according to recent research by  Nickson Quak from the Cyber Threat Alliance [<a href="#reference-2" rel="nofollow">2</a>]. According to Lin et al., attackers may  jailbreak mainstream LLMs or alternatively they may leverage malicious LLMs designed for  nefarious purposes, e.g., WormGPT, FraudGPT [<a href="#reference-3" rel="nofollow">3</a>]. These developments create the  impression that AI fundamentally advantages the attacker.</p><p>Yet AI has traditionally been the  tool of cyber defenders. AI-based tools have been used in cybersecurity for spam/phishing  detection, intrusion detection, malware detection, vulnerability scanning and remediation,  etc. [<a href="#reference-4" rel="nofollow">4</a>]. The market for AI in cybersecurity, according to Taddeo et al., is expected to grow by  an order of magnitude by 2025 compared to 2016 [<a href="#reference-5" rel="nofollow">5</a>]. Prior work by Gupta et al. highlights  how emerging AI like LLMs also promise to advance defender capabilities [<a href="#reference-6" rel="nofollow">6</a>]. LLMs can be  used to reduce the amount of technical expertise needed by a Security Operations Center  (SOC) analyst by collating multiple indicators of compromise and providing the combined  intelligence in a human readable format. They can be used to conduct code reviews for  security. They can also be used to generate patches more quickly for known vulnerable code.  What then is the overall impact of AI on the dynamics between attackers and defenders?</p><p>In  this article we attempt to address this by looking at three questions. First, what is  the impact of AI on organized cybercrime? Second, what is the impact of AI on reliability of  cybercrime markets? Third, what is the impact of AI on attacker and defender capabilities? We make three corresponding contributions investigating the overall impact of AI on the  dynamics between attackers and defenders:</p><ol><li>Exemplify how AI may increase both the number of cybercriminals and the types of  cybercrimes they engage in. </li><li>Demonstrate how economic forces of AI-powered tools may cause further concentration  of power in the cybercriminal market within an even smaller set of actors (i.e., cybercriminal organizations). </li><li>Present a case of how AI may decrease the asymmetry between attackers and defenders  regardless of the model. </li></ol><p>The rest of the article is organized as follows. Section 2 discusses organization in cybercrime.  In Section 3, we reframe the question of system reliability for cybercrime products through  relevant economic models. Section 4 presents the two canonical models of attack and defense. In section 5 we discuss how AI may inform the economic models discussed in  Sections 3 and 4. Section 6 concludes with a discussion of future work. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">2. Rise of Organized Cybercrime </div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Why do individuals engage in cybercrime? One explanation is that the entry barrier for  engaging in criminal activity is lower than that for engaging in legitimate activity [<a href="#reference-7" rel="nofollow">7</a>, <a href="#reference-8" rel="nofollow">8</a>].  However, a recent report from the National Security Telecommunications Advisory  Committee (NSTAC) claims that investments in cybersecurity by defenders have made it  more difficult to engage in cybercrime [<a href="#reference-9" rel="nofollow">9</a>]. Consequently, while the marginal cost of  cybercrime has gone up the marginal benefits have gone down. It can then be argued that  cybercriminals have responded in line with Coase’s theory of the firm to become organized  and thus also become specialized [<a href="reference-10" rel="nofollow">10</a>].</p><p>Prior research by Garg et al. notes that cybercriminals typically organize as either gangs or  mobs [<a href="#reference-11" rel="nofollow">11</a>]. Gangs are characterized by a central leader. The organization size of gangs is  impinged by Dunbar limits [<a href="#reference-12" rel="nofollow">12</a>], which is typically 100-230 members. Such gangs specialize  in a narrow set of cybercrimes to leverage competitive advantage. In contrast, mobs are  characterized by a complex hierarchy with multiple leaders so that there is no single critical  link that can collapse. Organization size of mobs have a larger portfolio of cybercriminal  activity.</p><p>Additional organization and cooperation for these organized cybercrime enterprises are  driven by the technical complexity of conducting cybercrime. Consider that to run a  successful ransomware campaign, an attacker will need access to phishing infrastructure,  access to malware authors or pre-packaged ransomware along with decryption keys, and a  support service agent who can respond to queries from infected “customers”. Arguably, as  Collier et al. mention, running a cybercriminal enterprise is akin to running a standard IT  company [<a href="#reference-13" rel="nofollow">13</a>]. </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">3. Cybercrime’s System Reliability Problem</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Cybercriminal organizations can thus be treated as individual ‘companies’ that produce  competing or complementary products. In the former case, they may integrate horizontally  to increase market size and benefit from economies of scale. In the latter case they may  integrate vertically to benefit from process efficiencies. These integrations may allow  cybercriminal seller organizations in a cybercrime marketplace to differentiate their  products more easily to cybercriminal buyer organizations [<a href="#reference-14" rel="nofollow">14</a>].</p><p>The customer focus on these markets means that sellers need to ensure that the products  offered as Cybercrime-as-a-Service (CaaS) on sale are reliable [<a href="#reference-15" rel="nofollow">15</a>]. Considering these CaaS  offerings as a system, we can apply Varian’s [<a href="#reference-16" rel="nofollow">16</a>] three distinct models for system reliability.</p><p>Consider a market where various stages of a cybercrime product’s supply chain are  controlled by distinct agents. For example, for a ransomware product one agent may provide  the phishing infrastructure, another agent may provide the malware, and a third agent may  provide the customer service. The success of the ransomware product in this case would be  controlled by the least reliable element of the supply chain or the weakest link. In this  scenario the agent with the least benefit cost ratio controls the system reliability. More  importantly, as Varian [<a href="#reference-16" rel="nofollow">16</a>] notes, increasing the number of agents decreases the reliability  of the system. Thus, to produce a more reliable cybercriminal product – cybercriminal  organizations will aim to consolidate the various stages of cybercrime tools production and  absorb functions of two or more of its supply chain agents. This would lead to greater vertical  integration.</p><p>Consider a different market where products are vertically integrated; however, multiple  cybercriminal organizations offer competing products as Anderson et al. points out [<a href="#reference-17" rel="nofollow">17</a>]. In  this case the reliability of the cybercriminal product will be determined by the best effort  model, i.e., the product ecosystem is as reliable as the most reliable product on the  cybercriminal market. Unsurprisingly in this case reliability will be decided by the agent with  the highest benefit-cost ratio. Consequently, agents with a lower benefit-cost ratio will  produce a less reliable product or would not produce products at all. If they do produce a  less reliable product, due to its lower reliability, it will be ignored by the customers in lieu of  more reliable ones. This condition occurs assuming that there is no information asymmetry  between the seller and the buyer as well as equivalent pricing between the two products.  Hence, agents with a lower benefit-cost ratio will either leave the market or be absorbed by  more successful agents (in the best effort model) so that the latter has more buyers. The  cybercrime market will then gravitate towards horizontal integration.</p><p>Varian highlights a third model where individual cybercriminals may cooperate to peer  produce cybercriminal products. Like Langlois and Garzarelli’s discussion of open-source  production of tools for legitimate use cases [<a href="#reference-18" rel="nofollow">18</a>], system reliability in this case depends on  the total effort of all the cybercriminals, but it will be decided by the agent with the highest  benefit-cost ratio (the best effort case).</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">4. Attack versus Defense</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>In the previous section, we discussed how economic factors drive the evolution of organized  cybercrime and associated markets. Eventually these cybercriminals and their tools must  face defenders. The success of cybercriminals in this case is combination of the economics  of attack and defense. The consensus, as highlighted by Ross Anderson’s work [<a href="#reference-19" rel="nofollow">19</a>] before  LLMs were commonly available for cybercrime, was that the economics of cybercrime favors  the attacker.</p><p>Consider the ransomware example introduced in the earlier section. Let us assume a model  in which an attacker sends a phishing email to all the employees at a company. Any  employee who clicks on the link in the phishing email can cause the ransomware to execute  and cause a security incident at the company. The attacker in this case needs to only find  one employee who makes an error. The defender needs to make sure that all employees have  a 100% rate of finding and mitigating phishing emails. The attacker can concentrate its  resources, while the defender must spread them out. Thus, the advantage under this model  is to the attacker.</p><p>However, this model would also depend on an organization’s maturity. Let us consider a  different model in which an organization implements Zero Trust Architecture [<a href="#reference-28" rel="nofollow">28</a>], i.e., where  individuals are not trusted by default and verification is needed before anyone can access  the organization’s resources. For such an organization, errors on one employee’s end would  need to be supplemented with several other cyberattacks working in tandem to ensure the  whole organization falls victim. Indeed, most successful breaches require a sequence of  attacks to execute one after the other in what is often described as a Cyber Kill Chain [<a href="#reference-20" rel="nofollow">20</a>,  <a href="#reference-21" rel="nofollow">21</a>]. Thus, the attacker needs to get lucky multiple times in a row, while the defender needs  to get lucky once in the chain as Slayton points out [<a href="#reference-22" rel="nofollow">22</a>]. This is the economic argument to  support the implementation of Zero Trust. </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">5. AI Impacts</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>In the previous sections we discussed how Economics drives organization in cybercrime, the  reliability of cybercrime products, and the relative advantage between attackers and  defenders. While the insights from these models have been useful, they will need to be  reconsidered now to address the impact of AI.</p><p>It is clear from the rise of FraudGPT and WormGPT, alongside legitimate but jailbroken LLMs,  that AI will make it easier to engage in cybercrime. Chui et al. have argued that AI will lead to  greater productivity [<a href="#reference-23" rel="nofollow">23</a>]; surely, this may apply to cybercriminal productivity as well [<a href="#reference-24" rel="nofollow">24</a>].  First, AI may reduce the amount of technical sophistication that is required to conduct  cybercrime. For example, according to a recent survey paper, an attacker may use LLMs to  help them generate malware [<a href="#reference-25" rel="nofollow">25</a>]. Second, it may improve the effectiveness of certain  cyberattacks. For example, a recent report says that an attacker may use LLMs to generate  more targeted, and therefore more compelling, phishing lures [<a href="#reference-26" rel="nofollow">26</a>]. The former will reduce  the cost of doing cybercrime, while the latter will increase the benefits, i.e., AI may increase  overall profits from cybercrime. Thus, more individuals may be incentivized to engage in  cybercrime. Furthermore, as AI reduces the technical expertise to engage in cybercrime,  existing gangs and mobs may expand the types of cybercrime they engage in.</p><p>AI may even impact the evolution of cybercriminal markets. As noted in Section 3, longer  supply chains or increasing number of agents in a cybercriminal product supply chain may  reduce reliability. The current technological landscape has created the need for multiple  agents, as investments in cyber defense have made it harder for cyberattacks to succeed.  Cybercriminals must thus plan sophisticated campaigns, each stage of which requires a  specialized cybercriminal skill set. However, LLMs may reduce the amount of expertise  required going forward. Just as the advent of computers reduced the demand for typists,  LLMs will allow cybercriminal organizations to bring certain parts of the operation in-house.  For example, organized cybercrime – much like legitimate companies – may use LLMs to  provide customer support. Thus, AI may help drive vertical integration in cybercriminal  markets.</p><p> With more cybercriminal organizations engaging in an ever-increasing number of  cybercriminal activities, with greater revenue enabled by greater system reliability and other  efficiencies enabled by vertical integration, we may witness an increase in competition  between these groups to grow their individual market shares. As Varian notes [<a href="#reference-16" rel="nofollow">16</a>], under this  dynamic system reliability depends on the agent with the highest benefit cost ratio while  other agents freeride. One way this outcome can materialize may be in the form of a small  set of cybercriminal organizations in the form of mobs. These mobs would provide a  comprehensive set of LLM-enabled cybercrime products, both capabilities and  infrastructure. The remaining vast majority of cybercriminal organizations stay at the level of  gangs who are just customers for the mob.</p><p>As these mobs and gangs use their AI and LLM enabled capabilities to conduct cyberattacks,  defenders will look to leverage the same technologies to scale defense. As noted in Section  4, the classical model of attack versus defense favors the attacker; the defender must  spread their resources to defend everywhere – the attacker need only find one undefended  resource. AI may help scale both defender and attacker capabilities. However, as the  attacker was already in an advantageous position any marginal gains for attack should be  less than the marginal gains for the defender.</p><p>The reverse may be true for a Zero Trust based attack versus defense model. Here the  defender has the advantage, as the attacker needs to get lucky multiple times, and the  defender needs to be lucky only once. In this case too AI may further both attacker as well  as defender capabilities. However, the marginal gains for the more favored party, i.e.,  attacker, should be greater than marginal gains for the less favored party, i.e., defender.  Overall, we hypothesize that the introduction of AI to attack and defense would reduce the  asymmetry between the two regardless of the underlying model. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">6. Conclusion and Future Work</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>When it comes to cybersecurity, is AI good or bad? This is the question that everyone,  regulators, industry professionals, academics, and civil society hopes to answer. This is the  puzzle that the White House Executive Order on AI aims to solve when it asks the Department  of Homeland Security to conduct a cross-sector risk assessment on AI for critical  infrastructure [<a href="#reference-27" rel="nofollow">27</a>]. This is the worry that underlies viral coverage of FraudGPT and WormGPT.  This is the conundrum that keeps cyber executives open to receiving calls from vendors  promising the newest AI cure-all.</p><p>In this position paper we examine the impact of AI on cybercrime on three dimensions: (1)  cybercrime organization, (2) reliability of cybercrime markets, and 3) asymmetry between  attackers and defenders. Our initial examination suggests that AI may reduce the barrier to  engage in cybercrime; thus, we have more cybercriminals engaging in more kinds of  cybercrime. Furthermore, AI may increase concentration in cybercrime markets through  both vertical and horizontal integration. Finally, AI may reduce the asymmetry between  attackers and defenders due to the broad range of tools available to both groups.</p><p>In future, we intend to build on this initial observation through experimentation.  Furthermore, while there is an increasing interest in AI tools available to attackers, the utility  of such tools used by defenders is not measured as much. We would like to explore the  impact of AI on organization in defense and associated markets. Additionally, there is limited  modeling done on establishing how attackers are at an advantage in cybercrime  ecosystems. We also hope to increase the maturity of our analyses by including formal  mathematical models. Finally, we intend to include implications for technologists and policy  makers as AI changes the landscape of threats. </p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Asimov, I., 2010. Foundation, Foundation and Empire, Second Foundation: Introduction  by Michael Dirda. Everyman's Library.</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Quak, N., 2023. How Emerging Technologies Threaten Our Cybersecurity. Cyber Threat  Alliance, White Paper.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] Lin, Z., Cui, J., Liao, X. and Wang, X., 2024. Malla: Demystifying Real-world Large Language  Model Integrated Malicious Services. arXiv preprint arXiv:2401.03315.</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Sarker, I.H., Furhad, M.H. and Nowrozy, R., 2021. AI-Driven Cybersecurity: An Overview,  Security Intelligence Modeling and Research Directions. SN Computer Science, 2(3), p.173.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Taddeo, M., McCutcheon, T. and Floridi, L., 2019. Trusting Artificial Intelligence in Cybersecurity Is a Double-Edged Sword. Nature Machine Intelligence, 1(12), pp.557-560.</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Gupta, M., Akiri, C., Aryal, K., Parker, E. and Praharaj, L., 2023. From ChatGPT to ThreatGPT: Impact of Generative AI In Cybersecurity and Privacy. IEEE Access.</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Garg, V. and Camp, L.J., 2015. Why Cybercrime? ACM SIGCAS Computers and  Society, 45(2), pp.20-28.</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Garg, V., Husted, N. and Camp, J. 2011. The Smuggling Theory Approach to Organized  Digital Crime. In 2011 eCrime Researchers Summit (pp. 1-7). IEEE.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] 2024. Measuring and Incentivizing the Adoption of Cybersecurity Best Practices. National  Security Telecommunications Advisory Committee (NSTAC).&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10] Coase, R.H., 1937. The Nature of the Firm. Economica, 4(16), pp.386-405.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-11"></a><p>[11] Garg, V., Afroz, S., Overdorf, R. and Greenstadt, R., 2015. Computer-Supported  Cooperative Crime. In Financial Cryptography and Data Security: 19th International  Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers  19 (pp. 32-43). Springer Berlin Heidelberg.</p> </div><div class="field-item even"><a class="anchor" name="reference-12"></a><p>[12] Brenner, S.W. 2002. Organized Cybercrime-How Cyberspace May Affect the Structure of Criminal Relationships. North Carolina Journal of Law &amp; Technology 4, 1 (2002)</p> </div><div class="field-item odd"><a class="anchor" name="reference-13"></a><p>[13] Collier, B., Clayton, R., Hutchings, A. and Thomas, D., 2021. Cybercrime Is (Often)  Boring: Infrastructure and Alienation in a Deviant Subculture. The British Journal of  Criminology, 61(5), pp.1407-1423.</p> </div><div class="field-item even"><a class="anchor" name="reference-14"></a><p>[14] Van Wegberg, R., Miedema, F., Akyazi, U., Noroozian, A., Klievink, B. and van Eeten, M.  2020. Go See a Specialist? Predicting Cybercrime Sales on Online Anonymous Markets from Vendor and Product Characteristics. In Proceedings of the Web Conference 2020 (pp. 816- 826).</p> </div><div class="field-item odd"><a class="anchor" name="reference-15"></a><p>[15] Akyazi, U., van Eeten, M.J.G. and Ganan, C.H., 2021. Measuring Cybercrime as a Service  (CaaS) Offerings in A Cybercrime Forum. In Workshop on the Economics of Information  Security.</p> </div><div class="field-item even"><a class="anchor" name="reference-16"></a><p>[16] Varian, H., 2004. System Reliability and Free Riding. In Economics of information  security (pp. 1-15). Boston, MA: Springer US.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-17"></a><p>[17] Anderson, R., Clayton, R., Böhme, R. and Collier, B. 2021. Silicon Den: Cybercrime is  Entrepreneurship. In Workshop on the Economics of Information Security.</p> </div><div class="field-item even"><a class="anchor" name="reference-18"></a><p>[18] Langlois, R.N. and Garzarelli, G., 2014. Of Hackers and Hairdressers: Modularity and The  Organizational Economics of Open-Source Collaboration. In Online Communities and Open  Innovation (pp. 11-29). Routledge.</p> </div><div class="field-item odd"><a class="anchor" name="reference-19"></a><p>[19] Anderson, R., 2001, December. Why Information Security is Hard - An Economic  Perspective. In Seventeenth Annual Computer Security Applications Conference (pp. 358- 365). IEEE.</p> </div><div class="field-item even"><a class="anchor" name="reference-20"></a><p>[20] 2011: The Cyber Kill Chain. Lockheed Martin. <a href="https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html" rel="nofollow">https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain...</a>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-21"></a><p>[21] Dargahi, T., Dehghantanha, A., Bahrami, P.N., Conti, M., Bianchi, G. and Benedetto, L.,  2019. A Cyber-Kill-Chain based Taxonomy of Crypto-Ransomware Features. Journal of  Computer Virology and Hacking Techniques, 15, pp.277-305.</p> </div><div class="field-item even"><a class="anchor" name="reference-22"></a><p>[22] Slayton, R., 2016. What is the Cyber Offense-Defense Balance? Conceptions, Causes,  and Assessment. International Security, 41(3), pp.72-109.</p> </div><div class="field-item odd"><a class="anchor" name="reference-23"></a><p>[23] Chui, M., Hazan, E., Roberts, R., Singla, A., Smaje, K., Sukharevsky, A., Yee, L. and  Zemmel, R., 2023. The Economic Potential of Generative AI: The Next Productivity Frontier.  McKinsey.</p> </div><div class="field-item even"><a class="anchor" name="reference-24"></a><p>[24] Torre, Richard De La. 2023. How AI is Shaping the Future of Cybercrime. Dark Reading. <a href="https://www.darkreading.com/vulnerabilities-threats/how-ai-shaping-future-cybercrime" rel="nofollow">https://www.darkreading.com/vulnerabilities-threats/how-ai-shaping-futur...</a>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-25"></a><p>[25] Kaloudi, N. and Li, J., 2020. The AI-based Cyber Threat Landscape: A Survey. ACM  Computing Surveys (CSUR), 53(1), pp.1-34.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-26"></a><p>[26] Violino, B. 2023. AI Tools Such as ChatGPT Are Generating a Mammoth Increase in Malicious Phishing Emails. CNBC. <a href="https://www.cnbc.com/2023/11/28/ai-like-chatgpt-is" rel="nofollow">https://www.cnbc.com/2023/11/28/ai-like-chatgpt-is</a>creating-huge-increase-in-malicious-phishing-email.html.&nbsp;&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-27"></a><p>[27] 2023: Executive Order on The Safe, Secure, And Trustworthy Development and Use of Artificial Intelligence. The White House. The United States Government.  <a href="https://www.whitehouse.gov/briefing-room/presidential-actions/2023/10/30/executive" rel="nofollow">https://www.whitehouse.gov/briefing-room/presidential-actions/2023/10/30...</a>order-on-the-safe-secure-and-trustworthy-development-and-use-of-artificial-intelligence/.</p> </div><div class="field-item even"><a class="anchor" name="reference-28"></a><p>[28] Stafford, V.A., 2020. Zero Trust Architecture. NIST Special Publication, 800, p.207.</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">AI/ML</li>
                                                    <li class="category">Culture</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/measuring-great-firewall%E2%80%99s-multi-layered-web-filtering-apparatus"
                    >Measuring the Great Firewall&#039;s Multi-layered Web Filtering Apparatus</a>
                </h2>

                                    <time datetime="2024-08-15 00:00:00">
                        2024-08-15 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Nguyen Phong Hoang</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We present GFWeb, a novel system designed for large-scale, longitudinal measurement of the Great Firewall (GFW) of China'</span>s Web censorship capabilities. GFWeb enables comprehensive, large-scale measurements of the GFW's HTTP and HTTPS blocking mechanisms over an extended period. Over 20 months, GFWeb tested 1.02 billion domains, detecting 943K and 55K pay-level domains (PLDs) censored by the GFW's HTTP and HTTPS filters, respectively. This represents the most extensive dataset of censored domains discovered to date, many of which had not been identified by previous studies. The findings from GFWeb highlight the need for comprehensive measurement systems that can capture the full spectrum of the GFW's censorship mechanisms. Systems relying on a single protocol or bidirectional interference may miss significant aspects of the GFW's operations. Future measurement efforts should consider testing from both sides of the GFW and across multiple protocols to obtain a complete picture of Web censorship.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Introduction</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>In the ever-evolving landscape of global Internet governance, the Great Firewall (GFW) of China stands as one of the most sophisticated and opaque systems of Web censorship [<a href="#reference-2" rel="nofollow">2</a>]. It employs an array of filtering mechanisms that continuously adapt to new evasion strategies and emerging technologies. This article expands on our research paper presented at USENIX Security '24 [<a href="#reference-1" rel="nofollow">1</a>], which introduces GFWeb—a novel system designed for large-scale, longitudinal measurement of the GFW's Web censorship capabilities. Analyzing measurement data collected by GFWeb over 20 months, from February 2022 to September 2023, our work provides a deeper understanding of the GFW's mechanisms, evolution, and the broader implications for Internet freedom.</p><p> </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">The Great Firewall - An Overview</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>The GFW is a multifaceted censorship apparatus deployed by the Chinese government to control the flow of information on the Internet. It employs various techniques, including DNS poisoning [<a href="#reference-3" rel="nofollow">3</a>, <a href="#reference-4" rel="nofollow">4</a>, <a href="#reference-5" rel="nofollow">5</a>, <a href="#reference-6" rel="nofollow">6</a>, <a href="#reference-7" rel="nofollow">7</a>, <a href="#reference-8" rel="nofollow">8</a>, <a href="#reference-9" rel="nofollow">9</a>], keyword filtering [<a href="#reference-10" rel="nofollow">10</a>, <a href="#reference-11" rel="nofollow">11</a>, <a href="#reference-12" rel="nofollow">12</a>, <a href="#reference-13" rel="nofollow">13</a>], and TCP/IP blocking [<a href="#reference-10" rel="nofollow">10</a>, <a href="#reference-14" rel="nofollow">14</a>, <a href="#reference-15" rel="nofollow">15</a>, <a href="#reference-16" rel="nofollow">16</a>, <a href="#reference-17" rel="nofollow">17</a>], to enforce its policies. Understanding the GFW's operational details is crucial for developing effective censorship circumvention tools and fostering a free and open Internet. China's Internet censorship framework, conceptualized in the late 1990s as part of the Golden Shield project [<a href="#reference-18" rel="nofollow">18</a>, <a href="#reference-19" rel="nofollow">19</a>], serves as the government's tool for controlling the flow of online information. Often dubbed "the Great Firewall", this system comprises middleboxes distributed across border autonomous systems (ASes) and managed in a centralized manner [<a href="#reference-11" rel="nofollow">11</a>, <a href="#reference-13" rel="nofollow">13</a>, <a href="#reference-20" rel="nofollow">20</a>].</p><p><span>The GFW's</span> on-path devices intercept and inspect network traffic, selectively blocking connections based on predefined blocklists. Its Web censorship mechanisms span multiple layers, covering all three fundamental protocols of the Web: DNS, HTTP, and HTTPS. DNS poisoning is done by exploiting the race condition of UDP-based DNS resolution, injecting false responses when it detects DNS queries for censored domains. HTTP filtering inspects unencrypted Web traffic and blocks connections based on specific keywords or host names. HTTPS filtering examines the Server Name Indication (SNI) field during the TLS handshake to block encrypted connections. The filtering middleboxes begin tracking a TCP connection's state when it sees the first SYN packet from the client and, upon detecting a censored domain in the HTTP Host header or the Server Name Indication (SNI) extension in the TLS Client Hello, tears down the connection by injecting RST/ACK packets to both the client and the server. Figure 1 illustrates the GFW's DNS, HTTP, and HTTPS filtering mechanisms.</p><p><span><br /></span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig1_gfw.png?itok=zTmV9Ltv" width="1440" height="371" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: The DNS, HTTP, and HTTPS filtering mechanisms of the Great Firewall. SYN, ACK, PSH, and RST denote TCP synchronization, acknowledgement, push, and reset flags. A packet with the RST flag set is meant to terminate a TCP connection.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Challenges in Measuring the GFW&#039;s Censorship</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Measuring the GFW's</span> censorship presents significant challenges due to its sophisticated and evolving mechanisms. Prior measurement efforts have been limited by scope, time, and/or methodology. Most studies focused on specific aspects over short periods, leading to gaps in understanding the GFW's dynamic censorship landscape. The GFW's stateful blocking, residual censorship, and asymmetric interference further complicate large-scale measurement efforts. Furthermore, relying on volunteers or public servers for data collection introduces potential risks, highlighting the need for innovative measurement approaches like GFWeb to continuously monitor the GFW's Web censorship at scale.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">GFWeb Design</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>GFWeb is designed to uncover the domain blocklists used by the GFW for Web censorship. It leverages the GFW's</span> bidirectional and loss-tolerant blocking behavior to test hundreds of millions of domains monthly.</p><p>The design of GFWeb is depicted in Figure 2, illustrating its probing approach using machines located at both sides of the GFW. The system initiates with the collection of domain test lists from various sources, including domain zone files, the Tranco list, the Citizen Lab test lists, and the Common Crawl dataset. These domains are used by probing machines located outside China to send SYN and PSH/ACK packet pairs towards controlled machines inside China. The loss-tolerant design of the GFW allows GFWeb to trigger censorship responses without completing the three-way TCP handshake, enabling efficient and scalable probing.</p><p><span>When the GFW detects a censored domain in the HTTP or HTTPS request, it responds by injecting three RST/ACK packets to both the client (probing machines) and the server (controlled machines inside China). The responses help identify which domains are censored by observing these injected packets.</span></p><p><span>The probing process is continuous and iterative, with steps to analyze the fully qualified domain names (FQDNs) detected as censored and subsequently creating regular expressions to understand the blocking patterns. The system then performs additional probing to confirm the censorship of pay-level domains (PLDs) by sending more SYN and PSH/ACK packet pairs and observing for RST/ACK responses. The process is run from both sides of the GFW, allowing GFWeb to scale up its measurement and uncover the comprehensive set of domains censored by the GFW.</span></p><p><span><em>Note</em></span><em>:</em> A pay-level domain (PLD) is the highest level of a domain name that can be directly registered and controlled by an individual or organization. It's typically the part of the domain name immediately below the public suffix. For example, in <em><a href="http://www.example.com" rel="nofollow">www.example.com</a></em>, “<em>example</em>” is the PLD, while in <em><a href="http://www.bbc.co.uk" rel="nofollow">www.bbc.co.uk</a></em>, “<em>bbc</em>” is the PLD. PLDs are used to identify the primary domain of a website and are more precise than second-level domains (SLDs) as they accommodate various global domain structures.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig2_gfweb.png?itok=FOplC8md" width="686" height="568" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: The design of GFWeb&#039;s probing approach, which does not rely on the completion of the three-way handshake for triggering the GFW&#039;s HTTP(S) filters.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Key Findings</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><em><strong>Evolution of the GFW</strong></em>: Our study reveals that the GFW has been upgraded to mitigate several issues previously identified by researchers, such as overblocking. More specifically, while developing GFWatch, our previous system for DNS censorship measurement presented at USENIX Security '21, we observed that the GFW was using overly broad regular expressions to block domains, such as <em><strong>*</strong>torproject.org</em>, which resulted in collateral damage by also inadvertently blocking unrelated domains that included the string “<em>torproject.org</em>” within their names, such as <em>mentorproject.org</em> and <em>ventilatorproject.org</em>, which have no association with the Tor Project. This broad matching caused more than 41K innocuous websites to be inaccessible in China, highlighting a significant flaw in the GFW's</span> censorship mechanism. With our new system, GFWeb, we observed that the GFW has since addressed this issue indicating an ongoing evolution in its filtering policies.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><em><strong>Cross-Protocol Blocking</strong></em>: Our study also reveals significant insights into the cross-protocol blocking behavior of the GFW, showing that the blocklists for DNS, HTTP, and HTTPS are not identical but rather complementary. As shown in Figure 3, the GFW's</span> HTTP filter has the largest blocklist, followed by DNS and HTTPS filters. Each filter operates on different blocklists that complement each other, forming a comprehensive censorship framework. We find an average of 528K and 24K base censored domains per month for HTTP and HTTPS filters, respectively. GFWatch discovers an average of 247K base censored domains per month. The differing sizes of these can be attributed to the distinct technical characteristics, implementation costs, and strategic purposes of each protocol's filtering mechanism.</p><p><span>Specifically, HTTP traffic is unencrypted, allowing for more granular content-based filtering using Deep Packet Inspection (DPI). This fine-grained control means the GFW can inspect the entire content of HTTP requests and responses, leading to a larger and more specific blocklist. HTTP filtering can block individual pages based on specific keywords, resulting in a higher number of blocked domains.</span></p><p><span>DNS filtering operates at the forefront of the GFW, manipulating DNS queries to block access to certain domains even before any HTTP or HTTPS traffic is initiated. It is the least expensive in terms of resources because it involves simple on-path inspection and forgery of DNS responses. This mechanism blocks fewer domains compared to HTTP but still plays a critical role in the overall censorship strategy.</span></p><p><span>HTTPS traffic is encrypted, limiting the GFW's</span> ability to inspect the content of Web communications. The GFW relies on the Server Name Indication (SNI) field in the TLS handshake to identify the domain of the visited website. This makes HTTPS filtering more complex and operationally expensive, as DPI techniques are less effective when it comes to parsing TLS packets with many more header fields compared to HTTP packets. Consequently, the HTTPS blocklist is smaller, focusing on high-priority domains that warrant the additional resource overhead.</p><p><span>Our findings of different blocklists across protocols can lead to straightforward circumvention strategies. For example, if a domain is blocked only by the DNS filter, importing the domain's</span> IP address into the hosts file can bypass the DNS block. Similarly, if a domain is blocked by the HTTP filter, accessing the domain via HTTPS can circumvent the block. For instance, the domain <em>geti2p.net</em> is blocked by the DNS and HTTP filters but not by the HTTPS filter. By (1) importing the domain's correct IP address into the hosts file to bypass the DNS filter and (2) accessing the domain via HTTPS, one can still reach the website. This underscores the importance of understanding the GFW's multi-layered filtering architecture for effective circumvention strategies.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig3_crossprotocol_blocking.png?itok=0kknhP5X" width="1069" height="708" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3: Number of HTTP(S) base censored domains (in log scale) detected over time by GFWeb compared to GFWatch. A base censored domain is the shortest domain name that matches the GFW&#039;s blocking rules. For example, if both &quot;en.wikipedia.org&quot; and &quot;zh.wikipedia.org&quot; are blocked, the base censored domain would be &quot;wikipedia.org&quot; because it is the common, shortest domain that is blocked.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><em><strong>Asymmetric Interference and Prolonged Residual Censorship:</strong></em> Our study also uncovered two new behaviors of the GFW's</span> Web censorship: asymmetric interference and prolonged residual censorship. Asymmetric interference refers to the GFW's blocking behavior that is not bidirectional and symmetric. We identified approximately 1,000 domains that trigger HTTPS filtering only when probed from inside China, but not from outside. This finding challenges the conventional belief that the GFW's filtering mechanisms are bidirectional and symmetric, posing a risk of false negatives in external measurement systems that do not account for this asymmetry. For instance, domains related to circumvention tools or sensitive content, such as <em>torproject.org</em>, exhibit this selective blocking, thereby eluding detection when probed externally.</p><p><span>Additionally, the GFW demonstrates prolonged residual censorship, wherein once a domain triggers asymmetric blocking, subsequent connections with the same three-tuple (source IP, destination IP, and destination port) are consistently dropped for an extended period—up to 350 seconds—rather than merely injecting reset packets. This behavior creates extended periods of unreachability for affected domains, complicating continuous probing strategies used by automated evasion tools like Geneva. The prolonged traffic dropping can mislead these tools into concluding that an evasion strategy is effective when the censorship still actually persists. These findings emphasize the need for comprehensive and nuanced approaches to measuring and circumventing the GFW's</span> evolving censorship tactics.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Localized Network Interference</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>While the ultimate goal of our study is to investigate the GFW's Web censorship, we encountered some interesting cases of localized network interference by major cloud providers and ISPs in China.</span></p><p><span><em><strong>Hosting Providers’ Redirection</strong></em>: Our measurement machines in China are located in the data centers of two major cloud providers: Aliyun and QCloud. While analyzing network traffic collected by GFWeb, we found that both providers have deployed DPI middleboxes to interfere with HTTP connections and attempt to redirect users to warning pages when certain domains are requested despite the location of the request client (i.e., inside or outside China). Specifically, Aliyun injects a redirection to batit.aliyun.com/alww.html and QCloud injects a redirection to dnspod.qcloud.com/static/webblock.html as shown in Figure 4. These pages warn that the domain being requested is not registered with the Chinese government. For a domain to be hosted from within China, it needs to be registered with the Chinese Ministry of Industry and Information Technology (MIIT) and obtain an Internet Content Provider (ICP) license.</span></p><p><span>Both providers’ DPI middleboxes are deployed as on-path devices and intercept packets in a stateless manner. In other words, these redirection injections can be triggered without initiating a complete TCP handshake (i.e., packets ❶-❸ in Figure 1(b)). An HTTP PSH/ACK packet (❹) with the payload of a trigger domain is sufficient to prompt the middleboxes to inject a redirection towards the side of the connection that sends the PSH/ACK packet. Bock et al. recently found that this behavior could be weaponized for TCP-based amplification attacks since the injected warning pages are much larger compared to the original HTTP request.</span></p><p><span>Over the course of our study, Aliyun and QCloud middleboxes have interfered with 36.5M and 39.1M FQDNs, respectively. Clustering these domains by their PLDs, we find a total of 7.8M and 6.8M PLDs whose HTTP requests were redirected to Aliyun and QCloud ICP warning pages. It's worth noting that this interference is not caused by the GFW and should not be considered as nation-state censorship. Instead, they are caused by the hosting providers enforcing the ICP license requirements since a benign domain like example.com also triggers the redirection of QCloud's middleboxes.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig4_cloud_redirections.png?itok=PMqfdc9Q" width="1423" height="339" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4: Redirection injected by Aliyun and QCloud to warn about ICP license requirements.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong><em>China's “Anti-Fraud</em><em>” Redirection</em><em>: </em></strong>In late 2021, there were some anecdotal reports of new network interference events across major state-owned ISPs in China, including the three largest operators: China Telecom, China Unicom, and China Mobile [<a href="#reference-21" rel="nofollow">21</a>]. Many users reported that their browsing sessions were redirected to a warning page showing an “Anti-Fraud” message. As indicated in Figure 5, the warning page advises users that the site they are trying to access is suspected of fraud and asks them to install an app developed by the State Anti-Fraud Center from the Android or the Apple app stores.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/fig5_china_anti_fraud_0.png?itok=mehogHyW" width="1234" height="848" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 5: China&#039;s “Anti-Fraud” redirection.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>GFWeb has also observed this network interference. Applying the limited time-to-live (TTL) probing approach, we confirm that it is indeed caused by the ISPs. While we did not have direct access to vantage points within these ISPs, one of our measurement machines in China is in a data center whose upstream provider is China Telecom, allowing us to observe the redirection injected by this ISP's middleboxes. Similarly to the GFW, they can inspect and inject packets bidirectionally. They are also deployed as on-path devices and have a loss-tolerant design (i.e., can be triggered without a complete TCP handshake).</span></p><p>GFWeb observed a total of 2.3M redirection attempts caused by China Telecom's middleboxes. In addition to two URLs reported on the Tor Project's GitLab (i.e., URLs 1 and 2 in Table 1) [<a href="#reference-21" rel="nofollow">21</a>], we have also observed six other URLs that share the same pattern but were injected with lower frequency. Our data also indicates that URLs ending with parameter1 and parameter2 were not deployed until February 2023.</p><p> </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table>   <tr>     <th>Index</th>     <th># Triggered</th>     <th>Redirection URLs</th>   </tr>   <tr>     <td>1</td>     <td>1.7M (75.2%)</td>     <td>182.43.124.6</td>   </tr>   <tr>     <td>2</td>     <td>182K (7.9%)</td>     <td>182.43.124.6/fzyujing?parameter</td>   </tr>   <tr>     <td>3</td>     <td>123K (5.3%)</td>     <td>0.0.0.0/fzyujing?parameter1</td>   </tr>   <tr>     <td>4</td>     <td>86K (3.7%)</td>     <td>0.0.0.0/fzyujing?parameter</td>   </tr>   <tr>     <td>5</td>     <td>74K (3.2%)</td>     <td>182.43.124.6/fzyujing?parameter1</td>   </tr>   <tr>     <td>6</td>     <td>67K (2.9%)</td>     <td>182.43.124.6/fzyujing?parameter2</td>   </tr>   <tr>     <td>7</td>     <td>26K (1.1%)</td>     <td>0.0.0.0</td>   </tr>   <tr>     <td>8</td>     <td>6K (0.3%)</td>     <td>0.0.0.0124.6/fzyujing?parameter</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1: Redirection URLs injected by China Telecom&#039;s middleboxes.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Table 1 also lists some injected URLs that we deem as “buggy” because they contain either an invalid or non-routable IP address (i.e., 0.0.0.*). We believe that these URLs are a result of misconfiguration because the injection of these URLs will not lead to any redirection, and thus they are not effective for the ISP's intended purpose.</span></p><p><span>GFWeb observed 478K unique FQDNs that trigger these injections. Still, we could not find any patterns that could explain why these domains were targeted, since they only triggered the redirection for a short period of time. Looking up the IP addresses of these domains, we find that less than half of them are associated with an IP address, while the remaining are either not associated with any IP address or not existing (i.e., NXDOMAIN). Instead of targeting specific domains that are truly associated with fraud, this observation suggests that the redirection could have been randomly triggered in an opportunistic manner to redirect users to the warning page, persuading them to install the government's “anti-fraud” app. This is evident by the fact that one of the trigger domains was baidu.com, which is obviously not fraudulent.</span></p><p><span>The original anecdote also reported that OONI and Censored Planet observed this network interference happened via DNS injection as well. However, we could not reproduce redirection cases caused by DNS injection of 182.43.124.6 anymore. This strengthens our hypothesis that the redirection is performed in an opportunistic manner and does not target any particular domains for a long period of time. At the time of writing, we are still observing this network interference from China Telecom and will continue monitoring for any change in the future.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Suggestions for Future Efforts</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><em><strong>Censorship Measurement</strong><strong>:</strong></em> The discovery of asymmetric interference underscores the importance of conducting measurements from both sides of the GFW since filtering policies can be different depending on the probing direction and the domain being tested.</span></p><p><span>Furthermore, measurement systems that function based on continuous probing against remote servers using the same destination ports will need to be aware of the two different types of residual censorship (i.e., “keeps injecting” and “keeps dropping”) and take appropriate actions to avoid incorrect inferences. More specifically, the residual censorship that “keeps injecting” packets may cause false positives as subsequent benign probes would still trigger the GFW to emit forged packets, whereas the residual censorship that “keeps dropping” subsequent traffic may cause false negatives due to the absence of forged packets that are usually anticipated. The co-existence of these two types of residual censorship in HTTPS filtering also suggests that it is non-trivial to determine whether a domain is blocked or not based solely on the presence or absence of forged packets if residual censorship is not taken into account. To that end, it is important to design measurement approaches that can sidestep the residual censorship to avoid both false positives and false negatives.</span></p><p><span><em><strong>Censorship Circumvention: </strong></em>The GFW's Web censorship is composed of multiple layers of filtering based on different blocklists and protocols. While various efforts have attempted to circumvent the GFW's Web censorship at different layers, an effective circumvention solution will need to tackle the GFW's multi-layered filtering architecture. Otherwise, circumvention solutions that only target a single filtering layer may not be sufficient to achieve the desired result.</span></p><p><span>Similarly to the suggestion for censorship measurement, probing-based evasion techniques like Geneva or DeResistor also need to be aware of the two different types of residual censorship to avoid being tricked into thinking that the censorship has been successfully evaded when it is actually not, especially when the residual censorship is of the “keeps dropping” type.</span></p><p><span><strong><em>Using Measurement Data:</em></strong> Internet censorship measurement is a challenging task. Each measurement system is designed with different resources and constraints. Consumers of censorship measurement data (e.g., journalists, researchers, and policymakers) should be aware of the strengths and drawbacks of each system and consider multiple measurement results from different protocols and data sources to obtain a more complete picture of the censorship landscape. When it comes to determining the censorship status of a domain, it is important to gather results from multiple systems and protocols to obtain a more conclusive result.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusion</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>DNS, HTTP, and HTTPS filtering middleboxes together form the primary pillars of the GFW's Web censorship. In this work, we present GFWeb, a longitudinal measurement system designed to discover domain blocklists used by the GFW for censoring Web access. Over the course of 20 months, GFWeb has tested over a billion fully qualified domains, and detected 943K and 55K pay-level domains censored by the GFW's HTTP and HTTPS filtering middleboxes, respectively. Our study not only complements prior efforts by providing a more comprehensive view into the GFW's Web censorship over time, but also reveals several new findings, including the GFW's asymmetric blocking behavior and patches of overblocking. </span></p><p><span>The implications of our investigation extend beyond academic circles, touching on the fabric of global Internet governance and the ongoing struggle for digital freedom. The adaptive nature of the GFW signals a future where Internet censorship will become more nuanced and technically complex, posing significant challenges for circumvention technologies and international policy efforts. </span></p><p><span>In light of these insights, our work underscores the need for a reinvigorated approach to understanding and combating Internet censorship. The dynamic between censorship and circumvention is not static; it evolves as part of a larger geopolitical and technological landscape, with implications for global Internet freedom, the free flow of information, and the resistance against digital authoritarianism. </span></p><p><span>As we keep operating GFWeb, we hope that our data will not only provide fresh insights into technical observations but also promptly update the public regarding changes in the GFW's blocking policies and support other initiatives, especially those focusing on censorship detection and circumvention.</span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Nguyen Phong Hoang, Jakub Dalek, Masashi Crete-Nishihata, Nicolas Christin, Vinod Yegneswaran, Michalis Polychronakis, and Nick Feamster. GFWeb: Measuring the Great Firewall's Web Censorship at Scale. In <em>Proceedings of the 33th USENIX Security Symposium (USENIX Security ’24), 2024.</em></p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Freedom House. Freedom in the World 2023 - China, 2023. <em><a href="https://freedomhouse.org/country/china/freedom-world/2023" rel="nofollow">https://freedomhouse.org/country/china/freedom-world/2023</a></em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] Anonymous, Arian Akhavan Niaki, Nguyen Phong Hoang, Phillipa Gill, and Amir Houmansadr. Triplet censors: Demystifying Great Firewall's DNS censorship behavior. In <em>Proceedings of the USENIX Workshop on Free and Open Communications on the Internet (FOCI '2</em><em>0), 2020.</em></p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Anonymous Author(s). Towards a comprehensive picture of the Great Firewall's DNS censorship. In<em> Proceedings of the USENIX Workshop on Free and Open Communications on the Internet (FOCI), 2014</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Haixin Duan, Nicholas Weaver, Zongxu Zhao, Meng Hu, Jinjin Liang, Jian Jiang, Kang Li, and Vern Paxson. Hold-On: Protecting against on-path DNS poisoning. In <em>Proceedings of the Conference on Securing and Trusting Internet Names (SATIN), 2012</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Oliver Farnan, Alexander Darer, and Joss Wright. Poisoning the well – exploring the Great Firewall's poisoned DNS responses. In <em>Proceedings of the ACM Workshop on Privacy in the Electronic Society (WPES), 2016</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Nguyen Phong Hoang, Arian Akhavan Niaki, Jakub Dalek, Jeffrey Knockel, Pellaeon Lin, Bill Marczak, Masashi Crete-Nishihata, Phillipa Gill, and Michalis Polychronakis. How great is the Great Firewall? Measuring China's DNS censorship. In <em>Proceedings of the 30th USENIX Security Symposium, 2021</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Graham Lowe, Patrick Winters, and Michael L. Marcus. The Great DNS Wall of China. <em>Technical report, New York University, 2007</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] Sparks, Neo, Tank, Smith, and Dozer. The collateral damage of Internet censorship by DNS injection. <em>SIGCOMM Computer Communication Review, 42(3):21–27, 2012</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10] Richard Clayton, Steven J. Murdoch, and Robert N. M. Watson. Ignoring the Great Firewall of China. In <em>Proceedings of the 6th Workshop on Privacy Enhancing Technologies (PET), pages 20–35. Springer, 2006</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-11"></a><p>[11] Geremie R. Barme And Sang Ye. The Great Firewall of China, 1997- 06-01. <em><a href="https://www.wired.com/1997/06/china-3/" rel="nofollow">https://www.wired.com/1997/06/china-3/</a></em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-12"></a><p>[12] Raymond Rambert, Zachary Weinberg, Diogo Barradas, and Nicolas Christin. Chinese wall or Swiss cheese? keyword filtering in the Great Firewall of China. In <em>Proceedings of the ACM Web Conference (WWW), 2021</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-13"></a><p>[13] Jonathan Zittrain and Benjamin Edelman. Internet filtering in China. <em>IEEE Internet Computing, 7(2):70–77, 2003</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-14"></a><p>[14]&nbsp;Nguyen Phong Hoang, Sadie Doreen, and Michalis Polychronakis. Measuring I2P censorship at a global scale. In <em>Proceedings of the USENIX Workshop on Free and Open Communications on the Internet (FOCI), 2019</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-15"></a><p>[15] Jong Chun Park and Jedidiah R. Crandall. Empirical study of a nationalscale distributed intrusion detection system: Backbone-level filtering of HTML responses in China. In <em>Proceedings of the 30th International Conference on Distributed Computing Systems (ICDCS), pages 315– 326, 2010</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-16"></a><p>[16] Zhongjie Wang, Yue Cao, Zhiyun Qian, Chengyu Song, and Srikanth V. Krishnamurthy. Your state is not mine: A closer look at evading stateful Internet censorship. In <em>Proceedings of the Internet Measurement Conference (IMC), 2017</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-17"></a><p>[17] Mingshi Wu, Jackson Sippe, Danesh Sivakumar, Jack Burg, Peter Anderson, Xiaokang Wang, Kevin Bock, Amir Houmansadr, Dave Levin, and Eric Wustrow. How the Great Firewall of China detects and blocks fully encrypted traffic. In <em>Proceedings of the USENIX Security Symposium, 2023</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-18"></a><p>[18] Lokman Tsui. An inadequate metaphor: the Great Firewall and Chinese internet censorship. <em>Global Dialogue, 9(1/2):60, 2007</em>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-19"></a><p>[19] Young Xu. Deconstructing the Great Firewall of China. <em>Technical report, Thousand Eyes, 2016</em>.</p> </div><div class="field-item even"><a class="anchor" name="reference-20"></a><p>[20] Ronald Deibert. China's Cyberspace Control Strategy: An Overview and Consideration of Issues for Canadian Policy, 2010.</p> </div><div class="field-item odd"><a class="anchor" name="reference-21"></a><p>[21] ] Tor Project's Anti-Censorship Team. China Anti-Fraud Webpage Redirection Censorship, 2022-01-12. <em><a href="https://gitlab.torproject.org/tpo/anti-censorship/censorship-analysis/-/issues/40026" rel="nofollow">https://gitlab.torproject.org/tpo/anti-censorship/censorship-analysis/-/...</a></em>.</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">Network</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/acto-push-button-end-end-testing-operation-correctness-kubernetes-operators"
                    >Acto: Push-Button End-to-End Testing for Operation Correctness of Kubernetes Operators</a>
                </h2>

                                    <time datetime="2024-08-02 00:00:00">
                        2024-08-02 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Jiawei Tyler Gu</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Acto is a push-button end-to-end testing technique for Kubernetes operators which are custom controllers for managing deployed systems atop Kubernetes. Acto uses a state-centric approach to test an operator together with its managed system. It checks if an operator satisfies three operation correctness properties: 1) always reconciling the managed system to the desired states, 2) always recovering the system from undesired or error states, and 3) always being resilient to misoperations. Acto has helped find more than 80 new bugs in popular Kubernetes operators and is maintained as an open-source project.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">1 Introduction </div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Cloud systems are growing in scale and demand beyond what human-based operation can reliably, continuously, and efficiently manage. Today, cloud systems deployed on platforms such as Kubernetes are increasingly being managed by mechanical “operators” [1, 3, 12, 22] that automate labor-intensive operations. Kubernetes operators implement declarative interfaces which define the managed system resources and their properties [2]. An operation declares the <em>desired</em> system state through the interface and the op- erator automatically reconciles the system from its current state to the declared state. This “cloud-native” operator pattern effectively simplifies operations and improves efficiency.</span></p><p><span>Today, there is a thriving ecosystem of high-quality, reusable operators on Kubernetes—almost all cloud- native systems have operators to manage them atop Kubernetes. These operators automate important management tasks like software upgrades, configuration updates, and autoscaling. Even for the same cloud system, multiple different operators are developed by commercial vendors and open-source communities, to support different operation practices and deployment environments.</span></p><p><span>The rapid development and deployment of operators make their quality assurance a pressing need—<em>operation correctness</em> is critical to system reliability [6]. A buggy operator can impair correctly implemented systems in production. Compared with human operator mistakes—major causes of system failures [9,13,20, 21, 27]—bugs in operators have more magnified impacts due to the nature of automation and widespread software reuse. In fact, buggy operators caused many recent production incidents [11, 15, 17–19].</span></p><p><span>Figure 1 depicts a safety bug that our tool detects in a Kubernetes operator for ZooKeeper [16]. When scaling down a ZooKeeper cluster, the operator only removes pods, but not the data volumes attached to the pods. If the operator later scales up the ZooKeeper cluster, the newly created pods will try to reuse the old volumes. Due to membership inconsistencies between the new pods and old volumes, the new ZooKeeper nodes fail to start. Moreover, all subsequent scaling operations hang inside the operator.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure1_0.jpg?itok=1Ec9iaEb" width="1440" height="547" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd"> Figure 1: A safety bug [7] in a ZooKeeper operator, detected by Acto. The bug manifests when the operator scales down and then scales up ZooKeeper. Newly created pods fall into crash loops; all subsequent scaling operations hang.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Compared with Kubernetes and the managed systems (e.g., ZooKeeper), operator code is often much less tested. For example, our study [14] shows that existing Kubernetes operators rely mostly on unit tests which cannot check operation correctness end to end, i.e., if an operator reconciles the managed system to </span><span>desired states. Some operators have a few end-to-end (e2e) tests but only cover small parts of the enormous system state space and the complex operations exposed by declarative interfaces.</span></p><p><span>We present Acto, the first automatic testing technique and a push-button tool for Kubernetes operators. Acto is fully automatic—it tests unmodified operators and requires no manual annotation, instrumenta- tion, or assertion. Acto uses a state-centric approach to test a given operator together with its managed system. Acto continuously instructs an operator to reconcile the system to different states and checks if the system successfully reaches those desired states during a test campaign. To do so, Acto models operations as state transitions and systematically realizes state-transition sequences to exercise supported operations in different scenarios. Acto checks three operation correctness properties: </span></p><ol><li><span>always reconciling the managed system to the desired states, </span></li><li><span>always recovering the system from undesired or error states, and </span></li><li><span>always being resilient to misoperations where the desired states are invalid, such as misconfigurations [23, 26].</span></li></ol><p><span>Acto has helped find more than 80 new bugs (at least 62 were confirmed and 41 have been fixed) with few false alarms (less than 0.19%). Acto also found six bugs in Kubernetes and in the Go runtime that affected multiple operators (all have been confirmed or fixed). The detected bugs lead to severe safety and liveness issues, affecting not only the operators, but also the reliability and security of the managed systems. We also find that existing operators have poor resilience to misoperations which would render the system into unrecoverable states. For a given Kubernetes operator, Acto’s testing finishes within eight hours (a nightly run) on a cluster of eight machines; the majority of operators only need one machine.</span></p><p><span>The Acto project is open sourced at <a href="https://github.com/xlab-uiuc/acto" target="_blank" title="https://github.com/xlab-uiuc/acto" rel="nofollow">https://github.com/xlab-uiuc/acto</a>.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">2 The Operator Pattern</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Kubernetes operators use a declarative, state-reconciliation design pattern [1, 3, 12, 22]. An operation declares a desired system state and the operator automatically reconciles the system to the declared state. This design pattern simplifies system management operations by removing the need to write ad hoc, imperative scripts for one-off tasks. The pattern also makes system management declarative and intent-driven.</span></p><p><span>In Kubernetes, operators expose a declarative interface in the form of custom resources CRs [2]. A CR defines a system resource and its properties that can be modified to manage that resource. A state declaration specifies property values in a CR. Figure 2 shows an example of desired-state declarations for ZooKeeper; it specifies primitive properties like replicas and image, and composite properties like persistence which has sub-properties. A ZooKeeper operator reconciles a managed ZooKeeper cluster to satisfy the declared state. Management operations are expressed by changing one or more property values in a CR.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure2.jpg?itok=J9-iyKpU" width="1440" height="552" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: Scaling up a ZooKeeper system (from 2 to 3 replicas) with a new desired-state declaration (CR).</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Every Kubernetes operator continuously reconciles the managed system from its current state to a newly declared desired state, if the current state does not match the declared state. Kubernetes manages the current system states in a collection of state objects in etcd, a strongly consistent datastore. Every entity in the cluster, such as a pod, a volume, and a stateful application, has a corresponding state object. State objects have uniform APIs and consistent data schema, making them highly interpretable and extensible [10].</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">3 Technique</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Acto is a state-centric testing technique. It tests operation correctness by performing end-to-end (e2e) test- ing of Kubernetes operators together with the managed systems. To do so, Acto continuously generates new operations during a test campaign, and checks if the operator always correctly reconciles the system from each current state to the desired state, or raises an alarm otherwise.</span></p><p><span>Acto detects bugs when operation correctness is violated. Such bugs include those that 1) cause an operator not to reconcile the system to desired states, 2) crash the operator or the system, and 3) prevent the managed system from recovering from an error state. Acto also detects vulnerabilities to misoperations that can drive the systems into explicit error states.</span></p><p><span>Acto generates minimized e2e test code for every alarm that it raises. These generated tests can help developers reliably reproduce a bug or a vulnerability, without rerunning the entire test campaign. That is, generated e2e tests only run operations that are necessary to set up the state for reproducing a bug or a vulnerability. Developers can include the generated e2e test in their regression test suite.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">3.1 Operation Model</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Acto models an operation as a pair, (<em>S<sup>c</sup>, D</em>), where <em>S<sup>c</sup> </em>denotes a current system state and <em>D</em> is a declaration of a valid desired state. <em>D</em> is constrained by the operation interface specification (CRD [2] in Kubernetes). If successful, an operation triggers a state transition, <em>S<sup>c</sup></em> to <em>S<sup>D</sup></em> , where <em>S<sup>D</sup></em> satisfies <em>D</em>. <em>D</em> often only specifies a (small) part of the system state. So, there are multiple possible system states that can satisfy <em>D</em>, and, in practice, only a small part of <em>S</em> needs to be examined to check if <em>S<sup>D</sup></em> satisfies <em>D</em>.</p><p>If an operation fails (e.g., due to bugs in operator code), the system enters an error state, <em>S<sup>e</sup></em>, which does not satisfy the desired state <em>D</em>. When <em>S<sup>e</sup></em> does not satisft <em>D</em>, the operator should be able to recover the system back to the previous healthy state from S<sup>e </sup>by means of a state transition using the desired-state declaration <em>D<sub>i-1</sub></em> that previously triggered the transition to <em>S<sup>c</sup></em><em>.</em></p><p>The fundamental challenge in testing operators is the prohibitive cost of testing all elements in the Cartesian product of <em>S</em> =<em> S<sup>C</sup> </em>∪ <em>S<sup>E</sup></em> and <em>Ď</em>, where S<sup>C</sup> is the set of all possible valid system states (<em>S<sup>c</sup></em> ∈ <em>S<sup>C</sup></em> ), <em>S<sup>E</sup></em> is the set of all possible error states (<em>S<sup>e</sup></em> ∈ <em>S<sup>E</sup></em>), and <em>Ď</em> is the set of all possible declarations of desired state (<em>D</em> ∈ <em>Ď</em>). There can be a large number of values for different properties that constitute the system state. Exhaustive testing could be prohibitively expensive, and any practical testing approach can only exercise a part of the state space, i.e., <em>S</em> × <em>Ď</em>.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">3.2 Test Strategy</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Acto systematically explores the state space using the following three test strategies (Figures 3a–c).</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure3.jpg?itok=GwYd3msa" width="1440" height="944" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3: State transitions of different test strategies.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong>Single operation.</strong> Acto generates a declaration of a desired state <em>D</em>, triggers the operator to reconcile the current system state <em>S<sup>c</sup></em> to the desired system state <em>S<sup>D</sup></em>, and checks whether <em>S<sup>D</sup></em> |= <em>D</em>. The single operation is applied to the initial system state <em>S<sup>c</sup></em> = <em>S<sup>0</sup></em> (starting from a non-initial state requires more operations). The key challenge is how to explore an effective and representative subset of <em>Ď</em>.</p><p><strong>Operation sequence.</strong> Acto extends single operations into a test campaign, which consists of a sequence of operations. Test campaigns overcome the limitation of the single-operation strategy, which must always start from the initial state <em>S<sup>c</sup></em> = <em>S<sup>0</sup></em>. It is important to test whether an operator can reconcile the system to desired states from different, non-initial start states. Reaching an end state from different start states increases the chance of invoking different procedures in the operator code. In a test campaign, earlier operations take the system to new states which become the start states for subsequent operations.</p><p>Acto generates a test campaign by chaining the expected end states <em>{S<sub>i</sub>}</em> from the single-operation strategy, and generating a new <em>D<sub>i</sub></em> after each successful reconciliation, as shown in Figure 3b. The result is a sequence of state transitions; after each transition Acto checks whether the expected end state <em>S<sub>i</sub></em> satisfies the desired state <em>D<sub>i</sub>.</em></p><p><span><strong>Error-state recovery.</strong> The operation-sequence strategy does not test whether an operator correctly restores </span>a system from implicit or explicit error states. If the system is in an error state <em>S<sup>e</sup></em>, the operator is responsible for recovering from <em>S<sup>e</sup></em> by reconciling the system from <em>S<sup>e</sup></em> back to the prior healthy state <em>S<span><sub>i-1</sub></span></em>. The subsequent operations start from <em>S<span><sub>i-1</sub></span></em>, such as in the transition from <em>S<span><sub>i-1</sub></span></em> → <em>S<span><sub>i+1</sub></span></em>, in Figure 3c. Error states can be reached because of operator bugs that reconcile the system to a state <em>S<sup>e</sup></em> which does not satisfy desired state <em>D</em>, or misoperations—semantic errors in <em>D</em> that escape syntactic validation against the interface specification.</p><p><span>Acto combines these three test exploration strategies (Figures 3a–c) to realize the state transition sequences in one test campaign, as shown in Figure 3d.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">3.3 Example</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We use the bug in Figure 1 as an example to illustrate Acto’s test strategy. When testing the ZooKeeper operator, as part of the operation sequence, Acto applies <em>D<sub>k</sub></em> (a ZooKeeper CR) that desires five ZooKeeper replicas, triggering the operator to set up a ZooKeeper cluster with five replicas (pods) running. Acto then applies <em>D<sub>k+1</sub></em> by reducing the desired replica number to three. The operator then scales down ZooKeeper by deleting two pods, but does not delete their volumes due to the bug. Finally, Acto applies D<sub>k+2</sub> that raises the replica number back to five. The operator creates two pods directly reusing the old volumes. Due to the bug, ZooKeeper gets stuck in an error state: the membership configurations on the old volumes are not updated, and the newly created pods keep crashing. Acto flags this bug using its test oracles.</p><p><span>To reproduce this bug without going through all the operations, Acto generates a minimized operation sequence </span>that deterministically triggers the bug.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">4 Design and Implementation</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We describe the main components of Acto and how we implement them. These components embody Acto’s state-centric testing technique; they generate declarations of desired system states, execute test campaigns, and check reconciled states using automated test oracles.</p><p><span>The Acto tool takes the following inputs: 1) a manifest for deploying the operator, 2) the specification of state declaration, i.e., the operator’s CRD [2], and 3) optionally the operator’s source code. Acto outputs test results, debugging information, and minimized test code that reproduces detected failures. Acto runs tests on virtualized Kubernetes clusters. It supports three backends: Kind, Minikube, and K3d.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">4.1 Realizing State Transitions</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>During a test campaign (Figure 3d), Acto automatically generates a new state declaration <em>D<sub>i+1</sub></em> based on the current system state <em>S<sub>i</sub></em> to realize a state transition from <em>S<sub>i</sub></em> → <em>S<sub>i+1</sub></em>. Test campaigns start from the initial state <em>S<sub>0</sub></em>. Acto triggers state transitions with the goals to 1) cover all properties exposed by the operation interface, and 2) exercise representative operation scenarios based on property semantics.</p><p>Acto systematically exercises all the properties that are defined in the operation interface. Each new <em>D<sub>i+1</sub></em> changes one property in the current state <em>S<sub>i</sub></em> and any other properties that are needed to satisfy predicates on property relationships. Specifically, Acto selects a previously untested property and uses it to declare a new desired state. The end state after one transition becomes the start state for the next transition (Figure 3b). All state declarations collectively change every property at least once during a test campaign.</p><p><span>Acto tests different scenarios based on the semantics of the changed properties. (Acto automatically infers these semantics). Table 1 gives a few such scenarios. For example, Acto tests the scale-up-and-scale- down and the scale-down-and-scale-up sequences if a property represents the number of replicas. Acto also tests different pod assignments that trigger the operator to re-configure or re-deploy managed systems differently. This scenario-driven approach allows Acto to focus on a small number of representative states, instead of the very large set of all possible property values. We implement the scenarios as plugins that can be extended or customized; users of Acto can implement more scenarios and support system-specific properties such as system configurations.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table>   <tr>     <th>Property</th>     <th>Scenarios</th>   </tr>   <tr>     <td>Replicas</td>     <td>Scale up and then down; scale down and then up; upscale over system resource limit.</td>   </tr>   <tr>     <td>Affinity</td>     <td>Place all pods on one node; spread pods to different nodes; set unsatisfiable affinity rules.</td>   </tr>   <tr>     <td>Storage</td>     <td>Expand storage volumes; shrink storage volumes; request more storage than is available in a cluster.</td>   </tr>    <tr>     <td>Access</td>     <td>Switch between normal and privileged roles.</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1: Examples of built-in scenarios of Acto to generate new state declarations and trigger state transitions. Scenarios are created based on property semantics inferred by Acto and they can be extended or customized.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Acto also generates misoperations, each of which triggers a state transition to an error state, <em>S<sup>e</sup></em>. For ex- ample, Acto generates misoperations that 1) scale the replicas beyond the total number of available physical resources, and 2) set unsatisfiable affinity rules (Table 1). Acto uses misoperations to check if an operator 1) is resilient to operation errors and 2) can recover from undesired or error states. Acto’s oracles check the former (is the system in a state <em>S<sup>e</sup></em>?). Acto checks the latter by rolling back <em>S<sup>e</sup></em> to the most recent healthy state. Misoperations that declare semantically erroneous states could escape constraint validation. A correct operator should not carry out an erroneous operation or at least should recover from operation failures.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">4.2 Generating State Declarations</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Acto generates desired-state declarations, <em>D</em> ∈ <em>Ď</em> , that are syntactically valid, resemble real-world scenarios, and satisfy predicates on property relationships. Such desired states improve the effectiveness and efficiency of Acto’s state space exploration. End-to-end tests are expensive, so a <em>D</em> that does not satisfy these conditions has a low chance of finding bugs.</p><p><span>Acto ensures that all property values in declared desired states are syntactically valid using the opera- tion interface specification. (Invalid declarations would likely be directly rejected by the Kubernetes API servers before reaching the operator.) Kubernetes’ OpenAPISchema specification defines constraints on all supported properties. For composite properties, Acto uses composite constraints like required properties and also derives constraints from the sub-properties. For primitive properties, Acto uses constraints like the type, min/max values (for numeric types), length (for string type), regular-expression patterns, etc.</span></p><p><span>To exercise various operation scenarios, Acto changes properties based on their semantics. Acto in- fers the semantics of a property in the interface specification by mapping it to a set of resource types in the Kubernetes core APIs. Such mapping is feasible because many operations for property changes are eventually delegated to Kubernetes core services. Acto exploits the insight that property structure is ef- fective for mapping to properties in the Kubernetes core resource specification. Specifically, all Kuber- netes core resource types have unique structures. Figure 4 exemplifies how Acto infers semantics from the property structure: CassOp has a <em>cassandraDataVolumeClaimSpec</em> property with the same structure as the <em>VolumeClaimTemplates</em> property in Kubernetes’ StatefulSet resource. Therefore, Acto infers the semantics of <em>cassandraDataVolumeClaimSpec </em>using a structural mapping. When provided with operator source code, Acto can obtain more complete mapping via static program analysis that tracks how the property value is used in the operator code via its data flows.</span></p><p><span>To generate values for properties with inferred semantics, Acto currently implements 57 property- specific generators based on Kubernetes resource semantics. Most of these properties are composite. The generators focus on high-level semantics to exercise different scenarios (Table 1). Each generator creates property values to realize a scenario. We find that most properties exposed by operation interfaces (83% on average in our evaluated operators) can be mapped to Kubernetes resources. For properties whose se- mantics Acto cannot infer, Acto mutates current values based on their data types while satisfying syntactic constraints. Acto only mutates primitive sub-properties of composite properties.</span></p><p><span>Lastly, the values Acto generates should satisfy predicates, in the form of property dependencies, for changed property values to trigger state transitions. Acto automatically infers property dependencies from naming convention. In Kubernetes, dependencies can be identified by feature toggles—each composite property has a Boolean sub-property named “enabled.” For example, operations that change PCN/MongoOp’s backup policy must also set Backup.Enabled to True. With operator source code, Acto can also detect dependencies among property values by analyzing control-flow relationships among program variables.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure4.jpg?itok=oxWW-syc" width="1440" height="1062" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4: Semantic analysis maps the properties in the CRD interface to the properties of a Kubernetes core resource.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">4.3 Test Oracles</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Acto’s test oracles check if the system state after an operation matches the desired state. If there is a match, Acto reports the operation as successful. Otherwise, Acto signals an alarm that the user can inspect to find bugs. The complexity of Acto’s oracles depends on whether mismatches between reconciled and desired states manifest explicitly or implicitly. Acto implements oracles to check for state mismatches that manifest as explicit <em>error states</em>, such as exceptions, error codes, and timeouts.</p><p>Acto also implements oracles to check if <em>S<sub>i</sub></em> satisfies <em>D<sub>i</sub></em> for each state transition, as many operator bugs manifest as implicit-state mismatches with no explicit symptoms. Checking whether <em>S<sub>i</sub></em> satisfies <em>D<sub>i</sub></em> is challenging. First, <em>S<sub>i</sub></em> and <em>D<sub>i</sub></em> are represented differently: <em>D<sub>i</sub></em> is a specification [2] and <em>S<sub>i</sub></em> is embodied in state objects [4]. Second, satisfiability is domain-specific; its semantics may not be obvious. To address these challenges, Acto devises the consistency oracle and differential oracle.</p><p><span>In addition, Acto also has an interface to allow users to add custom oracles with domain-specific knowledge, e.g., a probe that tries to set and get some path in ZooKeeper.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd"> 4.3.1 Consistency Oracle</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Some bugs occur if an operator stops reconciliation because the system is in state <em>S<sub>i</sub></em> which satisfies <em>D</em> in the operator’s view, but which does not satisfy <em>D</em> in Kubernetes’ view. To detect such bugs, Acto additionally checks whether the Kubernetes’ view matches <em>D</em>; the Kubernetes’ view is encoded in spec sections of state objects, which are jointly maintained by all running controllers and operators. For each transition from <em>S<sub>i−1</sub></em> → <em>S<sub>i</sub></em>, Acto attempts to match each property <em>p</em> (specified in <em>D<sub>i</sub></em>) to the corresponding spec fields in the state objects. If a match is found, it indicates that Kubernetes agrees with the operator. Otherwise, Acto raises an alarm.</p><p> </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">4.3.2 Differential Oracle</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>The differential oracle does not check against <em>D<sub>i</sub></em>; it checks that an operator 1) reconciles to the matching desired states from different existing states <em>S<sub>i−1</sub></em> and <em>S<sub>0</sub></em>, and 2) recovers the system from (implicit or explicit) error state <em>S<sup>e</sup></em> to state <em>S<sub>i−1</sub></em>. Acto rolls back to <em>S<sub>i−1</sub></em> to continue exploration from a known good state. Figure 5 shows a bug detected by the differential oracle. There, the Boolean KnativeOp property contour.enabled enables or disables Contour (an ingress controller). But, a KnativeOp bug makes it fail to disable Contour once it is enabled. The consistency oracle does not detect this bug: it is hard to automat- ically map the Boolean property to the existence of a Contour pod. The differential oracle detects the bug because a Contour pod appears in <em>S<sub>i</sub></em>, but not in <em>S'<sub>i</sub></em>.</p><div><p><span> Note that reporting alarms for any difference in the state objects of </span><em>S<sub>i</sub></em><span> </span><span>and </span><em>S'<sub>i</sub></em>would be brittle and lead to false positives, because execution-specific values like timestamps, IP addresses, and ports may change nondeterministically. Acto excludes execution-specific fields when comparing state objects. Acto automatically labels those fields by 1) running the transition <em>S<sub>0 </sub></em>→ <em>S<sub>1</sub></em> multiple times as a calibration and labeling fields with values varying across runs, and 2) running <em>S<sub>0 </sub></em>→ <em>S<sub>1</sub></em> multiple times, iff the differential oracle fires an alarm on <em>S<sub>i</sub></em>, to ensure relevant fields are deterministic. </p></div><p> </p><div><div><div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure5.jpg?itok=oTXgm7-L" width="1440" height="602" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 5: A KnativeOp bug that is detected by Acto’s differential oracle [5]. Contour continues to manage ingress after an operation explicitly disables it.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">5 Evaluation and Experience</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In our original SOSP paper [14], we rigorously evaluated Acto with eleven popular open-source Kubernetes operators which manage nine cloud systems. All evaluated operators were developed by the official teams of the managed systems, or by companies that sell services built around the managed systems. Acto found new bugs in every evaluated Kubernetes operator, and in total found 56 unknown bugs in all the evaluated operators. We had reported all these bugs. At that time, 42 were confirmed and 30 have been fixed. No bug report was rejected. Acto also finds six bugs in Kubernetes and in the Go runtime that affect multiple operators; all were confirmed or fixed.</span></p><p><span>Since then, we have been continuously developing the Acto project, and Acto has been used to test more Kubernetes operators. Recently, we designed an assignment on Kubernetes controller reliability based on the Acto project for CS 523 (Advanced Operating Systems) at the University of Illinois Urbana-Champaign and used it in the semester of Spring 2024, with the purpose of teaching cloud computing concepts and cloud-native technologies. Many students in the course have successfully applied Acto to more than 40 open-source Kubernetes operators. Most students find Acto easy (and fun) to use and effective in finding defects in existing operators. Students are encouraged to report the bugs they find back to the developers. So far, Acto has helped find more than 80 new bugs (at least 62 were confirmed and 41 have been fixed). The project maintains the list of bugs found by Acto [8].</span></p><p><span>During the process, students continuously improve Acto and add new features. For example, Acto now has support for Kubernetes operators written in Java and Rust, in addition to Go. Acto also starts to support simple crash testing [24]. Acto has also been used in other research projects on Kubernetes reliability. For example, Acto was used to empirically evaluate formally verified Kubernetes controllers [25].</span></p><p><span>The original Acto paper is available at <a href="https://github.com/xlab-uiuc/acto/blob/main/docs/acto- paper_sosp2023.pdf." target="_blank" title="https://github.com/xlab-uiuc/acto/blob/main/docs/acto- paper_sosp2023.pdf." rel="nofollow">https://github.com/xlab-uiuc/acto/blob/main/docs/acto- paper_sosp2023.pdf.</a></span></p><div><div></div></div></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Cloud Native Computing Foundation Operator White Paper. <a href="https://www.cncf.io/wp-content/uploads/ 2021/07/CNCF_Operator_WhitePaper.pdf" target="_blank" title="https://www.cncf.io/wp-content/uploads/ 2021/07/CNCF_Operator_WhitePaper.pdf" rel="nofollow">https://www.cncf.io/wp-content/uploads/ 2021/07/CNCF_Operator_WhitePaper.pdf</a>.&nbsp;&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2]&nbsp;Custom Resources. <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom- resources/" target="_blank" title="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom- resources/" rel="nofollow">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom- resources/</a>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3]&nbsp;Operator Pattern. <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" target="_blank" title="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="nofollow">https://kubernetes.io/docs/concepts/extend-kubernetes/operator/</a>.</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4]&nbsp; Understanding Kubernetes Objects. <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes- objects/" target="_blank" title="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes- objects/" rel="nofollow">https://kubernetes.io/docs/concepts/overview/working-with-</a><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes- objects/" target="_blank" title="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes- objects/" rel="nofollow">objects/kubernetes- objects/</a>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Contour pod is not deleted when disabled by user. <a href="//github.com/knative/operator/pull/1176, 2022." target="_blank" title="//github.com/knative/operator/pull/1176, 2022." rel="nofollow">https://github.com/knative/operator/pull/1176</a>, 2022.</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Kubernetes and cloud native operations report 2022. <a href="https://juju.is/cloud-native-kubernetes-usage- report-2022#kubernetes-operators" target="_blank" title="https://juju.is/cloud-native-kubernetes-usage- report-2022#kubernetes-operators" rel="nofollow">https://juju.is/cloud-native-kubernetes-usage- report-2022#kubernetes-operators</a>, 2022.</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Zookeeper pod keeps crashing when scaling down and up. <a href="https://github.com/pravega/zookeeper- operator/pull/526" target="_blank" title="https://github.com/pravega/zookeeper- operator/pull/526" rel="nofollow">https://github.com/pravega/zookeeper- operator/pull/526</a>, 2022.</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Bugs found by Acto. <a href="https://github.com/xlab-uiuc/acto/blob/main/bugs.md" target="_blank" title="https://github.com/xlab-uiuc/acto/blob/main/bugs.md" rel="nofollow">https://github.com/xlab-uiuc/acto/blob/main/bugs.md</a>, Apr. 2024.</p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] BROWN, A. B., AND PATTERSON, D. A. Undo for Operators: Building an Undoable E-mail Store. In <em>Proceedings of the 2003 USENIX Annual Technical Conference (ATC’03)</em> (June 2003).</p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10] BURNS, B., GRANT, B., OPPENHEIMER, D., BREWER, E., AND WILKES, J. <em>Borg, Omega, and Kubernetes. Communications of the ACM 59,5</em> (May 2016), 50–57.</p> </div><div class="field-item odd"><a class="anchor" name="reference-11"></a><p>[11] CEBULA, M., AND SHERROD, B. 10 Weird Ways to Blow Up Your Kubernetes. In <em>KubeCon North America</em> (Nov. 2019).</p> </div><div class="field-item even"><a class="anchor" name="reference-12"></a><p>[12] DOBIES, J., AND WOOD, J. <em>Kubernetes Operators: Automating the Container Orchestration Platform.</em> O’Reilly Media, Inc., 2020.</p> </div><div class="field-item odd"><a class="anchor" name="reference-13"></a><p>[13] GRAY, J. Why Do Computers Stop and What Can Be Done About It? <em>Tandem Technical Report 85.7</em> (June 1985).</p> </div><div class="field-item even"><a class="anchor" name="reference-14"></a><p>[14] GU, J. T., SUN, X., ZHANG, W., JIANG, Y., WANG, C., VAZIRI, M., LEGUNSEN, O., AND XU, T. Acto: Automatic End-to-End Testing for Operation Correctness of Cloud System Management. In <em>Proceedings of the 29th ACM Symposium on Operating Systems Principles (SOSP’23) </em>(Oct. 2023).</p> </div><div class="field-item odd"><a class="anchor" name="reference-15"></a><p>[15] GUILLOUX, S. Writing a Kubernetes Operator: the Hard Parts. In <em>KubeCon North America</em> (Nov. 2019).</p> </div><div class="field-item even"><a class="anchor" name="reference-16"></a><p>[16] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B. ZooKeeper: Wait-free coordination for Internet-scale&nbsp;systems. In <em>Proceedings of the 2010 USENIX Annual Technical Conference (ATC’10) </em>(June 2010).</p> </div><div class="field-item odd"><a class="anchor" name="reference-17"></a><p>[17] KUMAR,H., AND ŠAFRÁNEK, J.&nbsp;Storage on Kubernetes - Learning From Failures. In <em>KubeCon North America</em> (Nov. 2019).</p> </div><div class="field-item even"><a class="anchor" name="reference-18"></a><p>[18] LAGRESLE, M. Moving to Kubernetes: the Bad and the Ugly. In <em>ContainerDays</em> (June 2019).</p> </div><div class="field-item odd"><a class="anchor" name="reference-19"></a><p>[19] MADHU,C. Preventing Controller Sprawl From Taking Down Your Cluster. In <em>KubeCon North America</em> (Oct.2022).</p> </div><div class="field-item even"><a class="anchor" name="reference-20"></a><p>[20] NAGARAJA, K., OLIVEIRA, F., BIANCHINI, R., MARTIN, R. P., AND NGUYEN, T. D. Understanding and Dealing with Operator Mistakes in Internet Services. In <em>Proceedings of the 6th USENIX Conference on Operating Systems Design and Implementation (OSDI’04)</em> (Dec. 2004).</p> </div><div class="field-item odd"><a class="anchor" name="reference-21"></a><p>[21] OPPENHEIMER, D., GANAPATHI, A., AND PATTERSON, D. A. Why Do Internet Services Fail, and What Can Be Done About It? In <em>Proceedings of the 4th USENIX Symposium on Internet Technologies and Systems (USITS’03)</em> (Mar. 2003).</p> </div><div class="field-item even"><a class="anchor" name="reference-22"></a><p>[22] RATIS, P. Lessons Learned Using the Operator Pattern to Build a Kubernetes Platform. In <em>SREcon21</em> (Oct. 2021).</p> </div><div class="field-item odd"><a class="anchor" name="reference-23"></a><p>[23] SUN, X., CHENG, R., CHEN, J., ANG, E., LEGUNSEN, O., AND XU, T. Testing Configuration Changes in Context to Prevent Production Failures. In <em>Proceedings of the 14th USENIX Symposium on Operating Systems Design and Implementation (OSDI’20)</em> (Nov. 2020).</p> </div><div class="field-item even"><a class="anchor" name="reference-24"></a><p>[24] SUN, X., LUO, W., GU, J. T., GANESAN, A., ALAGAPPAN, R., GASCH, M., SURESH, L., AND XU, T. Automatic Reliability Testing for Cluster Management Controllers. In <em>Proceedings of the 16th USENIX Symposium on Operating Systems Design and Implementation (OSDI’22) </em>(July 2022).</p> </div><div class="field-item odd"><a class="anchor" name="reference-25"></a><p>[25] SUN, X., MA, W., GU, J. T., MA, Z., CHAJED, T., HOWELL, J., LATTUADA, A., PADON, O., SURESH, L., SZEK- ERES, A., AND XU, T. Anvil: Verifying Liveness of Cluster Management Controllers. In <em>Proceedings of the 18th USENIX Symposium on Operating Systems Design and Implementation (OSDI’24)</em> (July 2024).</p> </div><div class="field-item even"><a class="anchor" name="reference-26"></a><p>[26] XU, T., JIN, X., HUANG, P., ZHOU, Y., LU, S., JIN, L., AND PASUPATHY, S. Early Detection of Configuration Errors to Reduce Failure Damage. In <em>Proceedings of the 12th USENIX Symposium on Operating Systems Design and Implementation (OSDI’16) </em>(Nov. 2016).</p> </div><div class="field-item odd"><a class="anchor" name="reference-27"></a><p>[27] XU, T., ZHANG, J., HUANG, P., ZHENG, J., SHENG, T., YUAN, D., ZHOU, Y., AND PASUPATHY, S. Do Not Blame Users for Misconfigurations. In <em>Proceedings of the 24th Symposium on Operating System Principles (SOSP’13)</em> (Nov. 2013).</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">SRE</li>
                                                    <li class="category">Distributed systems</li>
                                                    <li class="category">Sysadmin</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/analysis-usenix-paper-downloads"
                    >Analysis of USENIX Paper Downloads</a>
                </h2>

                                    <time datetime="2024-07-30 00:00:00">
                        2024-07-30 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Rik Farrow</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In September of 2022, I started receiving the web log files for usenix.org. I felt I needed to see what articles were being downloaded, and the current system didn't provide the insights I was looking for in a timely manner. I filtered out log entries for publications/login, counted the download frequencies, and sorted these with the most popular first.</span></p><p><span>While I might think that a particular topic will be interesting to lots of people, I am not always right. And as an editor who doesn't pay authors, I really, really, want people to read the articles that they have taken the time to write. I have a responsibility to authors, one I only get to exercise by carefully curating the authors of papers about topics I think will be very popular.</span></p><p><span>Over time, I noticed a couple of things. Sometimes an article might remain popular for over a year, while other articles would suddenly become popular for a period of just weeks. In both cases, the initial surge in popularity often involves promotion by people other than the authors in places like Slashdot and HackerNews. And sometimes an article just fills a particular need through its thorough explanation of some technical topic.</span></p><p><span>I noticed a prominent example of how promotion affects downloads the second time I took a look at papers. <a href="https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-yuan.pdf" target="_blank" title="Simple Testing Can Prevent Most Critical Failures">An OSDI paper</a> had an unusually high number of downloads in the September-October 2023 timeframe: 1818. I asked Ding Yuan, the lead author, if he had any idea what might have caused this increase in activity. Ding discovered that a post on X by Kevlin Henney on September 6 had resulted in about 20% of his followers downloading the paper.</span></p><div><p><span>Besides papers and ;login: articles leaping in popularity because of promotion, some stay near the top for other reasons. I skimmed the top 20 papers from June 2024 trying to determine what it was about these papers that made them so popular. I first noticed that they were all well-written, but that's really not uncommon for highly-rated papers.</span></p><p><span>The other things all these papers had in common was that they weren't just introducing some new research or software: they did a great job of teaching about the issues involved. Usually, section two of a paper covers related-work, while section one provides motivation for why this particular work deserves to be published. Between these two sections, you can learn a lot about a topic. And that's why you find papers about Meta's Haystack, Google's Transformer, and Yahoo's ZooKeeper papers in the top 20 (Table 1).</span></p></div><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1: Top paper downloads during the month of June 2024</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p> </p><table><tbody><tr><th></th></tr><tr><td>Index</td><td>Title</td> <td>Description</td><td>Downloads</td></tr><tr><td>1</td><td><a href="https://www.usenix.org/legacy/event/lisa98/full_papers/oetiker/oetiker.pdf">The Multi Router Traffic Grapher and RRDtool</a></td><td>Description of MRTG and RRDtool, a binary logging tool for time-sequence data</td><td>939</td></tr> <tr><td>2</td><td><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">Scaling Memcache at Facebook</a></td><td>How Facebook scaled memcached to thousands of servers</td><td>874</td></tr> <tr><td>3</td><td><a href="https://www.usenix.org/system/files/soups2019-busse.pdf">Replication: No One Can Hack My Mind</a></td><td>Survey of security advice from experts and non-experts</td><td>845</td></tr> <tr><td>4</td><td><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-pellegrino.pdf">In the Compression Hornet’s Nest</a></td><td>Denial of service attacks when Deflate is used in Apache HTTPD Tomcat and other services</td><td>772</td></tr> <tr><td>5</td><td><a href="https://www.usenix.org/legacy/events/sec10/tech/full_papers/Aggarwal.pdf">An Analysis of Private Browsing Modes in Modern Browsers</a></td><td>Evaluation of private browsing in four major browsers, inconsistencies and failures</td><td>743</td></tr><tr><td>6</td><td><a href="https://www.usenix.org/system/files/sec23fall-prepub-234-wu-mingshi.pdf">How the Great Firewall of China Detects and Blocks Fully Encrypted Traffic</a></td><td>Blocking encrypted traffic based on passive traffic analysis</td><td>642</td></tr> <tr><td>7</td><td><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-porter.pdf">REX: A Development Platform and Online Learning Approach</a></td><td>Dana, a component-based programming language, an assembly and learning framework, and an online learning implementation that altogether allows for runtime optimization</td><td>533</td></tr> <tr><td>8</td><td><a href="https://www.usenix.org/system/files/sec21-carlini-extracting.pdf">Extracting Training Data from Large Language Models</a></td><td>Training data from LLMs (GPT2) can be recovered</td><td>540</td></tr> <tr><td>9</td><td><a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-abadi.pdf">TensorFlow: A System for Large-Scale Machine Learning</a></td><td>One of the foundational papers leading to LLMs: describes a dataflow graph to represent both the computation in an algorithm and the state</td><td>533</td></tr> <tr><td>10</td><td><a href="https://www.usenix.org//system/files/sec21-ulqinaku.pdf">Is Real-time Phishing Eliminated with FIDO?</a></td><td>Downgrade attack against the use of two-factor authentication that uses the FIDO protocol</td><td>493</td></tr> <tr><td>11</td><td><a href="https://www.usenix.org/system/files/conference/nsdi12/nsdi12-final138.pdf">Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</a></td><td>Improvement to Hadoop by caching datasets, Spark</td><td>475</td></tr> <tr><td>12</td><td><a href="https://www.usenix.org//system/files/conference/woot12/woot12-final24.pdf">Remote Exploitation of Memory Corruptions in Cellular Protocol Stacks</a></td><td>Demonstration of attacks against the radio processor on smartphones</td><td>462</td></tr> <tr><td>13</td><td><a href="https://www.usenix.org//system/files/osdi22-yu.pdf">Orca: A Distributed Serving System for Transformer-Based Generative Models</a></td><td>New scheduling mechanism improves performance of LLM inference procedures</td><td>459</td></tr> <tr><td>14</td><td><a href="https://www.usenix.org/legacy/event/hotcloud10/tech/full_papers/Zaharia.pdf">Spark: Cluster Computing with Working Sets</a></td><td>Adding of working sets for MapReduce and interactive analytics using a Dryad-like interface</td><td>451</td></tr> <tr><td>15</td><td><a href="https://www.usenix.org//system/files/conference/hotos15/hotos15-paper-mcsherry.pdf">Scalability! But at what COST?</a></td><td>Workshop paper that explains COST—the Configuration that Outperforms a Single Thread—showing that many data parallel systems are either slower than a single threaded solution or have high COST</td><td>440</td></tr> <tr><td>16</td><td><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf">Finding a needle in Haystack: Facebook’s photo storage</a></td><td>Facebook's Haystack photo storage system keeps metadata in memory</td><td>376</td></tr> <tr><td>17</td><td><a href="https://www.usenix.org/system/files/conference/nsdi18/nsdi18-dalton.pdf">Andromeda: Performance, Isolation, and Velocity at Scale</a></td><td>Google's Andromeda cloud network virtualization for isolation and performance</td><td>373</td></tr> <tr><td>18</td><td><a href="https://www.usenix.org/system/files/sec24summer-prepub-465-xue.pdf">Fingerprinting Obfuscated Proxy Traffic with Encapsulated TLS Handshakes</a></td><td>Uncovering obfuscated proxy traffic such is done by Great Firewall of China</td><td>373</td></tr><tr><td>19</td><td><a href="https://www.usenix.org/legacy/event/atc10/tech/full_papers/Hunt.pdf">Zookeeper</a></td><td>Description of Yahoo's ZooKeeper system for coordinating distributed services</td><td>353</td></tr> <tr><td>20</td><td><a href="https://usenix.org/system/files/atc22-elhemali.pdf" rel="nofollow">Amazon DynamoDB</a></td><td>A fully distributed NoSQL database supporting multiple tenants, limitless tables, predictable and reliable performance</td><td>343</td></tr></tbody></table></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>At the end of this article, I've included Table 2 with the top 100 paper downloads from July 2024. If you attend to the downloads column, you'll notice that there is a quick dropoff in number of downloads. I graphed the top 3000 downloads against their index numbers, and you can see (Figure 1) just how steeply downloads drop off. When you consider that there are nearly 31 thousand papers represented in the logfiles, this might seem very unfair that a relative handful appear the very popular. I suggest keeping in mind a couple of things: one, that papers about famous software are going to be downloaded more often, and two, that promotion can briefly push a paper to the top of the list.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure1_7.png?itok=qujQVSrn" width="1440" height="1080" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: Download frequency vs paper index; relatively few papers get downloaded often.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>I produced two lists of the top 100 paper downloads, one from the end of 2023 and the other from July 2024, and only 31 papers are in both lists. In other words, there is a fair amount of churn happening over time.</span></p><p><span>I didn't just look at the top papers either. I skimmed the paper with index number 3000, a workshop paper from <a href="https://www.usenix.org/legacy/events/hotpar11/tech/final_files/Boehm.pdf" target="_blank" title="There are no benign data races">HotPar'11</a> by Hans Boehm where he points out that there are no benign data races. A bit obscure, certainly, but still an interesting enough workshop paper.</span></p><p><span>One of the last entries in the list was the slide deck from a <a href="https://www.usenix.org/legacy/event/leet10/tech/slides/nunnery.pdf" target="_blank" title="Waledac botnet">LEET'10 presentation</a> about botnets. These days, it seems that no one talks about botnets, and looking at the web logs, only crawler bots actually visited this link. Still, I found the slides interesting as the botnot it described was very advanced compared to those from the 90s, with multiple tiers for command and control.</span></p><p><span>Papers with ten or less downloads, starting almost halfway down the list, are still being downloaded by other than bots. Unless the browser information has been falsified, that LEET presentation mentioned above was just downloaded by three bots, and nothing else.</span></p><p><span>Finally, there's the matter of conference popularity and how that affects the papers downloaded. If you go back to the early days of USENIX, there were just two conferences: USENIX Summer and USENIX Winter. All topics were included in those conferences, where the main difference between them, besides the season, is one happened near the East Coast and the other on the West Coast. Starting around 1990, conferences began appearing that covered a particular topic area, like system administration or security—</span> the first two new conferences. Figure 2 shows the binning of downloads when separated into conference categories.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure2_4.png?itok=XSBJGkvX" width="1440" height="1080" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: Downloads binned by conference.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Security dwarfs all other categories. If you wonder why this is, just consider that there were over 400 papers at Security'23, and Security'24 has even more. Some conferences, like SRE, have no papers at all, but they do have some presentation slides and all presentations appear on YouTube as videos, data not included in this analysis. LISA had few papers, but one from LISA'98 by Toby Oetiker about RRDTool is often in the top 100.</span></p><p>I'm closing this brief analysis with Table 2, the top 100 downloads during July 2024. When I compared this list to the one from June, 37 papers were the same. If you are wondering about the outlier, <span><a href="https://www.usenix.org/system/files/sec24fall-prepub-93-dossche.pdf" target="_blank" title="Inference of Error Specifications and Bug Detection">Inference of Error Specifications and Bug Detection Using Structural Similarities</a> by Dossche and Coppens with over 10,000 downloads, I quickly found a posting on X by Winson Tang, referring to this paper.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 2: Top 100 downloads of papers the month of July 2024</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table><tbody><tr><th></th></tr><tr><td>Index</td><td>URL</td><td>Downloads</td></tr> <tr><td>1</td><td><a href="https://usenix.org/system/files/sec24fall-prepub-93-dossche.pdf" rel="nofollow">https://usenix.org/system/files/sec24fall-prepub-93-dossche.pdf</a></td><td>10060</td></tr> <tr><td>2</td><td><a href="https://usenix.org/system/files/osdi24-chen-haibo.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-chen-haibo.pdf</a></td><td>3225</td></tr> <tr><td>3</td><td><a href="https://usenix.org/system/files/atc24-li-hongyu.pdf" rel="nofollow">https://usenix.org/system/files/atc24-li-hongyu.pdf</a></td><td>2168</td></tr> <tr><td>4</td><td><a href="https://usenix.org/events/osdi10/tech/full_papers/Xiong.pdf" rel="nofollow">https://usenix.org/events/osdi10/tech/full_papers/Xiong.pdf</a></td><td>841</td></tr> <tr><td>5</td><td><a href="https://usenix.org/conference/usenixsecurity15/sec15-paper-pellegrino.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity15/sec15-paper-pellegrino.pdf</a></td><td>684</td></tr> <tr><td>6</td><td><a href="https://usenix.org/conference/hotstorage18/hotstorage18-paper-raju.pdf" rel="nofollow">https://usenix.org/conference/hotstorage18/hotstorage18-paper-raju.pdf</a></td><td>665</td></tr> <tr><td>7</td><td><a href="https://usenix.org/conference/usenixsecurity16/sec16_paper_saltaformaggio.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity16/sec16_paper_saltaformaggio.pdf</a></td><td>545</td></tr> <tr><td>8</td><td><a href="https://usenix.org/system/files/osdi22-yu.pdf" rel="nofollow">https://usenix.org/system/files/osdi22-yu.pdf</a></td><td>523</td></tr> <tr><td>9</td><td><a href="https://usenix.org/system/files/osdi24-sun-xudong.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-sun-xudong.pdf</a></td><td>513</td></tr> <tr><td>10</td><td><a href="https://usenix.org/conference/nsdi13/nsdi13-final170_update.pdf" rel="nofollow">https://usenix.org/conference/nsdi13/nsdi13-final170_update.pdf</a></td><td>512</td></tr> <tr><td>11</td><td><a href="https://usenix.org/system/files/osdi24-choudhury.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-choudhury.pdf</a></td><td>497</td></tr> <tr><td>12</td><td><a href="https://usenix.org/conference/osdi16/osdi16-abadi.pdf" rel="nofollow">https://usenix.org/conference/osdi16/osdi16-abadi.pdf</a></td><td>426</td></tr> <tr><td>13</td><td><a href="https://usenix.org/event/hotcloud10/tech/full_papers/Zaharia.pdf" rel="nofollow">https://usenix.org/event/hotcloud10/tech/full_papers/Zaharia.pdf</a></td><td>390</td></tr> <tr><td>14</td><td><a href="https://usenix.org/conference/nsdi12/nsdi12-final138.pdf" rel="nofollow">https://usenix.org/conference/nsdi12/nsdi12-final138.pdf</a></td><td>373</td></tr> <tr><td>15</td><td><a href="https://usenix.org/system/files/sec21-carlini-extracting.pdf" rel="nofollow">https://usenix.org/system/files/sec21-carlini-extracting.pdf</a></td><td>372</td></tr> <tr><td>16</td><td><a href="https://usenix.org/event/osdi10/tech/full_papers/Beaver.pdf" rel="nofollow">https://usenix.org/event/osdi10/tech/full_papers/Beaver.pdf</a></td><td>361</td></tr> <tr><td>17</td><td><a href="https://usenix.org/system/files/osdi24_full_proceedings.pdf" rel="nofollow">https://usenix.org/system/files/osdi24_full_proceedings.pdf</a></td><td>352</td></tr> <tr><td>18</td><td><a href="https://usenix.org/system/files/osdi24-zhong-yuhong.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-zhong-yuhong.pdf</a></td><td>336</td></tr> <tr><td>19</td><td><a href="https://usenix.org/system/files/osdi24-skiadopoulos.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-skiadopoulos.pdf</a></td><td>320</td></tr> <tr><td>20</td><td><a href="https://usenix.org/system/files/osdi24-chow.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-chow.pdf</a></td><td>305</td></tr> <tr><td>21</td><td><a href="https://usenix.org/events/sec09/tech/full_papers/crosby.pdf" rel="nofollow">https://usenix.org/events/sec09/tech/full_papers/crosby.pdf</a></td><td>302</td></tr> <tr><td>22</td><td><a href="https://usenix.org/conference/usenixsecurity18/sec18-staicu.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity18/sec18-staicu.pdf</a></td><td>300</td></tr> <tr><td>23</td><td><a href="https://usenix.org/conference/nsdi18/nsdi18-dalton.pdf" rel="nofollow">https://usenix.org/conference/nsdi18/nsdi18-dalton.pdf</a></td><td>297</td></tr> <tr><td>24</td><td><a href="https://usenix.org/conference/hotos15/hotos15-paper-mcsherry.pdf" rel="nofollow">https://usenix.org/conference/hotos15/hotos15-paper-mcsherry.pdf</a></td><td>294</td></tr> <tr><td>25</td><td><a href="https://usenix.org/system/files/osdi24-lee.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-lee.pdf</a></td><td>294</td></tr> <tr><td>26</td><td><a href="https://usenix.org/events/sec03/tech/full_papers/crosby/crosby.pdf" rel="nofollow">https://usenix.org/events/sec03/tech/full_papers/crosby/crosby.pdf</a></td><td>291</td></tr> <tr><td>27</td><td><a href="https://usenix.org/conference/usenixsecurity14/sec14-paper-yarom.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity14/sec14-paper-yarom.pdf</a></td><td>290</td></tr> <tr><td>28</td><td><a href="https://usenix.org/conference/usenixsecurity17/sec17-tang.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity17/sec17-tang.pdf</a></td><td>283</td></tr> <tr><td>29</td><td><a href="https://usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf" rel="nofollow">https://usenix.org/events/sec10/tech/full_papers/Aggarwal.pdf</a></td><td>277</td></tr> <tr><td>30</td><td><a href="https://usenix.org/system/files/login/articles/login_spring17_08_bratus.pdf" rel="nofollow">https://usenix.org/system/files/login/articles/login_spring17_08_bratus.pdf</a></td><td>276</td></tr> <tr><td>31</td><td><a href="https://usenix.org/events/sec10/tech/full_papers/Felmetsger.pdf" rel="nofollow">https://usenix.org/events/sec10/tech/full_papers/Felmetsger.pdf</a></td><td>270</td></tr> <tr><td>32</td><td><a href="https://usenix.org/system/files/sec20-lee-hyeonmin.pdf" rel="nofollow">https://usenix.org/system/files/sec20-lee-hyeonmin.pdf</a></td><td>269</td></tr> <tr><td>33</td><td><a href="https://usenix.org/system/files/woot20-paper-obermaier.pdf" rel="nofollow">https://usenix.org/system/files/woot20-paper-obermaier.pdf</a></td><td>266</td></tr> <tr><td>34</td><td><a href="https://usenix.org/system/files/sec20fall_lee_prepub_0.pdf" rel="nofollow">https://usenix.org/system/files/sec20fall_lee_prepub_0.pdf</a></td><td>264</td></tr> <tr><td>35</td><td><a href="https://usenix.org/system/files/atc22-elhemali.pdf" rel="nofollow">https://usenix.org/system/files/atc22-elhemali.pdf</a></td><td>263</td></tr> <tr><td>36</td><td><a href="https://usenix.org/events/fast11/tech/full_papers/Wei.pdf" rel="nofollow">https://usenix.org/events/fast11/tech/full_papers/Wei.pdf</a></td><td>259</td></tr> <tr><td>37</td><td><a href="https://usenix.org/system/files/sec20fall_reichel_prepub.pdf" rel="nofollow">https://usenix.org/system/files/sec20fall_reichel_prepub.pdf</a></td><td>256</td></tr> <tr><td>38</td><td><a href="https://usenix.org/system/files/sec19-cidon.pdf" rel="nofollow">https://usenix.org/system/files/sec19-cidon.pdf</a></td><td>254</td></tr> <tr><td>39</td><td><a href="https://usenix.org/system/files/sec20-oleksenko.pdf" rel="nofollow">https://usenix.org/system/files/sec20-oleksenko.pdf</a></td><td>254</td></tr> <tr><td>40</td><td><a href="https://usenix.org/system/files/usenixsecurity23-moghimi.pdf" rel="nofollow">https://usenix.org/system/files/usenixsecurity23-moghimi.pdf</a></td><td>254</td></tr> <tr><td>41</td><td><a href="https://usenix.org/events/sec01/full_papers/gutmann/gutmann.pdf" rel="nofollow">https://usenix.org/events/sec01/full_papers/gutmann/gutmann.pdf</a></td><td>254</td></tr> <tr><td>42</td><td><a href="https://usenix.org/system/files/usenixsecurity23-feng.pdf" rel="nofollow">https://usenix.org/system/files/usenixsecurity23-feng.pdf</a></td><td>251</td></tr><tr><td>43</td><td><a href="https://usenix.org/system/files/osdi24-sun-hao.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-sun-hao.pdf</a></td><td>248</td></tr> <tr><td>44</td><td><a href="https://usenix.org/event/atc10/tech/full_papers/Hunt.pdf" rel="nofollow">https://usenix.org/event/atc10/tech/full_papers/Hunt.pdf</a></td><td>246</td></tr> <tr><td>45</td><td><a href="https://usenix.org/conference/usenixsecurity18/sec18-van_schaik.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity18/sec18-van_schaik.pdf</a></td><td>245</td></tr> <tr><td>46</td><td><a href="https://usenix.org/system/files/sec21-ragab.pdf" rel="nofollow">https://usenix.org/system/files/sec21-ragab.pdf</a></td><td>243</td></tr> <tr><td>47</td><td><a href="https://usenix.org/system/files/usenixsecurity23-ayalon.pdf" rel="nofollow">https://usenix.org/system/files/usenixsecurity23-ayalon.pdf</a></td><td>233</td></tr> <tr><td>48</td><td><a href="https://usenix.org/conference/atc13/atc13-bronson.pdf" rel="nofollow">https://usenix.org/conference/atc13/atc13-bronson.pdf</a></td><td>232</td></tr> <tr><td>49</td><td><a href="https://usenix.org/conference/usenixsecurity17/sec17-antonakakis.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity17/sec17-antonakakis.pdf</a></td><td>230</td></tr> <tr><td>50</td><td><a href="https://usenix.org/system/files/sec23fall-prepub-234-wu-mingshi.pdf" rel="nofollow">https://usenix.org/system/files/sec23fall-prepub-234-wu-mingshi.pdf</a></td><td>228</td></tr> <tr><td>51</td><td><a href="https://usenix.org/system/files/osdi24-shubha.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-shubha.pdf</a></td><td>219</td></tr> <tr><td>52</td><td><a href="https://usenix.org/system/files/osdi24-zhou.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-zhou.pdf</a></td><td>213</td></tr> <tr><td>53</td><td><a href="https://usenix.org/system/files/sec23winter-prepub-107-bouhoula.pdf" rel="nofollow">https://usenix.org/system/files/sec23winter-prepub-107-bouhoula.pdf</a></td><td>208</td></tr> <tr><td>54</td><td><a href="https://usenix.org/system/files/sec21-hoang.pdf" rel="nofollow">https://usenix.org/system/files/sec21-hoang.pdf</a></td><td>205</td></tr> <tr><td>55</td><td><a href="https://usenix.org/conference/woot15/woot15-paper-peles.pdf" rel="nofollow">https://usenix.org/conference/woot15/woot15-paper-peles.pdf</a></td><td>200</td></tr> <tr><td>56</td><td><a href="https://usenix.org/event/osdi10/tech/full_papers/Peng.pdf" rel="nofollow">https://usenix.org/event/osdi10/tech/full_papers/Peng.pdf</a></td><td>198</td></tr> <tr><td>57</td><td><a href="https://usenix.org/system/files/nsdi24-jiang-ziheng.pdf" rel="nofollow">https://usenix.org/system/files/nsdi24-jiang-ziheng.pdf</a></td><td>195</td></tr> <tr><td>58</td><td><a href="https://usenix.org/system/files/osdi24-fu.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-fu.pdf</a></td><td>191</td></tr> <tr><td>59</td><td><a href="https://usenix.org/system/files/sec23fall-prepub-285_kim-jiwon.pdf" rel="nofollow">https://usenix.org/system/files/sec23fall-prepub-285_kim-jiwon.pdf</a></td><td>188</td></tr><tr><td>60</td><td><a href="https://usenix.org/event/atc10/tech/full_papers/Carroll.pdf" rel="nofollow">https://usenix.org/event/atc10/tech/full_papers/Carroll.pdf</a></td><td>184</td></tr> <tr><td>61</td><td><a href="https://usenix.org/system/files/nsdi24-hu.pdf" rel="nofollow">https://usenix.org/system/files/nsdi24-hu.pdf</a></td><td>183</td></tr> <tr><td>62</td><td><a href="https://usenix.org/system/files/atc24-xiong.pdf" rel="nofollow">https://usenix.org/system/files/atc24-xiong.pdf</a></td><td>180</td></tr> <tr><td>63</td><td><a href="https://usenix.org/system/files/soups2019-busse.pdf" rel="nofollow">https://usenix.org/system/files/soups2019-busse.pdf</a></td><td>178</td></tr> <tr><td>64</td><td><a href="https://usenix.org/events/usenix99/provos/provos.pdf" rel="nofollow">https://usenix.org/events/usenix99/provos/provos.pdf</a></td><td>178</td></tr> <tr><td>65</td><td><a href="https://usenix.org/system/files/sec21-specter-keyforge.pdf" rel="nofollow">https://usenix.org/system/files/sec21-specter-keyforge.pdf</a></td><td>176</td></tr> <tr><td>66</td><td><a href="https://usenix.org/system/files/sec20-bouwman.pdf" rel="nofollow">https://usenix.org/system/files/sec20-bouwman.pdf</a></td><td>176</td></tr> <tr><td>67</td><td><a href="https://usenix.org/system/files/osdi24-agrawal.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-agrawal.pdf</a></td><td>174</td></tr> <tr><td>68</td><td><a href="https://usenix.org/system/files/atc24-ma.pdf" rel="nofollow">https://usenix.org/system/files/atc24-ma.pdf</a></td><td>174</td></tr> <tr><td>69</td><td><a href="https://usenix.org/events/usenix05/tech/general/gray/gray.pdf" rel="nofollow">https://usenix.org/events/usenix05/tech/general/gray/gray.pdf</a></td><td>172</td></tr> <tr><td>70</td><td><a href="https://usenix.org/system/files/nsdi20-paper-agache.pdf" rel="nofollow">https://usenix.org/system/files/nsdi20-paper-agache.pdf</a></td><td>166</td></tr> <tr><td>71</td><td><a href="https://usenix.org/conference/usenixsecurity14/sec14-paper-marczak.pdf" rel="nofollow">https://usenix.org/conference/usenixsecurity14/sec14-paper-marczak.pdf</a></td><td>165</td></tr> <tr><td>72</td><td><a href="https://usenix.org/system/files/sec23winter-prepub-490-jia.pdf" rel="nofollow">https://usenix.org/system/files/sec23winter-prepub-490-jia.pdf</a></td><td>164</td></tr> <tr><td>73</td><td><a href="https://usenix.org/system/files/osdi18-chen.pdf" rel="nofollow">https://usenix.org/system/files/osdi18-chen.pdf</a></td><td>162</td></tr> <tr><td>74</td><td><a href="https://usenix.org/system/files/sec24fall-prepub-1998-bocovich.pdf" rel="nofollow">https://usenix.org/system/files/sec24fall-prepub-1998-bocovich.pdf</a></td><td>162</td></tr> <tr><td>75</td><td><a href="https://usenix.org/system/files/osdi24-ma-haoran.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-ma-haoran.pdf</a></td><td>159</td></tr> <tr><td>76</td><td><a href="https://usenix.org/system/files/osdi18-moritz.pdf" rel="nofollow">https://usenix.org/system/files/osdi18-moritz.pdf</a></td><td>157</td></tr> <tr><td>77</td><td><a href="https://usenix.org/conference/atc17/atc17-hahn.pdf" rel="nofollow">https://usenix.org/conference/atc17/atc17-hahn.pdf</a></td><td>157</td></tr> <tr><td>78</td><td><a href="https://usenix.org/system/files/osdi24-xiang.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-xiang.pdf</a></td><td>156</td></tr> <tr><td>79</td><td><a href="https://usenix.org/conference/hotcloud16/hotcloud16_burns.pdf" rel="nofollow">https://usenix.org/conference/hotcloud16/hotcloud16_burns.pdf</a></td><td>155</td></tr> <tr><td>80</td><td><a href="https://usenix.org/system/files/woot19-paper_ovadia.pdf" rel="nofollow">https://usenix.org/system/files/woot19-paper_ovadia.pdf</a></td><td>155</td></tr> <tr><td>81</td><td><a href="https://usenix.org/events/lisa98/lisa98.pdf" rel="nofollow">https://usenix.org/events/lisa98/lisa98.pdf</a></td><td>155</td></tr> <tr><td>82</td><td><a href="https://usenix.org/system/files/usenixsecurity23-carlini.pdf" rel="nofollow">https://usenix.org/system/files/usenixsecurity23-carlini.pdf</a></td><td>155</td></tr> <tr><td>83</td><td><a href="https://usenix.org/system/files/usenixsecurity23-deng-jiangyi-v-cloak.pdf" rel="nofollow">https://usenix.org/system/files/usenixsecurity23-deng-jiangyi-v-cloak.pdf</a></td><td>152</td></tr> <tr><td>84</td><td><a href="https://usenix.org/system/files/woot19-paper_zhao.pdf" rel="nofollow">https://usenix.org/system/files/woot19-paper_zhao.pdf</a></td><td>151</td></tr> <tr><td>85</td><td><a href="https://usenix.org/conference/fast16/fast16-papers-lu.pdf" rel="nofollow">https://usenix.org/conference/fast16/fast16-papers-lu.pdf</a></td><td>149</td></tr> <tr><td>86</td><td><a href="https://usenix.org/system/files/atc21-chen.pdf" rel="nofollow">https://usenix.org/system/files/atc21-chen.pdf</a></td><td>149</td></tr> <tr><td>87</td><td><a href="https://usenix.org/system/files/fast21-pan.pdf" rel="nofollow">https://usenix.org/system/files/fast21-pan.pdf</a></td><td>148</td></tr> <tr><td>88</td><td><a href="https://usenix.org/event/usenix99/provos/provos.pdf" rel="nofollow">https://usenix.org/event/usenix99/provos/provos.pdf</a></td><td>148</td></tr> <tr><td>89</td><td><a href="https://usenix.org/conference/atc12/atc12-final39.pdf" rel="nofollow">https://usenix.org/conference/atc12/atc12-final39.pdf</a></td><td>146</td></tr> <tr><td>90</td><td><a href="https://usenix.org/conference/osdi14/osdi14-paper-yuan.pdf" rel="nofollow">https://usenix.org/conference/osdi14/osdi14-paper-yuan.pdf</a></td><td>143</td></tr> <tr><td>91</td><td><a href="https://usenix.org/system/files/osdi22-zheng-lianmin.pdf" rel="nofollow">https://usenix.org/system/files/osdi22-zheng-lianmin.pdf</a></td><td>142</td></tr> <tr><td>92</td><td><a href="https://usenix.org/system/files/osdi24-sun-biao.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-sun-biao.pdf</a></td><td>141</td></tr> <tr><td>93</td><td><a href="https://usenix.org/system/files/osdi24-lazarev_1.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-lazarev_1.pdf</a></td><td>141</td></tr> <tr><td>94</td><td><a href="https://usenix.org/system/files/osdi24-leblanc.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-leblanc.pdf</a></td><td>140</td></tr> <tr><td>95</td><td><a href="https://usenix.org/system/files/osdi24-zhong-yinmin.pdf" rel="nofollow">https://usenix.org/system/files/osdi24-zhong-yinmin.pdf</a></td><td>138</td></tr> <tr><td>96</td><td><a href="https://usenix.org/system/files/sec19-reardon.pdf" rel="nofollow">https://usenix.org/system/files/sec19-reardon.pdf</a></td><td>137</td></tr> <tr><td>97</td><td><a href="https://usenix.org/system/files/atc24-yuan.pdf" rel="nofollow">https://usenix.org/system/files/atc24-yuan.pdf</a></td><td>137</td></tr> <tr><td>98</td><td><a href="https://usenix.org/system/files/sec22fall_senol.pdf" rel="nofollow">https://usenix.org/system/files/sec22fall_senol.pdf</a></td><td>135</td></tr> <tr><td>99</td><td><a href="https://usenix.org/system/files/sec24fall-prepub-2205-fang.pdf" rel="nofollow">https://usenix.org/system/files/sec24fall-prepub-2205-fang.pdf</a></td><td>134</td></tr> <tr><td>100</td><td><a href="https://usenix.org/system/files/sec24fall-prepub-1500-yu-zhiyuan.pdf" rel="nofollow">https://usenix.org/system/files/sec24fall-prepub-1500-yu-zhiyuan.pdf</a></td><td>134</td></tr></tbody></table></div></div></div>  </div> </div> </div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">SRE</li>
                                                    <li class="category">Security</li>
                                                    <li class="category">Operating Systems</li>
                                                    <li class="category">Network</li>
                                                    <li class="category">Sysadmin</li>
                                                    <li class="category">Culture</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/consequences-compliance-crowdstrike-outage-19-july-2024"
                    >Consequences of Compliance: The CrowdStrike Outage of 19 July 2024</a>
                </h2>

                                    <time datetime="2024-07-29 00:00:00">
                        2024-07-29 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Laura Nolan</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>The widespread outage that occurred on Friday 19 July as a result of a CrowdStrike configuration push that put Windows machines into a boot loop may well have been the largest digital systems availability incident that the world has ever seen. The event affected airlines, payment systems, hospitals, emergency phone services, and many more. Many people had a very bad day. It is likely some people may have died or suffered lasting harm as a result of the loss of hospital and emergency services capacity. </span></p><p><span>CrowdStrike posted a description of the event a few days after it occurred [1]. CrowdStrike Falcon Sensor is an  EDR (Endpoint Detection and Response) agent, which monitors devices for cybersecurity purposes. An invalid configuration file caused a crash in the CrowdStrike Falcon Sensor code, which runs during the Windows boot process, causing a boot loop. But, as is unfortunately common with such summaries, many questions are left unanswered. In particular, there is no real detail about how CrowdStrike tests changes to their configuration files before they are pushed, how this problem evaded their tests, and there is no discussion of CrowdStrike’s apparent decision to push such changes globally at a single point in time, rather than to use a more progressive rollout mechanism. </span></p><p><span>A more gradual rollout would—of course—potentially increase the period of time that CrowdStrike’s customers might be unprotected from a novel attack. Using canarying or other forms of gradual rollout, it can be difficult to catch subtle regressions without a very long rollout duration (multiple hours at least), but severe issues like this one are generally visible quite quickly, within minutes. It is a tradeoff. A short delay can add a significant degree of reliability. </span></p><p><span>CrowdStrike’s preliminary incident report describes the buggy configuration file as “Rapid Response Content that is designed to respond to the changing threat landscape at operational speed” [1]. Rolling out these changes quickly is a key part of CrowdStrike’s value proposition, and it is normal work for engineers at CrowdStrike. Does CrowdStrike track the speed of such rollouts? Do staff have targets that must be met for getting such updates onto client machines? We may never know the answer to this question, but it would be very interesting to know if staff at CrowdStrike have ever advocated for a more gradual deployment mechanism for these configuration files, and, if so, how that discussion went. </span></p><p><span>Many readers of <em>;login:</em> are likely primarily users of various flavours of Unix and may not be fans of Windows. However, those of us in the Linux world should not consider ourselves immune from this kind of event. As Mark Twain said, “history doesn’t repeat itself, but it often rhymes”. From a broad-strokes technical perspective, what happened on Friday wasn’t entirely different to the DataDog outage from March 2023 [2]. In both cases, an automatic update was pushed globally within a short timeframe, resulting in widespread unavailability of machines, and thus, the services that run on them, with an inability for the affected services to automatically recover themselves without significant intervention by operators. In both cases, it is the inability for services to self-heal that exacerbated the severity of the incident, a pattern which is common to most significant outages.</span></p><p><span>Of course, there are differences, too. Based on their report [2], DataDog seems to have left their “legacy security update channel” (the description of which matches the unattended-upgrade tool [3]) enabled as an oversight, rather than as a conscious decision. CrowdStrike appears to push its configuration updates immediately as a matter of design, and, furthermore, does not give local administrators any control over the timing of application of those configuration updates, and shipping configuration updates quickly is a key part of their value proposition. </span></p><p><span>The pattern of events that CrowdStrike encountered—a client crashing due to a bad configuration—is not new. I have seen this pattern play out, and I expect most other seasoned software engineers to have seen it. Andy Ellis has described how Akamai encountered a similar issue 20 years ago, and how they solved it with a technique they called crash rejection [9]. Of course, unlike many other professions, there is no agreed-upon body of knowledge for software engineers—we learn on the job, or from stories that other engineers tell us. If there were a standard body of knowledge, crash rejection should certainly be part of it. Lacking that standardised body of knowledge, it becomes difficult to blame engineers for failing to spot the potential for coordinated client failure, without the possibility of recovery.</span></p><p><strong>Good Intentions </strong></p><p><strong> </strong>Of course, nobody at CrowdStrike intended this incident to occur. Nobody goes to work to write code that will make 8.5 million Windows machines inoperative [4], or to push an invalid configuration. People go to work and in general, they do their jobs as well as they can with the time and the resources and the knowledge that they have. I am sure that this is true of the engineers at CrowdStrike. But do those engineers have sufficient support—access to appropriate specialist expertise, dedicated testers, sufficient time to implement things such as static analysis and fuzz testing—to do the quality of work necessary to run their system well? It would not surprise me if CrowdStrike’s issue tracker held several items prior to July 19th that later appeared in their preliminary incident review as planned action items [1]. </p><p><span>Charles Perrow’s incredibly influential book <em>Normal Accidents</em> [5] is 40 years old today, but the arguments Perrow makes remain relevant. Most people recall that Perrow argues that perfect reliability in complex systems is impossible, because such systems will occasionally exhibit unintended and surprising behaviour. However, Perrow had another thesis: that most accidents are not unpredictable N<em>ormal Accidents</em>. Most serious accidents are a result of some combination of mismanagement, inadequate resourcing, and production pressure. Examples are numerous but include the Boeing 737 Max crashes [6], the Grenfell Tower fire [7], and the Deepwater Horizon blowout [8].</span></p><p><span>So was this a normal accident or a standard organisational accident? Software is a challenging domain for reliability. We can’t see our software’s internal state directly—we only have the observability that we have the foresight and the time to build in. Software has a lot of dependencies. The state of a digital system can change incredibly fast, before human operators have any hope of understanding and reacting. It’s also a young domain, and we are still building the techniques that allow us to run digital systems more reliably, and, as mentioned previously, we have not yet built a core body of knowledge that software engineers should possess. But still, many software outages (and many security issues) are avoidable and preventable, with sufficient investment, good management, and appropriate expertise—although sustaining these conditions over time, in the face of commercial pressures, is an enormous organisation challenge, at which many organisations have failed.</span></p><p><span>Regardless of whether the specific incident on July 19th was preventable or a Normal Accident, digital systems are and will remain complex systems with the potential for Normal Accidents. As organisations, and as societies, it would be wise to consider this when designing our systems. Any piece of software (or hardware) is potentially a failure domain. There is value in diversity. At a former employer, we used multiple kinds of routers in our networks, running with different chips, in order to ensure that a router-specific issue could not disable the entire network. </span></p><p><strong>Mono-culture</strong></p><p><strong> </strong>A significant part of the issue on July 19th was that so many organisations in particular sectors, such as aviation and healthcare, were reliant on a single software stack. At the organisational level, it certainly adds cost and effort to run two sets of tools, so that may not make sense for some organisations. But does it make sense for all hospitals in a region to use the same software? Or does this create unnecessary risk, because neighbouring hospitals cannot assist in the event of system downtime? Similar arguments might be made with respect to other key systems, such as emergency telephone services: these seem critical enough to maintain fully-redundant backups. There are very real tradeoffs to be made here between costs and human lives and health.  </p><p><span>Another aspect of the failure is that organisations can be remarkably resilient and can often do quite a bit without their usual IT systems. European budget airline Ryanair, for example, used paper manifests to board their planes. Organisations that prepare for these eventualities will be better able to cope when an outage strikes. The best way to understand the impact of the loss of IT systems and what would be needed to cope in their absence is to do drills, in as close to real-world conditions as possible. Drills train your staff in processes to follow in an outage, and, even more crucially, helps your organisation to find problems and gaps and ways to improve emergency plans. This, of course, has a cost in staff time, and potentially a cost in ongoing work, such as keeping printouts of essential data up-to-date.</span></p><p><span>Cutting staff to the bone, however, reduces resilience. A viral social media post on July 19th featured the plight of a solo DevOps engineer tasked with recovering 2000 servers affected by the issue as quickly as possible. Whether a real story or not, it is certainly the case that having extra colleagues to call upon to resolve major problems is extremely helpful in a crisis. Organisations that choose to run very lean on staff run the risk of extending outages. This is a subtle effect of layoffs that does not become apparent until a crisis occurs. </span></p><p><span>One thing that is not likely to be the answer to fixing software availability issues is the knee-jerk creation of regulation. Consider the example of Crowdstrike—its major selling point is that it provides a turn-key solution for customers to use to comply with myriad certification and compliance requirements</span>—which can be quite burdensome for organisations. The challenge of complying with certification requirements has effectively created a captive market for CrowdStrike and a few other competitors. This has systemic effects. Firstly, it creates centralisation, meaning that one large service having a problem creates many issues downstream. Secondly, it adds complexity to systems because of the addition of agents. This increases the potential for outages, and, paradoxically, even adds some new security risks. Think of the SolarWinds supply-chain attack. </p><p><span>Once an organisation has met a compliance requirement by installing an EDR solution, they may be less likely to consider solutions which do not add so much complexity and risk, such as design of networks into multiple zones, management of user permissions in line with the principle of least privilege, and the use of multi-factor authentication and zero-trust. The issue is that it is much more work to demonstrate the correct implementation of such organisation-specific interventions than it is to purchase and install a turnkey solution which regulators will be satisfied with.</span></p><p><em>Thanks to </em><em>Eric Dobbs, </em><em>Josh Kaderlan, and </em><em>Alan Kraft</em><em> for their thoughtful comments and review.</em></p><div></div></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] CrowdStrike (204 July 2024). Preliminary Post Incident Review. <a href="https://www.crowdstrike.com/falcon-content-update-remediation-and-guidance-hub/" target="_blank" title="https://www.crowdstrike.com/falcon-content-update-remediation-and-guidance-hub/" rel="nofollow">https://www.crowdstrike.com/falcon-content-update-remediation-and-guidance-hub/</a></p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Lê-Quôc, Alexis (16 May 2023). 2023-03-08 Incident: Infrastructure connectivity issue affecting multiple regions. DataDog Engineering Blog. Accessed 29/07/2024:<a href="//www.datadoghq.com/blog/2023-03-08-multiregion-infrastructure-connectivity-issue/" target="_blank" title="//www.datadoghq.com/blog/2023-03-08-multiregion-infrastructure-connectivity-issue/" rel="nofollow">&nbsp;https://www.datadoghq.com/blog/2023-03-08-multiregion-infrastructure-connectivity-issue/</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] unattended-upgrade man page. <a href="https://www.unix.com/man-page/linux/8/unattended-upgrade/" target="_blank" title="https://www.unix.com/man-page/linux/8/unattended-upgrade/" rel="nofollow">https://www.unix.com/man-page/linux/8/unattended-upgrade/</a></p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Tidy, Joe (20 July 2024). CrowdStrike IT outage affected 8.5 million Windows devices, Microsoft says. BBC. <a href="https://www.bbc.com/news/articles/cpe3zgznwjno" target="_blank" title="https://www.bbc.com/news/articles/cpe3zgznwjno" rel="nofollow">https://www.bbc.com/news/articles/cpe3zgznwjno</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Perrow, Charles (1999). Normal Accidents: Living With High-Risk Technologies (Princeton University Press).&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Robison, Peter (2021). Flying Blind: The 737 Max Tragedy and the Fall of Boeing (Doubleday).</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Apps, Peter (2022). Show Me the Bodies: How We Let Grenfell Happen (Oneworld).</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Hopkins, Andrew (2012). Disastrous Decisions: The Human and Organisational Causes of the Gulf of Mexico Blowout (CCH).</p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] Andy Ellis (19 July 2024). Twitter post on the topic of crash rejection. h<a href="//x.com/csoandy/status/1814252032884146636 " target="_blank" title="//x.com/csoandy/status/1814252032884146636 " rel="nofollow">ttps://x.com/csoandy/status/1814252032884146636&nbsp;</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">SRE</li>
                                                    <li class="category">Sysadmin</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/fuzzing-busybox-leveraging-llm-and-crash-reuse-embedded-bug-unearthing"
                    >Fuzzing BusyBox: Leveraging LLM and Crash Reuse for Embedded Bug Unearthing</a>
                </h2>

                                    <time datetime="2024-07-16 00:00:00">
                        2024-07-16 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Asmita</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><span>We explored two techniques for identifying vulnerabilities in embedded software. First, we used a Large Language Model (LLM) to generate initial seeds for fuzz testing, enhancing efficiency. Second, we reused crash data from previous fuzzing sessions to streamline testing on similar binaries. These methods improved coverage and crash detection, making fuzz testing faster and more effective than traditional approaches.</span></span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><span>There has been a significant increase in the number of IoT (Internet of Things) devices, and there has also been a resulting increase in the number of cyber attacks on these devices. Embedded devices are the core part of the IoT ecosystem with firmware being the main logic governing most aspects of a system’s behavior. Vulnerabilities in the firmware can indirectly impact the whole ecosystem. Firmware can be broadly classified into three categories: those based on modified generic operating systems (OS) like Linux, those based on real-time (RTOS) or custom operating systems, and those that do not have a formal operating system (non-OS or bare-metal). Each of these categories poses distinct challenges when it comes to security assessment [1]  and often requires different approaches. To that end, we focus our attention in this work on the largest subclass of OS-based firmware: embedded Linux. </span></span></p><p><span><span>As a critical set of commonly used utility programs in embedded Linux, BusyBox is a component of particular interest. It provides over 300 common Unix utilities within a single lightweight and compact executable, making it indispensable for resource-constrained Linux-based embedded devices. There are many IoT and OT (Operational Technology) devices running BusyBox, including remote terminal units (RTUs), human-machine interfaces (HMIs), and many others that are running on Linux. However, despite its many advantages, it can also present considerable risk, as it is often used with elevated privileges and provides multiple utilities that handle user input, which attackers have been able to exploit. 14 vulnerabilities were found in Busybox in 2021, some of which had the potential of remote code execution or denial of service attacks [2]. Despite this, in our investigation we have identified several real-world products that continue to use older versions of BusyBox that contain known vulnerabilities.</span></span></p><p><span>Fuzzing is a well-recognized software testing technique for uncovering vulnerabilities, but its effectiveness varies depending on the chosen target (i.e. firmware/software binary under test), each of which can present unique challenges. In this work, we propose and implement two techniques to assist software testing for embedded firmware. First, we leverage LLM-based seed generation, in which we utilize commercial large language models (LLMs) to generate the initial input seeds for mutation-based, coverage-guided fuzzing. In doing so, we take advantage of LLMs’ inherent capability to generate high-quality structured inputs that adhere to the input grammar of a target. Second, we employ a crash reuse strategy to identify crashes across similar binaries present in different embedded devices. This strategy is based on the intuition that an input that triggers a crashing vulnerability on one variant of a program is likely to trigger a crash on a different variant. This allows us to more efficiently determine if the same vulnerability is present on multiple program variants without performing fuzzing, thus saving significant time. When we mention a variant of a software component or similar binaries, we are referring to identical software components with varying version numbers or architectures or compiler optimization, or any custom modification by developers.</span></p><p><span><span><span>This research was done in collaboration with NetRise’s [3] firmware security division. We sourced BusyBox ELFs from real-world embedded products collected from the company’s proprietary firmware dataset, which had been collected using in-house extraction tools. Figure 1 shows the overall pipeline of the proposed work where we collect crashes using LLM-based seed generation technique, and then reuse the collected crashes to test the new variant of a similar target.</span></span></span></p><p><span> </span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/overview.png?itok=g71gMIyM" width="1440" height="785" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1 : Our work pipeline</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Leveraging LLM for initial seed generation</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><span>We evaluated the first technique, LLM-based seed generation, by comparing control runs that used randomly generated initial seeds, to experimental runs that used initial seeds generated using OpenAI’s GPT-4 LLM API. We observed a significant increase in crashes obtained when using LLM-generated seeds, demonstrating the potential for improving vulnerability detection. As a proof-of-concept, we demonstrate these techniques with AFL++ on BusyBox applets ‘awk’, ‘dc’, ‘man’, and ‘ash’.</span></span></p><p><span><span>There are 2 scenarios under which initial seeds need to be generated: when the target input format is well-defined and/or standardized, and when the input format is loosely-defined or unknown. When the input format is well-defined, as would be the case for well-known programs like some BusyBox applets, we reason that LLM should not require additional training, as it already possesses knowledge of the expected input format through its initial training on the internet. This can also be determined empirically. However, when the input format of the target is ill-defined or unknown, as would be the case for custom communication protocols, LLM requires fine-tuning. In this scenario, LLM needs to be initially trained with known samples to develop an understanding of the expected input format. In the case of the BusyBox applets, we reason that GPT-4 should already be aware of the input format given the applet’s popularity. Hence, we did not apply fine-tuning. We provided the following prompt to guide the seed generation process for awk:</span></span></p><p><span><span>"</span><span>role</span><span>": "system", "</span><span>content</span><span>": "You are the initial seed generator for a fuzzer that has to fuzz BusyBox awk applet. In response only provide the list of awk scripts"</span><span><br /></span><span>"</span><span>role</span><span>": "user", "</span><span>content</span><span>": "Generate initial seed to fuzz BusyBox awk applet" </span></span></p><p><span><span>The model responded with a list of commands relevant to the BusyBox awk applet as shown in Figure 2. These commands were then saved as .<strong>awk</strong> scripts, which were subsequently integrated into the input corpus.</span><span> </span><span>The generated corpus via LLM served as the set of initial seeds for the fuzzing process. We used <strong>afl-cmin</strong> to minimize the input corpus before sending it to the fuzzer, which filters the LLM-generated input corpus to include only the seeds that are useful for fuzzing. </span></span></p><p><span><span>We observed that more crashes were identified during fuzzing when the initial seeds were generated by LLM compared to the ones with random seeds. Moreover, a similar pattern was observed in the case of the number of edges found during the fuzzing of each of the targets. Refer to our paper [4] for more insights about the result. Figure 3 shows a Venn diagram depicting the number of unique crashes found in each case and the number of crashes common in both cases. This emphasizes the importance of discovering a more significant number of crashes. When there are more crashes to work with, there are more opportunities to discover different failing execution paths, thereby increasing the likelihood of uncovering vulnerabilities. It</span><span> </span><span>underscores this by revealing that more unique crashes were identified when utilizing LLM-generated initial seeds. AFL-Triage [5] was used to identify the unique crashes.</span></span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/screenshot_2024-06-29_at_8.53.33_am.png?itok=7yPtt1LP" width="1184" height="600" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2 : Generated list of commands w.r.t BusyBox ‘awk’ applet using LLM </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/screenshot_2024-06-29_at_9.09.51_am.png?itok=PGk1kVbN" width="940" height="640" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3 : No. of unique crashes  with vs without LLM based initial input seeds. Target : Network controller, Network switch, storage array controller, firewall</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Crash Reuse</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><span>Having completed our fuzz testing runs on individual BusyBox targets (i.e. on different versions/variants of BusyBox binaries), we turn our attention to triaging crashes and investigating the potential utility of crash reuse. To recap, we have hypothesized that we can leverage known crashing inputs for a given target to quickly determine if variants of that target contain a similar vulnerability or bug. <em>Crash Reuse</em> provides advantages including efficiency, and performing blackbox testing. Initially testing the new variant of the target against the consolidated crash database offers the potential for significant time and resource savings. By capitalizing on the crashes identified during previous fuzz testing on similar targets, we can leverage the resources previously expended in fuzzing and accelerate the fuzzer’s coverage exploration by including it in future seeds. Hence, we can potentially identify previously discovered crashes in the new variant without extensive fuzz testing. Moreover, This technique is highly beneficial when conducting blackbox testing on new variants of a previously tested target. It is particularly advantageous in scenarios where the target utilizes accessible or open-source software components, even if further details are unavailable. By fuzzing open-source variants, we can gather crashing inputs to use as high-quality seeds that are likely to identify duplicate vulnerabilities. This is preferable to engaging in resource-intensive binary-only black-box fuzzing, which can be extremely difficult depending on the complexity of the system under test.</span></span></p><p><span><span>We actively curated a database of crashes obtained from previously fuzzed software components. Then, when we encounter variants of these software components in the future, we leverage the collected crashes to identify potential issues in the new variant under test without fuzzing. This provides us with a rapid initial assessment of the new target, which can later undergo more thorough fuzzing for in-depth inspection. This technique is applicable to any target whose variant has undergone previous fuzzing, and for which we possess a corresponding collection of crashes. After we had amassed a substantial number of crashes from fuzzed BusyBox targets, our total collection amounted to 4540 crashes that likely map to a much smaller place in the binary where the crash happens. Subsequently, we subjected the latest BusyBox version (v1.36.1 at the time of experiment) to testing against all these pre-existing crashes. This endeavor discovered 97 crashes in the latest BusyBox, of which 19 were unique. Later, we conducted traditional fuzzing on the latest BusyBox using AFL++ QEMU mode, with initial seeds generated by LLM over 10 hours. This approach yielded 20 crashes, of which eight were unique. Remarkably, five of these eight unique crashes were also identified using the crash reuse technique. Figure 4</span><span> </span><span>presents a graphical comparison of the number of unique crashes discovered using the crash reuse technique versus traditional fuzzing, as well as the common crashes between the two methods. These results underscore the potential utility of crash reuse in software testing. Hence, it can reduce substantial time and resource demands, and is a valuable tool for black box fuzzing when a comprehensive crash database is available.</span></span></p><p><span><span>Additionally, it is essential to note that not all crashes indicate software bugs. Crashes can occur for various reasons, including invalid inputs, false positives, unreachable code, execution environment factors, platform-specific issues, and other non-bug-related causes. Reaching conclusive determinations often involves meticulous manual triaging, which can be time-consuming and intricate. As such, we limited our scope to identifying crashes, with triaging performed only on a subset of crashes found in the latest BusyBox version, more detail about crash analysis can be found in the paper [4]. However, as previously discussed, the quantity of crashes is a vital metric in fuzzing. A higher number of unique crashes equates to a more extensive array of test scenarios to explore during testing. Consequently, this increases the likelihood of identifying potential software vulnerabilities or bugs.</span></span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/screenshot_2024-06-29_at_9.10.10_am.png?itok=K_pHav-W" width="536" height="438" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4 : Comparison of number of unique crashes in the latest BusyBox using crash reuse technique vs 10-hours of fuzzing.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Applicability of proposed techniques</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>The LLM-based technique for generating initial seeds plays a supportive role in the fuzzing process, contributing quality and diverse seeds that enhance fuzzing performance. However, it is crucial to note that this technique alone is not the sole factor influencing the overall outcome. Various associated factors, contingent upon the specific target, must be considered. The effectiveness is contingent upon the target type and the extent to which the initially provided diverse inputs contribute to code coverage. The primary function of LLM in this proposed technique is to assist in producing high-quality and diversified initial seeds, thereby potentially enhancing fuzzing performance. The seed generation using LLM requires initial manual intervention to validate if the generated seeds align with the target’s requirements. In the case of a new target initially unknown to LLM, model training is essential for the target-specific seed format. However, this represents an initial, one-time effort; once the model learns the required seed format, it expedites the generation of diverse seeds suitable as potential initial seeds for fuzzing. Thus, we can leverage the knowledge base of LLM models, or train these models according to different target requirements. Therefore, this technique is not restricted to the BusyBox and can be adapted for use with different targets.</span></p><p><span>Similarly, the crash reuse technique proposed can be extended to various software components across different targets. The technique isn’t limited to a particular target but applies universally. It can be employed in any scenario where we have previously gathered crash data by fuzzing a target and aim to test the variant of that target by reusing those crashes. The primary goal is to convey that the crash reuse technique could be beneficial for the initial screening of a new variant of a software component without spending hours on fuzzing. However, this technique may not uncover all the vulnerabilities requiring fuzzing for a thorough analysis.</span></p><p><span> </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusion</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In our pursuit to enhance existing software testing methodologies, we emphasize the significance of our proposed techniques, particularly within the context of embedded systems. Firmware in embedded systems often consists of numerous third-party software components with custom implementations and unique input types, making it predominantly a black-box testing scenario. The techniques introduced in this work, namely leveraging LLM for initial seed generation and crash reuse, have exhibited promising outcomes that can significantly aid software testing efforts. While these techniques can be adapted for various targets, we have used them to analyze BusyBox for the proof of concept.</span></p><p><span>Nevertheless, it is essential to acknowledge certain limitations and challenges associated with these approaches. Utilizing LLM for initial seed generation may necessitate a significant initial effort, mainly when dealing with different targets, especially in the complex domain of embedded systems where a wide array of hardware protocols and custom input patterns are encountered. Furthermore, while the crash reuse technique represents a valuable first pass phase, it may not consistently identify all bugs, especially zero-day vulnerabilities. Hence, a traditional fuzzing technique remains a necessary complement for comprehensive testing. The crash reuse method primarily assists in determining whether previously identified crashes are applicable to a new target but does not guarantee the discovery of all potential bugs. However, while there are particular challenges and limitations, substantial research potential exists for harnessing these techniques to enhance and assist software testing endeavors. These approaches hold promise for improving the efficiency and effectiveness of testing procedures, particularly in the context of embedded systems and firmware analysis.</span></p><p><span> </span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Acknowledgements</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><span>We would like to acknowledge the NetRise[3] team for providing us with a real-world embedded firmware database and cloud resources to perform a part of these experiments. We would also like to thank NSF CHEST for funding this project </span><span>(Project # 1916741 industry funding)</span><span>.</span></span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Marius Muench, Jan Stijohann, Frank Kargl, Aurelien Francillon, and Davide Balzarotti. What you corrupt is not what you crash: Challenges in fuzzing embedded devices. In Proceedings 2018 Network and Distributed System Security Symposium, San Diego, CA, 2018. Internet Society.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>&nbsp;[2] Lucian Constantin. BusyBox flaws highlight need for consistent IoT updates, September 2021.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] netrise.io. Netrise | firmware security.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>&nbsp;[4] Asmita, Yaroslav Oliinyk, Michael Scott, Ryan Tsang, Chongzhou Fang, and Houman Homayoun. Fuzzing BusyBox: Leveraging LLM and Crash Reuse for Embedded Bug Unearthing. Usenix Security 2024 - <a href="https://www.usenix.org/conference/usenixsecurity24/presentation/asmita">Link</a>&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Grant Hernandez. AFLTriage.&nbsp;</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">IoT</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/choose-one-android-performance-or-security"
                    >Choose One: Android Performance or Security!</a>
                </h2>

                                    <time datetime="2024-07-08 00:00:00">
                        2024-07-08 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Philipp Mao</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong>Security mitigations are crucial to protect Android against the exploitation of memory corruption vulnerabilities. Unfortunately, Android's performance-oriented system architecture undermines these mitigations. We explain how probabilistic mitigations, including Android's newly introduced hardened memory allocator, are affected.</strong></p><p>Large parts of the code running on Android are written in memory unsafe C++, which is prone to memory corruption vulnerabilities. Several publicly known exploits demonstrate how an adversary achieves arbitrary code execution on Android. For example, the Stagefright vulnerabilities[<a href="#reference-1" rel="nofollow">1</a>] allowed a remote attacker to compromise thevictim's phone by sending a crafted MMS message.</p><p>As code complexity increases, memory corruption vulnerabilities remain a common vector for exploitation. While software testing aims to uncover and patch as many bugs as possible, it is inherently incomplete. Mitigations are therefore crucial to protect systems. Depending on the vulnerability, mitigations prohibit exploitation or, at least, increase complexity and cost. Mitigations are not free and come with some performance impact and increase system complexity. Balancing the costs and benefits of mitigations is therefore crucial along with a careful integration into the overall system design. Following best practices, Android compounds several mitigations to maximize protection.</p><p>We discuss how performance optimizations in Android's system design undermine the security guarantees of probabilistic mitigations and the impact on Android security.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Secret-Reliant Memory Corruption Mitigations</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Android deploys several well-known mitigations: Data Execution Prevention (DEP), Stack Canaries, Address Space Layout Randomization (ASLR), and, since Android 11, the hardened memory allocator Scudo. Except for DEP all these mitigations are probabilistic. Probabilistic, because they rely on a secret, which if guessed by the attacker, voids any protection guarantees.</p><p>The stack canary is a 32/64-bit value stored just before the return address on the stack. The value of the stack canary is verified before returning from a function to detect stack-based buffer overflows. If the attacker guesses the value of the canary, the attacker can forge a stack buffer overflow payload that includes the canary and passes the canary verfication.</p><p>ASLR randomizes the memory layout of processes. For an attacker this means that the address of code reuse gadgets will be different across multiple executions of the same program. To successfully mount a code reuse attack an attacker has to guess the address of these gadgets. <br /><br />Scudo is a memory allocator designed to prevent the exploitation of heap-based vulnerabilities. Scudo uses secrets to protect the integrity of allocator metadata and to randomize the layout of allocations. <br /><br />Correctly guessing these secrets is infeasible as the likelihood of each guess is low (ASLR is the most likely to be guessed with a probability of around 1/2<sup>28</sup>) and wrongly guessed secrets will cause the process to crash. The only viable alternative for an attacker is to find additional vulnerabilities that leak the mitigation's secrets. This is possible because the secrets are stored in memory (for ASLR, the secret is stored implicitly in memory as the memory layout itself is the secret). Weaponizing such an additional memory leak vulnerability increases the cost and complexity of developing a functional exploit. Unfortunately, as we will see, one of Android's performance optimizations shares these secrets across most processes, undermining the protection guarantees of the aforementioned mitigations for some attack vectors.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Forking to Reduce App Startup Time</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Android runs on diverse hardware. One challenge for low-end hardware is executing several apps concurrently. Apps run on top of the Dalvik Virtual Machine (DVM) as well as a large amount of Android framework code and resources (around 4GB). Initializing the DVM and loading all of the framework resources requires significant time, increasing both process startup time and memory consumption. As an optimization, Android forks a pre-loaded runtime environment to spawn new app processes.<br /><br />Fork is a system call available on Linux-based systems, including Android, which creates a copy of the calling process. The created child process has the same memory layout and content as its parent. Fork is fast and memory efficient since the child and parent process share the initial underlying memory pages. New app processes are forked from a single Zygote process, which has already initialized the DVM and all the framework resources. App processes forked from the "Zygote" process can directly start loading and executing app-specific code, leveraging the already loaded DVM and framework[<a href="#reference-2" rel="nofollow">2</a>]. With this performance optimization, Android provides "instant" app startup times, even on lower-end hardware.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Consequences of Forking</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>All child processes forked from the same parent process share the same initial memory layout and content. On Android, all app processes fork from the Zygote process. This initial memory, inherited from the Zygote process, contains the secrets of the memory corruption mitigations. For example, both stack canaries and ASLR memory layouts are shared across all app processes. Disclosing the secrets of any of these processes enables an adversary to attack all other processes. This simplifies exploitation as an adversary can leak information from one process to attack another process.<br /><br />For example, a malicious app could exploit other apps to escalate privileges. When such a malicious app attempts to exploit a memory corruption vulnerability in another Zygote-forked process, the malicious app already knows the ASLR layout and stack canary and does not need to leak them.</p><p>While the effects of forking on ASLR and the canary are known<a href="#reference-3" rel="nofollow">[3</a>], it  also affects Android's most recent mitigation, the Scudo memory  allocator.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/scudo_zygote_final.png?itok=tseoKX1X" width="1440" height="858" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Victim and malicious app, both forked from the same Zygote process  share the same ASLR layout and Scudo secrets.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Breaking Scudo</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Scudo is a hardened heap memory allocator designed to increase the cost and complexity of exploiting heap-based memory corruption vulnerabilities in Android userspace programs[<a href="#reference-4" rel="nofollow">4</a>]. The heap is a memory region where programs can dynamically allocate and free memory. The allocator handles allocation (<em>malloc</em>) and deallocation (<em>free</em>) requests and manages the heap memory. The Linux default allocator is optimized for speed and efficiency. On Android, Scudo was designed with security as the main design priority, trading off some performance for security. Today, heap-based vulnerabilities are the most common and also most commonly exploited type of memory corruption vulnerability[<a href="#reference-5" rel="nofollow">5</a>]. To protect Android processes from such vulnerabilities, Scudo is the default allocator since Android 11. Scudo's two key security features are the protection of inline heap metadata and the randomization of allocations.<br /><br />Heap metadata contains information about the heap's state, such as the size of an allocation or the addresses of freed allocations. Due to the heap's dynamic nature, allocators usually store parts of their metadata inline on the heap. A common example of this is the header of an allocation, which contains information about the size of the allocation, usually stored just before the address returned by <em>malloc</em>. Overwriting inline heap metadata is a common approach to exploiting heap vulnerabilities as it confuses the allocator. The default Linux allocator stores most of its metadata inline on the heap, such as pointers to free allocations. For this allocator, the security community has compiled a large compendium of techniques that escalate a heap-bound memory corruption vulnerability into an arbitrary memory write primitive or code execution by manipulating this inline metadata[<a href="#reference-6" rel="nofollow">6</a>]. Scudo protects itself against such attacks by signing inline metadata and verifying the signature before it processes the metadata. If the signature check fails, Scudo safely aborts the process.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/scudo_overflow.png?itok=x4TD1ec6" width="1090" height="252" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">A heap buffer overflow clobbers the chunk header. Scudo detects this when validating the signature and aborts the process.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Many heap vulnerabilities only become exploitable with certain heap layouts (i.e., they require a specific arrangement of adjacent heap objects). For most allocators, the address of allocations is deterministic, and thus attackers can manipulate the heap layout by interacting with the target process. Scudo prevents this by randomizing the address of allocations. In Scudo the same sequence of a allocations/deallocations across multiple runs of the same program will result in a different heap layout each time, preventing attackers from arranging heap objects in a specific layout.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/screenshot_from_2024-07-08_22-22-53.png?itok=lx_GVRBX" width="1440" height="357" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Across multiple runs of the same program, Scudo ensures that the heap layout is randomized.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Both these security measures rely on the confidentiality of secrets: a secret key to sign inline heap metadata and a secret seed to randomize allocations. Both of these Scudo-specific secrets suffer the same fate as the stack canary: They are shared across all Zygote-forked processes. In combination with sharing ASLR, a malicious app can predict the exact address where chunks of other Zygote-forked processes will be allocated. To tamper with inline metadata, the malicious app may simply read out its Scudo secret key and forge valid signatures.<br /><br />As these security measures are compromised by the design of the Android runtime environment, exploiting heap vulnerabilities in Zygote-forked processes protected by Scudo remain feasible. Even targetting the allocator itself becomes feasible, since Scudo assumes that its security measures are effective, it forgoes additional sanity checks.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-subtitle field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Exploiting Scudo</div></div></div><div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>In our work "Exploiting Android's hardened Memory Allocator"[<a href="#reference-7" rel="nofollow">7</a>]  we present two exploitation techniques that coerce Scudo into  allocating a chunk at an attacker's chosen address. We demonstrate that  these techniques are feasible by exploiting the Zygote-forked,  Scudo-protected, system server from an attacker app.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusions: Consider Security while Optimizing for Performance</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Unfortunately, performance optimizations may compromise security mitigations. Mitigations and performance form a tight bond and their interactions need to be carefully considered to avoid any undesirable side effects. By discussing how Android's forking optimization voids secret-based memory corruption mitigations we demonstrate weaknesses in the recently introduced hardened allocator (Scudo). The current Android runtime model of forking the same Zygote process for all apps brings performance but drastically reduces the effectiveness of secret-based mitigations such as stack canaries, ASLR, and Scudo, the new heap allocator.</p><p>Going forward, we urge system researchers to work closely with security researchers, especially when designing new mitigations to avoid the negative interplay between mitigations and optimizations.</p><p> </p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] M. Brand, "Stagefrightened?", <a href="https://googleprojectzero.blogspot.com/2015/09/stagefrightened.html" rel="nofollow">https://googleprojectzero.blogspot.com/2015/09/stagefrightened.html</a>, 2015</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] developer.android.com, "Overview of memory management: Share memory", <a href="https://developer.android.com/topic/performance/memory-overview#SharingRAM" rel="nofollow">https://developer.android.com/topic/performance/memory-overview#SharingRAM</a>, 2024</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] B. Lee L. Lu, T. Wang, T. Kim and W. Lee, "From Zygote to Morula: Fortifying Weakened ASLR on Android", in <em>USENIX Security</em>, 2014</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[5] source.android.com, Scudo, <a href="https://source.android.com/docs/security/test/scudo" rel="nofollow">https://source.android.com/docs/security/test/scudo</a>, 2024</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] M.Miller, "Trends, challenges, and strategic shifts in the software vulnerability mitigation landscape", in <em>BlueHat</em>, 2019</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] anonymous, "Once upon a free()...", <a href="http://phrack.org/issues/57/9.html" rel="nofollow">http://phrack.org/issues/57/9.html</a>, 2001&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] P. Mao, E. Boschun, M. Busch and M. Payer, "Exploiting Android's hardened Memory Allocator", in <em>Woot</em>, 2024</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/data-only-attacks-are-easier-you-think"
                    >Data-Only Attacks Are Easier than You Think</a>
                </h2>

                                    <time datetime="2024-07-01 00:00:00">
                        2024-07-01 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Brian Johannesmeyer</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong>Data-only attacks, those that do not affect a program’s control flow, have long been considered too sophisticated and niche to pose a practical threat. With our research, however, we have built a tool that automatically generates them with surprising ease. We explain how such attacks work, and why our tool, Einstein, calls upon both researchers and vendors alike to rethink their mitigation strategies.</strong></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div></div><div><p>Suppose you are a hacker and you just found a bug that allows you to overwrite data in a victim program. Such a scenario is not uncommon: Microsoft, Google, and Mozilla report that about 70% of their security bugs are indeed such <em>memory safety</em> bugs [<a href="#reference-1" rel="nofollow">1</a>, <a href="#reference-2" rel="nofollow">2</a>, <a href="#reference-3" rel="nofollow">3</a>]. The question then becomes, as a hacker, how do you weaponize this bug into a real exploit?</p><p>In the past, it would have been relatively straightforward: you could, for example, use the bug to conduct a <em>control-flow hijacking attack</em>, overwriting code pointers in the program [<a href="#reference-4" rel="nofollow">4</a>], forcing it to execute your own <em>malicious code</em>. However, due to decades of research (resulting in defenses such as DEP, CFI, CPI, etc.), it is now very difficult to divert a program’s control flow away from the code that it intends to execute. Hence, weaponizing the bug in such a way is now often infeasible in practice.</p><p>In our recently published paper at USENIX Security 2024 [<a href="#reference-5" rel="nofollow">5</a>], we present a practical approach to an entirely different method of exploitation: letting the program execute all of its intended code (e.g., any benign functions, system calls, etc.), but with <em>malicious data</em>. These so-called <em>data-only attacks</em> have been known for quite some time [<a href="#reference-6" rel="nofollow">6</a>], but were assumed to be too application-specific or complex to pose any practical threat [<a href="#reference-7" rel="nofollow">7</a>]. In our work, we show that such assumptions are not justified. In particular, we implemented a scalable and automated solution, Einstein, that demonstrates that building data-only attacks is easy — well within reach of low-effort attackers. In this article, we will discuss the insights that allow Einstein to automatically generate such exploits with surprising ease, and the implications of our findings on software vendors.</p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">An example data-only attack</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Let us first walk through one of the classic data-only attacks described in the literature, which exploits a victim web server </span>[<a href="#reference-6" rel="nofollow">6</a>] (simplified for clarity). At start up, the server reads its configuration file to initialize its data. One such configuration option is the CGI-BIN path, which is the directory it uses to execute external programs. In our example, the server sets its <strong>cgi_bin_path</strong> variable to "<strong>/usr/local/server/cgi-bin</strong>". We assume that the server has a program in its CGI-BIN directory, <strong>sort_script</strong>, that a client can use to sort numbers. Moreover, the server has a memory safety bug that allows a malicious client to overflow some buffer and overwrite, for instance, the contents of the <strong>cgi_bin_path</strong> variable to "<strong>/bin</strong>":</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/bug.jpg?itok=YJG7Zluu" width="1440" height="359" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: An example memory safety bug that allows the attacker to modify the CGI-BIN path.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Of course, the low-level details of the memory safety bug could differ from this (e.g., it could be a use-after-free rather than a buffer overflow), but nonetheless, the question arises: how could an attacker weaponize such a bug? To answer this question, we will show first how the server interacts with a benign client, then how it interacts with a malicious client:</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/example.jpg?itok=k2Wg4kOt" width="1440" height="493" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: An example data-only attack that corrupts a server’s CGI-BIN path to execute arbitrary code.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>After the server initializes (Fig. 2a), it begins processing requests. A benign client interacts with it as follows (Fig. 2b):</p><ul><li>➊ The client sends a “<strong>POST sort-script</strong>” request with the unsorted numbers “<strong>2 1 3</strong>” in the request body.</li><li>➋ The server concatenates the CGI-BIN path and the request’s path to determine the program to be executed, “<strong>/usr/local/server/cgi-bin/sort-script</strong>”.</li><li>➌ The server executes the program, i.e., the sort script, and passes in  “<strong>2 1 3</strong>” as its input. It does so by invoking the <strong>execve</strong> system call, which instructs the operating system to run the script on behalf of the server.</li><li>➍ The script sorts the numbers and outputs “<strong>1 2 3</strong>”, which the server forwards to the client in its HTTP response.</li></ul><p>Let us now sketch how a malicious client could exploit this (Fig. 2c):</p><ul><li>➎ The client exploits the bug to set the <strong>cgi_bin_path</strong> to the string “<strong>/bin</strong>” (Fig. 1).</li><li>➏ The client sends a “<strong>POST /sh</strong>” request with “<strong>touch /tmp/attacker-was-here</strong>” in the request body.</li><li>➐ The server concatenates the CGI-BIN path and the request’s path to determine the program to be executed,  “<strong>/bin/sh</strong>”.</li><li>➑ The server executes the program, i.e., the system shell, and passes in “<strong>touch /tmp/attacker-was-here</strong>” as its input. It does so by invoking the <strong>execve</strong> system call, which instructs the operating system to run the shell on behalf of the server.</li><li>➒ The shell creates the file <strong>/tmp/attacker-was-here</strong>.</li></ul></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-subtitle field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">There are two important takeaways here.</div></div></div><div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>First, the victim server does not execute any <em>malicious code</em> provided by the client; all harmful actions are triggered by <em>malicious data</em>. The attack effectively modifies <em>only</em> the arguments of the <strong>execve</strong> syscall. Other than that, the benign and malicious <em>executions</em> are equivalent — when handling a request, the victim server performs the same steps, and executes the same functions, albeit with different arguments.</p><p>Second, this attack is very powerful, as it allows the attacker to execute arbitrary programs on the victim machine. In our example, the client only creates the file <strong>/tmp/attacker-was-here</strong>, but any shell command is possible, e.g., to install a malicious program or to exfiltrate data.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Why data-only attacks are considered difficult</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Despite the discovery of data-only attacks almost two decades ago, conventional wisdom says they rarely pose a practical threat, either because they are too application-specific or too complex.</span></p><p><span><strong>Application-specific</strong>. As pointed out by the authors of the example attack, building such an attack “require[s] sophisticated knowledge about program semantics”. In other words, an attacker has to become so familiar with the server’s inner-workings — either through reverse-engineering its code, or studying its protocols, etc. — that they know that out of all the program’s data, the <strong>cgi_bin_path</strong> variable specifically is security-critical, and that a <strong>POST</strong> request that is malformed in a very specific way can exploit it. In all likelihood, this kind of labor-intensive, application-specific analysis is prohibitively expensive, and hence, according to conventional wisdom, such data-only attacks are too niche to pose a practical threat.</span></p><p><span><strong>Complex</strong>. Recent approaches to building data-only attacks foray into complex territory, under the assumption that simpler attacks — such as the example attack — are not generally at reach. In particular, they assume the need either to solve complex data-flow constraints using heavyweight analyses, or to deviate the victim program away from the code it intends to execute to circumvent a variety of defenses. Several approaches even go so far as to construct highly complicated, Turing-complete machines — something real-world attackers rarely need.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-subtitle field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">In our work, we show that these assumptions are all false:</div></div></div><div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Exploitation requires neither extensive knowledge of the program semantics, nor the solving of complex data-flow constraints, nor the diversion of the control flow in a complicated (or even any) way.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Einstein: “As simple as possible, but not simpler”</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Inspired by the quote attributed to Albert Einstein, we present a simple (but not too simple) data-only attack exploitation pipeline, named Einstein, that builds attacks with surprising ease. It generates data-only attacks using an application-agnostic technique, proving that such attacks are well within reach of low-effort attackers.</span></p><p><span><strong>Application-agnostic</strong>. Rather than attempting to understand application-specific semantics (e.g., the corner cases of the HTTP protocol), Einstein targets a universal interface used by any program to communicate with the operating system kernel: its syscalls. In particular, we track the data that ends up in syscall arguments, determining whether an attacker can corrupt them to e.g., execute arbitrary code via <strong>execve</strong> or modify files in the filesystem via <strong>write</strong>.</span></p><p><span><strong>Simple</strong>. Moreover, Einstein abstracts away unnecessary complexities and, instead, targets the exploits that are not only the simplest to identify, but also the most promising for an attacker. In particular, Einstein automatically generates exploits for the security-sensitive syscalls along a program’s (already valid) runtime path, and whose arguments are (simply) copied verbatim from attacker-controllable data. As detailed later, this simple approach can automatically generate a surprisingly large number of practical data-only exploits in popular real-world programs.</span></p><h3><span>How Einstein builds the example attack</span></h3><p><span>To explain how Einstein works, we walk through each step of how it builds the example attack and how it crafts the arguments of a security sensitive system call. We assume that the attacker has access to a program that is equivalent to the one deployed by their prospective victim, so they can run the server locally for analysis. Einstein takes the victim program as input, and operates in two stages: first, it generates <em>candidate exploits</em>; and second, it confirms whether each candidate exploit is indeed a <em>working exploit</em>. For an explanation of the finer points of the design beyond the scope of this example — e.g., how Einstein tracks unbounded data, chains together multiple syscalls, etc. — please refer to our paper </span>[<a href="#reference-5" rel="nofollow">5</a>].</p><p><strong>Candidate exploit generation</strong>. To generate candidate exploits, Einstein tracks all attacker-corruptible data at runtime, determining which can influence the arguments of security-sensitive syscalls. To facilitate this, we first start the server with Einstein’s binary-level instrumentation (Fig. 3a, ➊). The instrumentation adds support for dynamic taint analysis, which allows us to track any “tainted” program data at runtime [<a href="#reference-8" rel="nofollow">8</a>]. The server starts up, initializes its <strong>cgi_bin_path</strong>, and starts waiting for requests. Einstein models an attacker exploiting the memory safety bug by uniquely tainting any data that it could potentially corrupt, e.g., the string “<strong>/usr/local/server/cgi-bin</strong>”, but also all other data within reach of it. Additionally, we record the tainted data in a memory snapshot (➋).</p><p><span>Next, Einstein continues executing the program and tracks how the tainted data propagates throughout the program’s execution as the server handles a workload consisting of benign requests (➌). For instance, it sends the “<strong>POST /sort-script</strong>” request from Fig. 2b. Then, while handling the request, the server passes the tainted string as an argument to the <strong>execve</strong> syscall. Einstein identifies this flow of attacker-controllable data into a security-sensitive syscall, and records information about it, such as the arguments and their taintedness (➍).</span></p><p><span>Then, Einstein determines that <strong>execve</strong>’s <strong>pathname</strong> and <strong>argv</strong> parameters are not only tainted with an identifier that corresponds to <strong>cgi_bin_path</strong>, but they are in fact identical to <strong>cgi_bin_path</strong>. We refer to this kind of (very) straightforward data flow as an <em>identity data flow</em>. Einstein builds a candidate exploit for the identity data flow by generating <em>(address, value)</em> pairs that specify that the memory write bug could exploit the <strong>execve</strong> by overwriting the <strong>cgi_bin_path</strong> from "<strong>/usr/local/server/cgi-bin</strong>" to "<strong>/bin</strong>" (➎).</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/identification1.jpg?itok=L-j-_Pik" width="1440" height="664" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3a: First, Einstein generates a candidate exploit.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><strong>Exploit confirmation</strong>. Even though we have identified an identity data flow from attacker data into a syscall argument, we are not guaranteed that it is necessarily exploitable. For example, before executing the file, the server may double-check that it is within some preset, hard-coded directory, thereby mitigating the vulnerability. Hence, we confirm whether each candidate exploit is indeed a working exploit.</span></p><p><span>To confirm the exploit, we first restart the server (Fig. 3b, ➏). Then, at the point where an attacker may exploit the memory write bug, Einstein overwrites the data that is specified by the candidate exploit, changing <strong>cgi_bin_path</strong> to "<strong>/bin</strong>" (➐). Next, we send a workload to exploit the gadget — in this case, a “<strong>POST /sh</strong>” request with a shell command to create a file (➑). Finally, Einstein confirms that the file is indeed created, thereby confirming that the candidate exploit is indeed a working exploit (➒).</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/identification2.jpg?itok=SYlorhbD" width="1440" height="446" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3b: Second, Einstein confirms the candidate exploit to be a working exploit.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h3>Evaluation</h3><p><span>We have seen how Einstein can automatically build the example attack from almost two decades ago. Now, let us see how it performs against popular servers today. Although we follow previous work by targeting server applications, we note that other types of applications (e.g., those with more limited user-input interaction and few obviously dangerous syscalls) may well be at risk.</span></p><p><span>We target the web servers <strong>httpd</strong>, <strong>lighttpd</strong>, and <strong>nginx</strong>; and the database servers <strong>postgres</strong> and <strong>redis</strong> —  all of which have been shown to be at risk of weaponizable memory write bugs. To generate workloads for the target servers, we use their test suites. Moreover, because <strong>nginx</strong> is a common target for exploitation case studies, we confirm the candidate exploits that Einstein generates for <strong>nginx</strong>.</span></p><p><span>We first refer to Table 1, which presents the number of attacker-tainted syscalls per target program, and the percentage of those that have an identity data flow from attacker data. We observe that an attacker may corrupt many security-sensitive syscall arguments, and (with the exception of <strong>postgres</strong>) the high rate of identity flows (84–98%) allows us to generate candidate exploits for the vast majority of them. We refer to our paper [<a href="#reference-5" rel="nofollow">5</a>] for a full breakdown per syscall argument. Despite the test suites generating relatively low code coverage (27–49%), Einstein still uncovers many security-sensitive issues. Further work into increasing coverage would undoubtedly yield even more dire results.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table>   <tr>     <th>Target program</th>     <th>Security-sensitive syscalls with tainted arguments (% with an identity data flow from attacker data)</th>     <th>Code coverage</th>   </tr>   <tr>     <td>httpd</td>     <td>1834 (97%)</td>     <td>27.3%</td>   </tr>   <tr>     <td>lighttpd</td>     <td>92 (98%)</td>     <td>27.8%</td>   </tr>   <tr>     <td>nginx</td>     <td>1623 (82%)</td>     <td>49.1%</td>   </tr>   <tr>     <td>postgres</td>     <td>2105 (27%)</td>     <td>46.5%</td>   </tr>   <tr>     <td>redis</td>     <td>218 (84%)</td>     <td>33.6%</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1: Number of attacker-tainted syscalls per target program.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Next, we refer to Table 2, which presents the number of confirmed exploits for <strong>nginx</strong>. We observe that the exploits offer many primitives to attacker: a vulnerable <strong>execve</strong> gives us a Code-Execution primitive, vulnerable file-configuring syscalls (e.g., <strong>openat</strong>) combined with vulnerable file-write syscalls (e.g., <strong>write</strong>) give us 17 Write-What-Where primitives, vulnerable socket-configuring syscalls (e.g., <strong>connect</strong>) combined with vulnerable socket-write syscalls (e.g., <strong>sendmsg</strong>) give us 41 Send-What-Where primitives, etc. We refer to our paper for a description of two such exploits that bypass state-of-the-art mitigations </span>[<a href="#reference-5" rel="nofollow">5</a>]<span>. Despite conventional wisdom dictating that data-only attacks are too complex or too niche to be practical, we can conclude that an attacker indeed has a diverse set of primitives at their disposal against popular server programs, even today.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table border="1">     <tr>       <th>Attack Primitive</th>       <th>Count</th>     </tr>     <tr>       <td>Code-Execution</td>       <td>1</td>     </tr>     <tr>       <td>Write-What-Where</td>       <td>17</td>     </tr>     <tr>       <td>Write-What</td>       <td>375</td>     </tr>     <tr>       <td>Write-Where</td>       <td>79</td>     </tr>     <tr>       <td>Send-What-Where</td>       <td>41</td>     </tr>     <tr>       <td>Send-What</td>       <td>372</td>     </tr>     <tr>       <td>Send-Where</td>       <td>59</td>     </tr>     <tr>       <td>Total</td>       <td>944</td>     </tr>   </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 2: Confirmed exploits for nginx.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusion</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We presented Einstein, a data-only attack exploitation pipeline, which automatically builds exploits against popular servers and bypasses state-of-the-art mitigations. The question, then, is how do we properly mitigate such attacks? To answer this, let us consider two features that a proper mitigation would provide: (1) <em>comprehensiveness</em>, i.e., mitigating an attack surface entirely; and (2) <em>practicality</em>, i.e., requiring little effort to deploy, and, therefore, being more amenable to practical adoption.</span></p><p><span>For control-flow hijacking attacks in the old days, the parameters were relatively well-defined: they would typically overwrite a code pointer, which would then corrupt an indirect branch (e.g., a return instruction). Hence, the mitigations for such attacks (e.g., DEP, CFI, CPI) can generally afford to be both <em>comprehensive</em> and <em>practical</em>.</span></p><p><span>On the other hand, data-only attacks present a unique challenge: they may overwrite any data (not just code pointers), which may then corrupt any operation (not just indirect branches, or even syscalls, for that matter). Hence, the mitigations for such attacks can generally afford only to be either </span><em>comprehensive</em><span> or </span><em>practical</em><span>. That is, </span><em>comprehensive</em><span> defenses (e.g., memory safety, DFI) are <em>impractical</em>, because they either incur poor performance or require onerous changes in the software or hardware. Meanwhile, </span><em>practical</em><span> defenses (e.g., memory error scanning, selective DFI, syscall filtering) are <em>noncomprehensive</em>, because, as Einstein demonstrates, they leave part of the attack surface vulnerable.</span></p><p><span>Generating exploits that trivially bypass the </span><em>practical</em><span> defenses, Einstein highlights that vendors should strongly consider deploying one or more of the </span><em>comprehensive</em><span> defenses. Vendors may also use Einstein to mitigate vulnerabilities on a case-by-case basis, however, a general solution — e.g., by making the </span><em>comprehensive</em><span> defenses more </span><em>practical</em><span> — poses a pressing direction for future research.</span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] M. Miller, "Trends, challenges, and strategic shifts in the software vulnerability mitigation landscape," in <em>BlueHat</em>, 2019.</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Chromium, "Memory safety," <a href="https://www.chromium.org/Home/chromium-security/memory-safety/" rel="nofollow">https://www.chromium.org/Home/chromium-security/memory-safety/</a>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3]&nbsp;D. Hosfelt, “Implications of Rewriting a Browser Component in Rust,” <a href="https://hacks.mozilla.org/2019/02/rewriting-a-browser-component-in-rust/" rel="nofollow">https://hacks.mozilla.org/2019/02/rewriting-a-browser-component-in-rust/</a>, 2019.</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4]&nbsp;E. H. Spafford, “The Internet Worm Program: An Analysis,” <em>SIGCOMM CCR</em>, vol. 19, no. 1, 1989.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5]&nbsp;B. Johannesmeyer, A. Slowinska, H. Bos, and C. Giuffrida, "Practical Data-Only Attack Generation," in <em>USENIX Security</em>, 2024.</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6]&nbsp;S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, “Non-Control-Data Attacks Are Realistic Threats,” in <em>USENIX Security</em>, 2005.</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7]&nbsp;R. Rogowski, M. Morton, F. Li, F. Monrose, K.Z. Snow, and M. Polychronakis, "Revisiting Browser Security in the Modern Era: New Data-only Attacks and Defenses," in <em>EuroS&amp;P</em>, 2017.</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8]&nbsp;J. Newsome, and D. Song, "Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature Generation of Exploits on Commodity Software," in <em>NDSS</em>, 2005.</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise"
                    >An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise</a>
                </h2>

                                    <time datetime="2024-07-01 00:00:00">
                        2024-07-01 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Hongyu Li</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Linux is the de facto foundation for today’s computing infrastructure, and Linux developers have never eliminated memory and concurrency bugs [<a href="#reference-35" rel="nofollow">35</a>, <a href="#reference-39" rel="nofollow">39</a>, <a href="#reference-49" rel="nofollow">49</a>, <a href="#reference-56" rel="nofollow">56</a>], which have been plaguing systems software for years. Bugs keep emerging [<a href="#reference-9" rel="nofollow">9</a>, <a href="#reference-16" rel="nofollow">16</a>, <a href="#reference-17" rel="nofollow">17</a>, <a href="#reference-18" rel="nofollow">18</a>] despite years of security hardening and engineering efforts from the Linux community [<a href="#reference-1" rel="nofollow">1</a>, <a href="#reference-12" rel="nofollow">12</a>]. Rust seems to be a promising solution, which may finally resolve the aforementioned problems [<a href="#reference-8" rel="nofollow">8</a>]. As an emerging, statically and strongly-typed systems programming language, Rust claims to deliver both safety and performance without runtime overhead [<a href="#reference-34" rel="nofollow">34</a>]. Backing its claim is the <em>ownership</em> mechanism [<a href="#reference-31" rel="nofollow">31</a>] for eliminating memory and concurrency bugs. Rust eliminates a heavyweight and costly memory checker [<a href="#reference-51" rel="nofollow">51</a>, <a href="#reference-55" rel="nofollow">55</a>] as well as a garbage collector [<a href="48" rel="nofollow">48</a>, <a href="#reference-52" rel="nofollow">52</a>], eschewing being interrupted and having unpredictable delays at run time.</p><p><span>These intriguing properties of Rust led to the advent of <em>Rust-For-Linux</em> (RFL), which began in 2013 as a hobbyist project [</span><a href="#reference-2" rel="nofollow">2</a>]. As the first attempt to bring Rust into Linux, the project built a Rust object file against kernel headers and invoked one Rust function from the file in a loadable kernel module. In 2019, a proposal to write kernel modules fully in Rust emerged [<a href="#reference-4" rel="nofollow">4</a>, <a href="#reference-6" rel="nofollow">6</a>] to lead Rust further into Linux. To achieve this goal, the proposal took a bold move by directly adding a thin Rust wrapping layer to kernel interfaces and data structures in upstream Linux. Only a year after the RFC, RFL was officially merged into upstream Linux v6.1 as an experimental kernel feature [<a href="#reference-13" rel="nofollow">13</a>]. As RFL gradually improved in the journey of building a more robust Linux, there emerged numerous attempts to use RFL to write drivers in various areas, such as network [<a href="#reference-40" rel="nofollow">40</a>], block device [<a href="#reference-45" rel="nofollow">45</a>, <a href="#reference-46" rel="nofollow">46</a>], file system [<a href="#reference-20" rel="nofollow">20</a>, <a href="#reference-22" rel="nofollow">22</a>], android [<a href="#reference-38" rel="nofollow">38</a>], and GPU [<a href="#reference-44" rel="nofollow">44</a>]. Among them, one network driver [<a href="#reference-24" rel="nofollow">24</a>] first made it into the Linux mainline in v6.8 after 11 rounds’ co-review by the RFL and network community. This means RFL can receive feedback from users, which is a sign of RFL stepping into the real use cases from the experimental states. Despite still being in an early stage, RFL has become one of the most active kernel subsystems [<a href="#reference-30" rel="nofollow">30</a>], on par with <strong>ebpf</strong> [<a href="#reference-41" rel="nofollow">41</a>], and <strong>io_uring</strong> [<a href="#reference-43" rel="nofollow">43</a>].</p><p><span>This article takes the ﬁrst in-depth look into RFL and how a new program</span>ming language blends into a giant, old-school codebase which has been already shipped on billions of computing devices. We report our ﬁndings on two key research questions (RQs). First, what is the status quo of RFL? Second, does RFL live up to the hype?</p><p>For full details, please refer to our USENIX ATC’24 paper [<a href="#reference-58" rel="nofollow">58</a>].</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">RQ1: What is the status quo of RFL</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h5><strong>RFL development status</strong></h5><p><em>(1) Development progress. </em>We ﬁrst analyze the development progress of RFL. Overall, RFL is still at a very early stage in blending with the Linux kernel: in terms of LoC, the merged code (7.1%) only constitutes 0.125% of the kernel code, while the rest (92.9%) is still pending review or is staged for merging. We further break down the merged code by their respective kernel subsystems to understand individual status and show the results in Figure 1.</p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure3_00.jpg?itok=qno2z5Ke" width="1440" height="668" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: The progress of wrapping APIs.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 1: drivers, netdev, and ﬁle systems are the long tail of RFL code.</strong></h4></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We have observed a clear long tail: most Rust code resides in scheduling, memory management, and IRQ infrastructure. By contrast, drivers, ﬁle systems, netdev, <span>and security subsystems which account for most kernel code (i.e., 78% in Linux </span>v6.2) only have received little RFL code, constituting the “tail”. The results are sensible. As scheduling, memory management, and IRQ subsystems are most commonly used by all drivers, optimizing RFL development for them has a high value and priority. In comparison, drivers and ﬁle systems have more speciﬁc use cases (e.g., for a particular model of a device), which require more programming and reviewing eﬀort. For instance, reviewers from netdev communities spent 6 months on 11 versions of draft patches, before settling one the ﬁnal merged network PHY driver [<a href="#reference-29" rel="nofollow">29</a>].</p><p><em>(2) Patch distribution.</em> To study how individual RFL components develop, we categorize the code into three types depending on their use cases, i.e. for building safe abstraction, the Kbuild system, and the Rust compiler. We show the results in Figure 2 and conclude the following insight:</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure4_0.png?itok=AqRHIy5H" width="1440" height="787" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: RFL patch distribution over time. Rust, Kbuild, abstraction are patches for modifying Rust compiler, constructing KBuild system, and the safe abstraction, respectively.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 2: RFL infrastructure has matured, with safe abstraction and drivers being the next focus.</strong></h4></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>We base the insight on two key pieces of evidence: 1) as time passes, Kbuild undergoes a clear recession in its portion of the RFL cake, indicating the foundation of RFL has been laid; 2) in the meantime, abstraction takes up more portion, e.g., from 20% to 60% in 18 months. Interestingly, a surge in the number of Rust commits appeared half a year after RFL started, as seen by the 23/4 timestamp of Figure 2. It belongs to a patch that directly modifies the RFL lib code for supporting a safe implementation of the Rust initializer for pinned objects; prior to the fix, early RFL has been using an unsafe initializer in <strong>gpio_pl061 </strong>and <strong>bcm2835_rng</strong> drivers.</span></p><p><em>(3) The trend.</em> To understand how RFL development progresses with time, we project the commits and the email exchanges onto the timeline and highlight the reviewing time length of the PRs, as shown in Figure 3.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure6_1.png?itok=8JWs_RWm" width="1440" height="766" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3: The trend of RFL commits and reviews over time.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 3: RFL is bottlenecked by code review but not by code development.</strong></h4></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><p>From the slope changes in the lefthand graph of Figure 3, we are witnessing the committed/staged RFL code start to plateau after the initial steep slope when RFL first started. Yet, the number of email exchanges shows RFL is an increasingly active community. Besides, the PR reviewing becomes significantly slower as time goes by, e.g., the PRs between Jan. 2023 and Jul. 2023 take 280 hours to be reviewed on average, which is 200× as long as 3 years ago. This suggests the speed of producing RFL code is much faster than that of consumption, i.e., reviewing and eventually merging RFL code into the upstream kernel. This can also be confirmed by the huge imbalance between merged code versus the rest of the code, where the latter is 13× larger than the former and represents a huge bulk of the area.</p><p>An inspiring observation is that RFL is gradually being embraced by the kernel community, seeing the increasing engagement of traditional kernel developers. For example, the recently developed NVME, NULL block, V4L2, and e1000 drivers using RFL are all driven by the Linux community.</p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h5><strong>Rustify Linux with safe abstraction</strong></h5><div></div><p>Safe abstraction is the key ingredient towards rustifying Linux kernel and among the largest portions of RFL code. As the name itself implies, the layer extends C kernel features safely into Rust drivers: it abstracts kernel data structures and interfaces, so that upon invocation they may still ensure memory and thread safety.</p><div></div><div></div><div></div><p><strong>Converting kernel data structures</strong> RFL leverages <strong>bindgen</strong> to automatically generate Rust bindings of C kernel struct prior to use. The generation is rule-based and syntax-directed, which translates the C types and symbols into their Rust counterparts. The translation is mechanical, following the rules in Table 1. For instance, uint32_t of C translates into c_uint in Rust namespace core::ffi, which aliases to the Rust primitive u32. However, not every C type translates into a corresponding Rust primitive. We have found such incompatibility exists especially in language features which kernel developers exploit for manually consolidating memory layout. We detail them as follows.</p><div></div><div></div><div></div><p><em>(1) Emulated bitfields and unions.</em> The kernel extensively uses bitfields and unions for improving memory efficiency, e.g., the e1000 driver uses a single word to store 4 flags to indicate link states. Bit operations on struct members contradict Rust memory safety principle and hence do not have native Rust support. As a workaround, RFL emulates bitﬁelds with a byte array, which implements bit operations as accessors to the array. Although Rust has a union primitive, it cannot provide ABI compatibility with C union. Thus RFL implements a struct called <strong>__BindgenUnionField</strong> with the same memory layout as the C interface. Both workarounds are based on the transmute operation, which reinterprets memory at run time, hence are implemented in unsafe blocks. The major overhead of the emulation code is the increase of binary size, which we will discuss in the <strong>"Does Rust incur any overhead?" </strong>section.</p><div></div><div></div><div></div><p><em>(2) Incomplete attribute support.</em> The kernel often relies on packed and aligned attributes for better locality and memory efficiency, e.g., <strong>task_struct</strong> groups most frequently access scheduling data in one cache line. Despite the attributes that are supported by Rust repr(C), Rust may still mishandle them and cause <strong>bindgen</strong> to generate the wrong code [<a href="#reference-3" rel="nofollow">3</a>, <a href="#reference-5" rel="nofollow">5</a>]. For attributes less commonly used, RFL does not support them, e.g., BTF tags [<a href="#reference-14" rel="nofollow">14</a>]. Notably, RFL ignores the <strong>randomize_layout</strong> attribute, which kernel utilizes to mitigate memory bugs [<a href="#reference-37" rel="nofollow">37</a>]. This is reasonable because Rust has already mitigated such vulnerabilities through ownership and boundary checks.</p><p>Despite the generated bindings having the identical data layout as their C counterpart, the safe abstraction layer still cannot directly expose them to drivers. This is because the bindings involve numerous raw pointers (i.e., <strong>*mut</strong>), which are prevalent in the kernel but are unsafe to use in Rust. To safely use them, Rust needs to manually reason about the pointer validity (i.e., not via borrow checker at compile time) and specify their ownership. To this end, RFL uses helper types to embed generated kernel data structure bindings and bakes Rust ﬂavors into them.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 4: The kernel’s initiative to control memory in fine granularity conflicts Rust philosophy, which incurs overhead for RFL.</strong></h4></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table class="tg">   <tr>     <th class="tg-n73t">Type</th>     <th class="tg-n73t">C</th>     <th class="tg-n73t">Rust</th>   </tr>    <tr>     <td class="tg-xnen">Primitive types</td>     <td class="tg-xnen">foo</td>     <td class="tg-xnen">core::ffi:c_foo</td>   </tr>   <tr>     <td class="tg-xnen">Typed pointers</td>     <td class="tg-xnen">foo *</td>     <td class="tg-xnen">*mut foo</td>   </tr>   <tr>     <td class="tg-xnen" rowspan="5">Attributes</td>     <td class="tg-xnen" rowspan="2">aligned</td>     <td class="tg-xnen" rowspan="2">#repr(c)(with caveats [3, 5])</td>   </tr>   <tr>   </tr>   <tr>     <td class="tg-xnen">unused</td>     <td class="tg-xnen">ignored</td>   </tr>   <tr>     <td class="tg-xnen">weak</td>     <td class="tg-xnen">ignored</td>   </tr>   <tr>     <td class="tg-xnen">randomize_layout</td>     <td class="tg-c3ow">ignored</td>   </tr>   <tr>     <td class="tg-xnen">Function pointer</td>     <td class="tg-xnen">fn</td>     <td class="tg-xnen">option&lt;fn&gt;</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1: The translation rules from C to Rust in the rust-bindgen.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h5><strong>Incorporating kernel functions</strong> </h5><div></div><p>Following similar translation rules in converting the kernel data structures (Table 1), RFL generates FFI bindings of kernel functions. Then, RFL extensively leverages Rust traits to massage Rust features into them in the safe abstraction layer. We summarize three major measures.</p><div><div><p><em>(1) Functions as members of structs.</em> RFL groups kernel functions related to a type and incorporates them as members of the type struct, following an OOP paradigm. For instance, it groups work queue related functions such as <strong>queue_work_on</strong>, <strong>__INIT_WORK_WITH_KEY</strong> under Rust <strong>struct Queue</strong>, the RFL helper type for kernel <strong>struct workqueue_struct</strong>. Doing so improves code readability and ensures the caller of these functions is never null, avoiding pointer validity checks inside the function body.</p><p><em>(2) Functions pointers as traits.</em> Many kernel functions are dangling and used only as callbacks of kernel structs at run time. RFL incorporates them as traits of the helper type and specify bounds on them. The trait bounds specify the callback types and owner struct for the dangling kernel functions, preventing vulnerabilities caused by incorrect type casting [<a href="#reference-10" rel="nofollow">10</a>].</p><p><em>(3) Wrapping inlined functions and macros.</em> Inlined functions and macros provide important and handy utilities to kernel drivers, e.g., for_each_online_cpu to enumerate available CPUs. RFL wraps static inline functions with non-inlined Rust functions. This is because current Rust lacks a convenient mechanism for inlining Foreign Function Interfaces (FFIs) of C functions; while it is still possible to inline them, it takes lots of efforts and hence is not encouraged by the community [<a href="#reference-27" rel="nofollow">27</a>]. For function-like macros, RFL prefers wrapping them with helper functions instead of rewriting them with Rust macros. The main reason is RFL inclines not to maintain two sets of kernel interfaces known to be unstable [<a href="#reference-50" rel="nofollow">50</a>].</p></div><div></div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 5: RFL uses helper types to delegate management of kernel data to Rust while leaving the operation to the kernel itself.</strong></h4></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">RQ2: Does RFL live up to the hype?</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h5><strong>RFL makes Linux more “securable”</strong></h5><div><p>We first collect all bug reports and safety-related code reviews among the RFL abstractions and drivers. In total, we have found 25 bugs from merged and staged RFL code. Among them, 15 of them are in the Linux mainline and 10 of them are in the stage Rust branch. We list them in Table 2. Of the bugs within merged code, 11 are compilation bugs and the other 4 are related to safe abstraction. The compilation bugs do not introduce safety vulnerabilities; they are mostly caused by the misconfig of the kernel, incompatibility of various Clang toolchain versions and the mismatch between the Kbuild and <strong>rustc</strong> compiler [<a href="#reference-11" rel="nofollow">11</a>]. Of the soundness bugs, 6 are in the safe abstraction layer and break memory safety and 3 break thread safety.</p><p>RFL safety hinges on the safety assurance of Rust language, which concretely relies on the elimination of all unsafe blocks in drivers and the safe abstraction APIs. Therefore, they are the entry point to RFL safety vulnerabilities, if any. We examine all existing RFL drivers and Rust kernel crates in the upstream repo [<a href="#reference-15" rel="nofollow">15</a>] and analyze the usage of unsafe code blocks. We have not found any unsafe usage of RFL drivers in the Linux mainline, because no serious driver has made into the mainline except for one with around 130 lines of code [<a href="#reference-33" rel="nofollow">33</a>]. However, we have found unsafe cases in the drivers that are proposed to the RFL mailing list. We show the results in Table 3.</p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table class="tg">   <tr>     <th class="tg-vl74">Source</th>     <th class="tg-xnen">Compilation bug</th>     <th class="tg-xnen">Soundness bug</th>   </tr>    <tr>     <td class="tg-xnen">GitHub [15]</td>     <td class="tg-xnen">4(1/3)</td>     <td class="tg-xnen">7(3/4)</td>   </tr>   <tr>     <td class="tg-xnen">Intel LKP [26]</td>     <td class="tg-xnen">8(6/2)</td>     <td class="tg-xnen">0</td>   </tr>   <tr>     <td class="tg-ndl6">Mailing List [28]</td>     <td class="tg-ndl6">4(4/0)</td>     <td class="tg-ndl6">2(1/1)</td>   </tr>  </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 2: The bugs we have found in RFL. (x/y): x and y stands for number of bugs from merged and staged code respectively. We have not found bugs from Syzbot [25] and KernelCI [23].</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table class="tg">   <tr>     <th class="tg-ndl6" rowspan="2">Driver</th>     <th class="tg-ndl6" colspan="2">Number of Unsafe usage</th>   </tr>   <tr>     <th class="tg-ndl6">Driver logic</th>     <th class="tg-amwm">Safety abstractions</th>   </tr>    <tr>     <td class="tg-ndl6">GPU [44]</td>     <td class="tg-ndl6">107</td>     <td class="tg-baqh">7</td>   </tr>   <tr>     <td class="tg-ndl6">NVME [46]</td>     <td class="tg-ndl6">44</td>     <td class="tg-baqh">16</td>   </tr>   <tr>     <td class="tg-ndl6">Null block [45]</td>     <td class="tg-ndl6">0</td>     <td class="tg-baqh">0</td>   </tr>   <tr>     <td class="tg-ndl6">E1000 [40]</td>     <td class="tg-ndl6">4</td>     <td class="tg-baqh">2</td>   </tr>   <tr>     <td class="tg-ndl6">Binder [38]</td>     <td class="tg-ndl6">45</td>     <td class="tg-baqh">9</td>   </tr>   <tr>     <td class="tg-ndl6">Gpio_pl061 [42]</td>     <td class="tg-ndl6">0</td>     <td class="tg-baqh">3</td>   </tr>   <tr>     <td class="tg-ndl6">Semaphore [37]</td>     <td class="tg-ndl6">0</td>     <td class="tg-baqh">4</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 3: The unsafe usage in RFL drivers. The second and third columns show the number of unsafe usage due to 1) Driver logic is too complex for Rust safety rules, and 2) Safety abstractions are currently missing in RFL, respectively.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><p><strong>Post analysis</strong> We audit the bug reports and unsafe code to summarize our findings on RFL safety as follows.</p><p>Our verdict is reminiscent of that of the Multics security audit [<a href="#reference-54" rel="nofollow">54</a>] and is based on the following facts.</p><p><em>(1) Rust safety mechanism constructs the pillar of kernel safety.</em> The language-level support helps kernel drivers fix existing bugs and eschew potential memory/concurrency bugs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as <strong>klint</strong> [<a href="#reference-19" rel="nofollow">19</a>], and RustBelt [<a href="#reference-53" rel="nofollow">53</a>] to further harden the kernel. Compared with C, RFL greatly reduces the vast attack space of kernel software caused by memory bugs. As a result, the developer has much less to reason about in terms of kernel security.</p><p><em>(2) unsafe is inevitable, though vulnerabilities are optional.</em> In our audit, we have found unsafe code exist commonly in all major drivers and it is hard, if not impossible, to fully eliminate them. The reason is twofold. First, as the kernel asserts full control over memory and hardware, its operations need to bypass Rust ownership checks. For instance, kernel developers exploit inline assembly for managing TLB and issuing memory barrier [<a href="#reference-44" rel="nofollow">44</a>], raw pointers for de-referencing MMIO registers, and unions/bitfields. Second, the community sometimes has to compromise on unsafe functions. This is because ownership sometimes introduces twisted implementation, which often requires long reviewing cycles. A notable example we have found is a memory initialization interface <strong>pin-init</strong>. After rounds of debates by seasoned developers [<a href="#reference-7" rel="nofollow">7</a>, <a href="#reference-36" rel="nofollow">36</a>], has the interface been finally fixed in a recent patch [<a href="#reference-32" rel="nofollow">32</a>].</p><p><em>(3) Bugs do not disappear; they only hide deeper.</em> On the one hand, kernel functions invoked by the safe abstraction and Rust drivers may still contain bugs and be exploited. On the other hand, although Rust compile-time borrow checker detects memory bugs on the spot, it does not detect semantic bugs, which are often caused by subtle differences in Rust and kernel memory allocation methods. Such bugs may take a long to ﬁx and can only be detected by experts who are familiar with both Rust and kernel. For example, the C binder driver has a use-after-free [<a href="#reference-21" rel="nofollow">21</a>] bug. When being re-implemented in Rust, it will not cause the same symptom as in C. Instead, it incurs a mapping bug putting the memory into the wrong place which passes all the checks by the Rust compiler.</p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 6: with RFL, Linux becomes more “securable” but still cannot be fully secure.</strong></h4></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h5><span>Does rust incur any overhead?</span></h5><div><p><strong>Setup</strong> We collect 4 drivers with serious use cases, which span diverse IO functions (e.g., network, storage). Notably, NVME and <strong>binder</strong> are considered the first batch of drivers to be merged in the Linux mainline. In addition, we include 2 more toy drivers (i.e., <strong>gpio</strong> and <strong>sem</strong>) from RFL Rust branch which are often used to explore the difference between Rust and C implementation. Among the 6 drivers tested, only <strong>binder</strong> and the 2 toy example drivers have faithfully implemented full features as C drivers do; while the rest of them have only implemented a subset of the features.</p><p><strong>Binary size</strong> As illustrated in Figure 4, Rust drivers with fully implemented features are significantly larger than C: Since the text section is to be blamed for most of the increased binary size, we looked into it further and find that Rust generates extra code (99%) to support its unique features that C does not have: generic programming, boundary checks, lifecycle management, etc. Even for the <strong>gpio</strong> driver which simply wraps around five kernel APIs (i.e., <strong>probe</strong>, <strong>mask/unmask</strong>, <strong>irq_type</strong>, <strong>suspend</strong> and <strong>resume</strong>), Rust expands its size by 33%.</p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure8.png?itok=8eqcS0xv" width="1440" height="1404" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4: Comparison of Rust and C driver size. * indicates that the Rust driver has not implemented as full features as the C version.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong>Performance</strong> Mostly, Rust drivers show on par performance with C drivers within a 20% gap. Occasionally, Rust underperforms C significantly; in a few cases, Rust surprisingly outperforms C. Looking into individual drivers, we have found:</p><ol><li>For e1000, Rust driver is 11× slower than C driver for <strong>ping</strong> latency as presented in Figure 5. The reason we dug out is that the Rust driver has not yet implemented as many features that can accelerate data transmission as the C driver does, e.g., prefetch.</li><li>For <strong>binder</strong>, the Rust driver shows similar performance with C, with only a 10% gap in ping latency.</li><li>For storage devices (NVME and NULL block), Rust drivers lead to overall similar performance with C, with up to 61% degradation and 67% improvement in throughput, depending on the specific settings (e.g., job number and batch sizes) as shown in Figure 6 and Figure 7. We observe that Rust drivers favor smaller job numbers and blocksize, possibly because Rust often has smaller <strong>struct</strong>s (reasons explained later) which are more likely to fit in the cache line.</li></ol></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure7.png?itok=AZTQKgxY" width="1440" height="1104" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 5: The latencies between Rust and C drivers. Rust e1000 driver is signiﬁcantly slower because it lacks advanced features such as prefetch.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure5.png?itok=gEVjlRNH" width="1440" height="703" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 6: The performance comparison of NULL block drivers. Green cell indicates the Rust driver performs better than the C driver in the conﬁguration. Red means the Rust driver under-performs the C driver.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/figure5_1.png?itok=pM2iSJ2P" width="1440" height="769" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 7: The performance comparison of NVME driver.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h5>Why Rust drivers may perform poorly</h5><ol><li>Locks in Rust drivers are coarse-grained. Despite Rust off-loading the duty of ensuring thread-safety to the language itself (i.e., via rules), it does not lift the burden of high-performance concurrency programming of a developer.</li><li>Rust runtime checks in accessing arrays (e.g., boundary checks) introduce extra performance costs. The results are consistent with the prior study which reports Rust program overhead can be 2.49× larger than C program [<a href="#reference-57" rel="nofollow">57</a>]. Rust performs poorly in memory-intensive workloads.</li><li>Rust uses the emulated bit ﬁelds. As introduced earlier in <strong>"Rustify Linux with safe abstraction"</strong>, bit ﬁeld accesses are emulated via array accesses. It further gets exacerbated by the runtime boundary checks.</li><li>Rust massively use pointers to share the ownership of objects, which results in a higher cache/TLB/branch miss rate.</li></ol><h5>Why Rust drivers may perform better</h5><ol><li>The Rust <strong>struct</strong> has a smaller size compared with the C due to the usage of smart pointers instead of allocating item memory inside the <strong>struct</strong>. We use <strong>pahole</strong> to identify that Rust <strong>struct</strong>s use fewer cache lines than their C counterpart.</li><li>The Rust driver does not implement full features compared with C, thus some code paths may be omitted.</li></ol></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><strong>Insight 7: There is no free lunch for performance – it is the programmer that counts!</strong></h4></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusions</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>In this article, we thoroughly investigate RFL, the very ﬁrst and increasingly popular project that aims to use Rust to enhance the Linux kernel. We ﬁrst study the status quo of RFL by diving into the construction of the safe abstraction layer and Rust drivers, which reveals the tension between the language features of Rust and kernel programming. We then look into whether and to what extent RFL has delivered its promise in building a safer kernel with zero overhead. The results show RFL brings better safety but still has leaks which are stealthier and undetectable by the compiler, and that the overhead brought by the tension between Rust and Linux can not be totally erased. Last, we summarize key lessons learned in this study, hoping it may guide future development of RFL.</p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] The static code analysis tool Coverity scan results for Linux. <a href="https://scan.coverity.com/projects/linux" rel="nofollow">https://scan.coverity.com/projects/linux</a>, 2006.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] A minimal Linux kernel module written in Rust. <a href="https://github.com/tsgates/rust.ko" rel="nofollow">https://github.com/tsgates/rust.ko</a>, 2013.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] Bindgen does not handle packed and aligned right.&nbsp;<a href="https://github.com/rust-lang/rust-bindgen/issues/1538" rel="nofollow">https://github.com/rust-lang/rust-bindgen/issues/1538</a>, 2019.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Why write Linux Kernel Modules in Safe Rust.&nbsp;<a href="https://www.youtube.com/watch?v=RyY01fRyGhM" rel="nofollow">https://www.youtube.com/watch?v=RyY01fRyGhM</a>, 2019.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Bindgen mishandles aligned typedefs. <a href="https://github.com/rust-lang/rust-bindgen/issues/1753" rel="nofollow">https://github.com/rust-lang/rust-bindgen/issues/1753</a>, 2020.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Linux kernel modules in safe Rust. <a href="https://github.com/fishinabarrel/linux-kernel-module-rust" rel="nofollow">https://github.com/fishinabarrel/linux-kernel-module-rust</a>, 2021.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] The issue of ”Safe initialization of pinned structs” in github. <a href="https://github.com/Rust-for-Linux/linux/issues/290" rel="nofollow">https://github.com/Rust-for-Linux/linux/issues/290</a>, 2021.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] The RFC in the maillist for Rust support. <a href="https://lore.kernel.org/rust-for-linux/20210414184604.23473-1-ojeda@kernel.org/" rel="nofollow">https://lore.kernel.org/rust-for-linux/20210414184604.23473-1-ojeda@kern...</a>, 2021.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] A Linux CVE caused by data race. <a href="https://www.cvedetails.com/cve/CVE-2022-3566/" rel="nofollow">https://www.cvedetails.com/cve/CVE-2022-3566/</a>, 2022.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10] A Linux CVE caused by incorrect type casting. <a href="https://www.cvedetails.com/cve/CVE-2018-5861" rel="nofollow">https://www.cvedetails.com/cve/CVE-2018-5861</a>, 2022.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-11"></a><p>[11] A RFL bug due to the misconﬁg of Kbuild. <a href="https://github.com/Rust-for-Linux/linux/issues/735" rel="nofollow">https://github.com/Rust-for-Linux/linux/issues/735</a>, 2022.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-12"></a><p>[12] KMSAN is a dynamic error detector aimed at ﬁnding uses of uninitialized values. <a href="https://docs.kernel.org/dev-tools/kmsan.html" rel="nofollow">https://docs.kernel.org/dev-tools/kmsan.html</a>, 2022.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-13"></a><p>[13] Linux merges Rust into the mainline. <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8aebac82933ff1a7c8eede18cab11e1115e2062b" rel="nofollow">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commi...</a>, 2022.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-14"></a><p>[14] RFL discards BTF TYPE TAG attribute. <a href="https://github.com/rust-lang/rust-bindgen/issues/2244" rel="nofollow">https://github.com/rust-lang/rust-bindgen/issues/2244</a>, 2022.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-15"></a><p>[15] The Rust-for-Linux project helping write drivers in Linux. <a href="https://github.com/Rust-for-Linux/linux/" rel="nofollow">https://github.com/Rust-for-Linux/linux/</a>, 2022.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-16"></a><p>[16] A Linux CVE caused by oob bugs. <a href="https://www.cvedetails.com/cve/CVE-2023-38429/" rel="nofollow">https://www.cvedetails.com/cve/CVE-2023-38429/</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-17"></a><p>[17] A Linux CVE caused by use-after-free. <a href="https://www.cvedetails.com/cve/CVE-2023-33288/" rel="nofollow">https://www.cvedetails.com/cve/CVE-2023-33288/</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-18"></a><p>[18] A Linux CVE caused by usedouble free. <a href="https://www.cvedetails.com/cve/CVE-2023-28464/" rel="nofollow">https://www.cvedetails.com/cve/CVE-2023-28464/</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-19"></a><p>[19] Lints for kernel or embedded system development. <a href="https://github.com/Rust-for-Linux/klint" rel="nofollow">https://github.com/Rust-for-Linux/klint</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-20"></a><p>[20] PuzzleFS buiild on the top of vfs abstractions in RFL. <a href="https://lore.kernel.org/rust-for-linux/20230609063118.24852-1-amiculas@cisco.com/" rel="nofollow">https://lore.kernel.org/rust-for-linux/20230609063118.24852-1-amiculas@c...</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-21"></a><p>[21] Rewriting drivers in RFL can still have bugs. <a href="https://lwn.net/Articles/953116/" rel="nofollow">https://lwn.net/Articles/953116/</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-22"></a><p>[22] Tarfs build on the top of vfs abstractions in RFL. <a href="https://github.com/Rust-for-Linux/linux/pull/1037" rel="nofollow">https://github.com/Rust-for-Linux/linux/pull/1037</a>, 2023.</p> </div><div class="field-item odd"><a class="anchor" name="reference-23"></a><p>[23] The community-based distributed test automation system KernelCI.&nbsp;<a href="https://foundation.kernelci.org/" rel="nofollow">https://foundation.kernelci.org/</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-24"></a><p>[24] The ﬁrst rust driver merged into in the Linux mainline. <a href="https://lore.kernel.org/rust-for-linux/20231213004211.1625780-1-fujita.tomonori@gmail.com/" rel="nofollow">https://lore.kernel.org/rust-for-linux/20231213004211.1625780-1-fujita.t...</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-25"></a><p>[25] The google Syzbot kernel fuzzer project. <a href="https://syzkaller.appspot.com/upstream" rel="nofollow">https://syzkaller.appspot.com/upstream</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-26"></a><p>[26] The intel Linux Kernel Performance(LKP) project. <a href="https://www.intel.com/content/www/us/en/developer/topic-technology/open/linux-kernel-performance/overview.html" rel="nofollow">https://www.intel.com/content/www/us/en/developer/topic-technology/open/...</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-27"></a><p>[27] The LTO optimization for Rust kernel modules. <a href="https://kangrejos.com/2023/Inlining%20and%20LTO%20for%20Rust%20Kernel%20Modules.pdf,2023. " rel="nofollow">https://kangrejos.com/2023/Inlining%20and%20LTO%20for%20Rust%20Kernel%20...</a></p> </div><div class="field-item even"><a class="anchor" name="reference-28"></a><p>[28] The mailing list of Rust-for-Linux project. <a href="https://lore.kernel.org/rust-for-linux/" rel="nofollow">https://lore.kernel.org/rust-for-linux/</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-29"></a><p>[29] The network PHY driver abstraction is merged. <a href="https://lore.kernel.org/rust-for-linux/170263322444.1975.17234929609368010648.git-patchwork-notify@kernel.org/" rel="nofollow">https://lore.kernel.org/rust-for-linux/170263322444.1975.172349296093680...</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-30"></a><p>[30] The oﬃcial statistics about the RFL community size. <a href="https://kangrejos.com/2023/" rel="nofollow">https://kangrejos.com/2023/</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-31"></a><p>[31] The ownership mechanism of the Rust. <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" rel="nofollow">https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-32"></a><p>[32] The patch of <strong>pin-init </strong>API. <a href="https://github.com/Rust-for-Linux/linux/commit/90e53c5e70a69159ec255fec361f7dcf9cf36eae" rel="nofollow">https://github.com/Rust-for-Linux/linux/commit/90e53c5e70a69159ec255fec3...</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-33"></a><p>[33] The Rust implementation of drivers/net/phy/ax88796b.c. <a href="https://lore.kernel.org/rust-for-linux/20231213004211.1625780-5-fujita.tomonori@gmail.com/" rel="nofollow">https://lore.kernel.org/rust-for-linux/20231213004211.1625780-5-fujita.t...</a>, 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-34"></a><p>[34] The Rust Programming Language. <a href="https://www.rust-lang.org/" rel="nofollow">https://www.rust-lang.org/</a>, 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-35"></a><p>[35] Kernel Self Protection Project. <a href="https://kernsec.org/wiki/index.php/Kernel" rel="nofollow">https://kernsec.org/wiki/index.php/Kernel</a> Self Protection Project, 2024.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-36"></a><p>[36] The 7 <strong>pin-init</strong> patches proposed in Github. <a href="https://lore.kernel.org/all/?q=Rust+pin-init+API+for+pinned+initialization+of+structs,2024" rel="nofollow">https://lore.kernel.org/all/?q=Rust+pin-init+API+for+pinned+initializati...</a>.</p> </div><div class="field-item odd"><a class="anchor" name="reference-37"></a><p>[37] The Address space layout randomization wiki. <a href="https://en.wikipedia.org/wiki/Address" rel="nofollow">https://en.wikipedia.org/wiki/Address</a> space layout randomization, 2024.</p> </div><div class="field-item even"><a class="anchor" name="reference-38"></a><p>[38] The Android <strong>binder</strong> driver in Rust. <a href="https://github.com/Darksonn/linux, 2024. " rel="nofollow">https://github.com/Darksonn/linux, 2024. </a></p> </div><div class="field-item odd"><a class="anchor" name="reference-39"></a><p>[39] The documentation about how Linux handles bugs. <a href="https://docs.kernel.org/process/index.html#dealing-with-bugs" rel="nofollow">https://docs.kernel.org/process/index.html#dealing-with-bugs</a>, 2024.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-40"></a><p>[40] The e1000 NIC driver in Rust. <a href="https://github.com/fujita/rust-e1000" rel="nofollow">https://github.com/fujita/rust-e1000</a>, 2024.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-41"></a><p>[41] The <strong>ebpf</strong> project. <a href="https://ebpf.io/" rel="nofollow">https://ebpf.io/</a>, 2024.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-42"></a><p>[42] The <strong>gpio</strong> driver written in Rust. <a href="https://github.com/Rust-for-Linux/linux/blob/rust/drivers/gpio/gpio" rel="nofollow">https://github.com/Rust-for-Linux/linux/blob/rust/drivers/gpio/gpio</a> pl061 rust.rs, 2024.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-43"></a><p>[43] The <strong>io uring</strong> project. <a href="https://github.com/axboe/liburing" rel="nofollow">https://github.com/axboe/liburing</a>, 2024.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-44"></a><p>[44] The Mac GPU driver in Rust. <a href="https://github.com/AsahiLinux/linux/tree/gpu/rust-wip" rel="nofollow">https://github.com/AsahiLinux/linux/tree/gpu/rust-wip</a>, 2024.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-45"></a><p>[45] The NULL block driver written in Rust. <a href="https://lore.kernel.org/rust-for-linux/20230503090708.2524310-1-nmi@metaspace.dk/" rel="nofollow">https://lore.kernel.org/rust-for-linux/20230503090708.2524310-1-nmi@meta...</a>, 2024.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-46"></a><p>[46] The NVME device driver written in Rust. <a href="https://github.com/metaspace/linux/tree/nvme" rel="nofollow">https://github.com/metaspace/linux/tree/nvme</a>, 2024.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-47"></a><p>[47] The semaphore driver written in Rust. <a href="https://github.com/Rust-for-Linux/linux/blob/rust/samples/rust/rust" rel="nofollow">https://github.com/Rust-for-Linux/linux/blob/rust/samples/rust/rust</a> semaphore.rs, 2024.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-48"></a><p>[48] Stephen M Blackburn, Perry Cheng, and Kathryn S McKinley. Oil and water? high performance garbage collection in java with mmtk. In Proceedings. 26th International Conference on Software Engineering, pages 137–146. IEEE, 2004.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-49"></a><p>[49] Sishuai Gong, Deniz Altinb¨uken, Pedro Fonseca, and Petros Maniatis. Snowboard: Finding kernel concurrency bugs through systematic interthread communication analysis. In Proceedings of the ACM SIGOPS 28th Symposium on Operating Systems Principles, pages 66–83, 2021.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-50"></a><p>[50] Liwei Guo, Shuang Zhai, Yi Qiao, and Felix Xiaozhu Lin. Transkernel: bridging monolithic kernels to peripheral cores. In 2019 USENIX Annual Technical Conference (USENIX ATC 19), pages 675–692, 2019.&nbsp;<a href="https://www.usenix.org/conference/atc19/presentation/guo ">https://www.usenix.org/conference/atc19/presentation/guo </a></p> </div><div class="field-item odd"><a class="anchor" name="reference-51"></a><p>[51] Thuan Quang Huynh and Abhik Roychoudhury. A memory model sensitive checker for c#. In International Symposium on Formal Methods, pages 476–491. Springer, 2006.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-52"></a><p>[52] Mohamed Ismail and G Edward Suh. Quantitative overhead analysis for python. In 2018 IEEE International Symposium on Workload Characterization (IISWC), pages 36–47. IEEE, 2018.</p> </div><div class="field-item odd"><a class="anchor" name="reference-53"></a><p>[53] Ralf Jung, Jacques-Henri Jourdan, Robbert Krebbers, and Derek Dreyer.&nbsp;Rustbelt: Securing the foundations of the rust programming language.&nbsp;Proc. ACM Program. Lang., 2(POPL), dec 2017.</p> </div><div class="field-item even"><a class="anchor" name="reference-54"></a><p>[54] Paul A Karger and Roger R Schell. Multics security evaluation: Vulnerability analysis. In 18th Annual Computer Security Applications Conference, 2002. Proceedings., pages 127–146. IEEE, 2002.</p> </div><div class="field-item odd"><a class="anchor" name="reference-55"></a><p>[55] Michalis Kokologiannakis and Viktor Vafeiadis. Genmc: A model checker for weak memory models. In International Conference on Computer Aided Veriﬁcation, pages 427–440. Springer, 2021.</p> </div><div class="field-item even"><a class="anchor" name="reference-56"></a><p>[56] Duo Zhang, Om Rameshwar Gatla, Wei Xu, and Mai Zheng. A study of persistent memory bugs in the linux kernel. In Proceedings of the 14th ACM International Conference on Systems and Storage, SYSTOR ’21, New York, NY, USA, 2021. Association for Computing Machinery.</p> </div><div class="field-item odd"><a class="anchor" name="reference-57"></a><p>[57] Yuchen Zhang, Yunhang Zhang, Georgios Portokalidis, and Jun Xu. Towards understanding the runtime performance of rust. In Proceedings of the 37th IEEE/ACM International Conference on Automated Software Engineering, ASE ’22, New York, NY, USA, 2023. Association for Computing Machinery.</p> </div><div class="field-item even"><a class="anchor" name="reference-58"></a><p>[58] Hongyu Li, Liwei Guo, Yexuan Yang, Shangguang Wang, and Mengwei Xu.&nbsp;An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise. In 2024 USENIX Annual Technical Conference (ATC'24).&nbsp;<a href="https://www.usenix.org/conference/atc24/presentation/li-hongyu">https://www.usenix.org/conference/atc24/presentation/li-hongyu</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">Operating Systems</li>
                                                    <li class="category">Programming</li>
                                                    <li class="category">Linux</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/interview-arnold-robbins"
                    >Interview with Arnold Robbins</a>
                </h2>

                                    <time datetime="2024-06-27 00:00:00">
                        2024-06-27 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Rik Farrow</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Arnold (Aharon) Robbins has just received the <a href="https://www.usenix.org/about/awards/flame" target="_blank" title="USENIX Flame award">USENIX Flame</a> for his contributions to the USENIX community over the last several decades. Although Arnold and I have never met until now, I found exchanging emails for this interview easy to do, as if we had known each other for years. I guess some of that is the Unix effect.</span></p><p><span>Arnold has written or revised over a dozen books, including the documentation for <strong>gawk</strong>, GNU <strong>awk</strong>. He is also the maintainer of <strong>gawk</strong>.</span></p><p> </p><p><span>Rik Farrow: What was your first Unix system?</span></p><p><span>Arnold Robbins: I was first exposed to Unix in 1980 on a PDP-11/70 running a V6 variant (IS/1 from Interactive Systems).  I was exposed to C at the same time.</span></p><p><span>I read the K&amp;R C book (first edition), and found that my head was swimming with all the details; it was one of the densest books I'd ever read.  I then re-read the book, and everything clicked. I fell in love with C.</span></p><p>At the same time, I was also exposed to Kernighan &amp; Plauger's <em>Software Tools</em>.  That book changed my life!  It turned on all the lights for what the various Unix tools were and how to really use Unix to the fullest. In particular, regular expressions and <strong>grep</strong> and <strong>ed</strong>, but also <strong>sort</strong> as a key way to organize data for further processing.</p><div><p><span>My first <em>personal</em> Unix system was an AT&amp;T 3B1, the slightly bigger brother of the "Unix PC".  Both had an MC 68010 with virtual memory, a System V-based kernel, and a kludgy shared library implementation which was mainly for use by the C library. The final userland for it had some bits from System V Release 2.</span></p><p><span>The 3B1 had room for a larger disk; eventually I had a 67 Meg disk and I seem to recall 2 megabytes of memory. It was amazing how much you could do with what today is considered miniscule quantities of memory and storage.</span></p><p><span>The 3B1 had a funky windowing system with a three-button mouse, a great keyboard, and a built-in 1200 baud modem.  I was part of a group of unixpc/3B1 owners who set up our own UUCP-based network. Initially this was with the built-in modem; later we used Telebit trailblazers and worldblazers. (Remember those? :-)</span></p><p>I spent many happy hours on that system working on <strong>gawk</strong> and its documentation. (I was single. :-)</p><div></div><div><span><p><span>Phil Pemberton has a lovely 3B1 emulator available at <a href="https://github.com/philpem/freebee" target="_blank" title="3B1 emulator" rel="nofollow">https://github.com/philpem/freebee</a> for anyone who wishes to journey into the past. There are links there to a drive image I made for it a while back.</span></p><p><span>Later on, I donated that machine to a charity and got a small Sun Sparcstation, and from there I moved on to GNU/Linux.</span></p><div></div></span></div></div><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: How did you get involved in doing service to the community, like working on <strong>gawk</strong>?</span></p><p><span>I had always had something of a (small) flare for languages, doing well in French in high school, and getting higher scores on the English SAT than on the Math one.</span></p><p><span>When I started studying Computer Science, I found programming languages, compilers and interpreters to be of particular interest.</span></p><p><span>I had read the original V7 paper on <strong>awk</strong>, but found the language described to be too hard to wrap my head around, so I largely ignored it.</span></p><p><span>However, in October of 1987, I came across <em><a href="https://en.wikipedia.org/wiki/The_AWK_Programming_Language" target="_blank" title="Wikipedia on AWK Programming Language" rel="nofollow">The AWK Programming Language</a></em> in a bookstore. I bought the book and read it and finally "grokked" <strong>awk</strong>. The book described "new" <strong>awk</strong>, which wasn't so easily available at the time, and (a) knowing about the GNU Project, (b) having an interest in languarges, and (c) being single with lots of spare time, I decided to see if there was a GNU version of <strong>awk</strong> out there to play with.</span></p><div><p><span>There was, but it was a buggy clone of the original <strong>awk</strong>. I got in touch with the GNU project about updating it to match "new" <strong>awk</strong> and was told that someone else </span><span>— </span>a nice guy named David Trueman — had already volunteered to do that, but that I could join in if I wanted.  I got in touch with David, we set up UUCP links, and got to work.  For a long time we exchanged diffs via email. We met in person a time or two at USENIX conferences.</p><p><span>David did most of the heavy lifting converting <strong>gawk</strong> to match new <strong>awk</strong>, although I contributed bug fixes and some features, and I started to work on improving the manual.  The existing manual was bare-bones, at about 90 pages. Today it's about 600 or so and has been published, first by Specialized Systems Consultants (SSC), later by O'Reilly.</span></p><p><span>In the fall of 1993 David had to drop out, and I took over as sole maintainer. Even then, there were contributors who helped in the porting. If I recall correctly, MS-DOS was the first port and Vax/VMS was the second. Even today, OpenVMS is still supported!</span></p></div><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: Was there an inflection point of some sort during <strong>gawk</strong>'s development?</span></p><p><span>AR: Initially, people used <strong>gawk</strong> alongside Unix <strong>awk</strong> and <strong>nawk</strong> (new <strong>awk</strong>).  Even in the early days, though, the GNU "no arbitrary limits" principle was in place, and sometimes this made a difference. For example, in the mid-90s sometime, Rick Adams at UUNET was in touch with me. He used <strong>gawk</strong> to do his accounting, because Unix <strong>awk</strong> just fell over and died on the amounts of data he had to process.</span></p><p><span>The "inflection point", though, came with the creation of GNU/Linux distributions.  It was one thing when <strong>gawk</strong> was used alongside Unix <strong>awk</strong>.  It was a whole 'nother ball game when <strong>gawk</strong> became <em>the</em> <strong>awk</strong> on a user's system.  During Linux's initial few years, <strong>gawk</strong> really stabilized and became much more "production" quality.</span></p><p><span>I would also say that this is the point when what I was doing became a real service to the community.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: You've been the maintainer of GNU <strong>awk</strong> for many years. Maintaining open source software tools seems to me like a source for receiving criticism from people who have ideas they aren't willing or able to implement themselves. How do you handle that?</span></p><p><span>AR: Sometimes I handle it better than at other times. This is an issue that plagues other Free Software maintainers; Chet Ramey (of Bash fame) and I discuss this stuff a lot.  The attitude of "it's Free Software, so you work for me" is not uncommon, and ranges from annoying to distressing to making you wonder why you continue to bother. In other words, being a BDFL (Benevolent Dictator For Life, a term coined by Guido van Rossum) isn't always everything it might be cracked up to be.</span></p><p><span>Now is also an opportunity to mention <a href="https://xkcd.com/2347/;" rel="nofollow">https://xkcd.com/2347/;</a> sometimes I feel like I'm the guy he's talking about.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/dependency.png?itok=lrGaMQlc" width="385" height="489" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Dependency: https://xkcd.com/2347/</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In 2012, Chet and I co-wrote <em>An Open Letter To Those of You Who Are Unhappy</em>, available at <a href="https://www.skeeve.com/fork-my-code.html" title="https://www.skeeve.com/fork-my-code.html" rel="nofollow">https://www.skeeve.com/fork-my-code.html</a>. Not that it helped a whole lot...</span></p><p><span>More recently, I have simply stopped posting in comp.lang.awk, as the level of discourse there is stunningly low.  There is no "awk community" like there is for Perl, Python, Ruby, Go or Rust.  In some ways this is sad. In others, it's OK, as I don't have the cycles for more than what I'm doing now.</span></p><p><span>As another example, there was (and still is) an extremely annoying user.  I was almost at the point of giving up on maintainership due to him.  Instead, I repurposed the "bug reports for <strong>gawk</strong>" list to be bug reports only, and started a "help for <strong>gawk</strong>" mailing list, <em>which I don't read</em>. I then pointed him to it. He sends his requests there, and other people deal with him. And I am considerably happier.</span></p><p>Even more recently, another user was so obnoxious that I had the GNU people block his access to the <strong>gawk</strong> lists.</p><p>Fortunately, these people are fairly few, and every once in a while, out of the blue, I get a "<strong>gawk</strong> is wonderful, I couldn't manage without it" kind of email from a random user out in the world. Those emails make my day, and help me keep going.</p><div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: What lessons have you learned maintaining <strong>gawk</strong> that you wish you had understood earlier on?</span></p><p>I'm glad you asked me that.</p><p>1. Just because someone asks for a feature, it doesn't mean that you have to add it.  It took me a while to figure out that often, when someone says "<strong>gawk</strong> needs XXX", it means "<em>I</em> want <strong>gawk</strong> to do XXX".  But XXX may not be worth doing.</p><p>2. Once a feature goes in, it won't come out. So be <strong><em>careful </em></strong>about adding features. In the early days, adding features is easy, and provides an outlet for one's creativity. This makes it <em>fun</em>.</p><p>But over time, features accrue, and they start to interact with one another in unexpected ways (C++ syndrome), and the accumulated baggage of code (and documentation!) makes the program too large for one person to maintain well. This also raises the barrier of entry for new contributors.</p><p><span>I have to say that this is one of areas where the original Bell Labs people stood out: <em>they knew when to stop</em>. It seems that almost nobody else in the software world does.</span></p><p><span>3. Be careful what you let other people contribute, particularly if it causes significant upheaval in the code. <em>You</em> are still the maintainer, and have final responsibility for the code. That contributor might leave the project, leaving you holding the bag. This happened. I survived, but it wasn't pleasant for the first several years.</span></p><p>4. You can't please everyone, so don't try to. We talked about this some earlier.</p><p>5. Be sure you like the project, you may end up as the BDFL! If you'd told me 36 years ago that I'd still be working on <strong>gawk</strong>, I'd've been pretty surprised, and probably would have said, "nah! that's unlikely". On the other hand, <strong>gawk</strong> led me to my writing career, for which I'm grateful.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: Writing books is more a labor-of-love most of the time than a profitable enterprise. Yet you have written or revised over a dozen books. Tell us about that, please.</span></p><p>AR: My writing indeed started out as a labor-of-love: working on the <strong>gawk</strong> manual. One of the goals of the GNU Project was always to have good free documentation along with the code.</p><p>At some point, I acquired a copy of O'Reilly's <em>sed &amp; awk</em>, written by Dale Dougherty. I think I was thinking I might learn something, or I wanted to see what it said. As I read, I marked up things that were incorrect.  When I was done, I got in touch with Professor Eugene Spafford at Purdue to ask who at O'Reilly I could send the book to.  Gene and I had been in grad school together at Geogia Tech, and he had co-written a popular O'Reilly book on Unix security.  In any case, I sent the marked-up book on to O'Reilly and then more or less forgot about it.</p><p>Sometime later, they contacted me and asked if I would be interested in revising the book, as Dale didn't have the cycles. I said "sure, please find the marked up copy and send it back to me." They did, and I revised the book.  Although I signed a contract for royalties, I wasn't expecting it to make much of a financial difference in my life.</p><p><span>The first royalty check was a big surprise. It was <em>much</em> larger than anything I expected.  This was early in 1997, before everyone just searched on the Internet, and the book business was quite profitable!</span></p><div><p><span>At that point, I said, "Gee, do you have any more books that need updating?" I was moving out of the US and knew I'd have some free time. So I signed contracts to update their <em>Learning vi</em> book, and then to revise <em>UNIX In A Nutshell</em>.</span></p><p><span>After I moved to Israel, I found that start-up companies were where the interesting jobs were, but they also expected 60-80 hour weeks. I was making enough money writing that I just decided to do that full time instead. I was able to support myself and my family for several years, until a little after the first Internet bubble burst. I had to go to work at a day job early in 2005.</span></p><p><span>I've kept my hand in the writing, but at a much reduced level. The most recent was a revision of the <em>Learning the vi and Vim editors</em> published a few years ago. And right now I'm working on a new edition of another of my books.</span></p><p><span>Writing is enjoyable, but it is definitely work. I think that there is still a lot of value in a well-organized, well-written technical book that you can't get out of searching the Internet.  Sadly, it seems that the younger generation of developers don't necessarily realize this.</span></p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: Do you want to tell me about the <strong>gawk</strong> manual, which sounds like a very long book in itself?  I think that started before your book revising projects.</span></p><p><span>AR: Yes indeed. I had to go back to my bookshelf to see what the FSF had done with the manual.  They published six editions: October of 1989, October of 1991, October of 1992, August of 1993, January of 1996 and January of 1998.  It goes without saying that they didn't pay me any royalties, as their publications help them raise money, and I was fine with that.  It's interesting that the first one they published came out about a year after I first found <em>The AWK Programming Language</em>. It was a productive time for me.</span></p><p><span>Sometime in the late 80s or early 90s I'd met Phil Hughes of SSC, I think at a USENIX conference. SSC had a booming business in <strong>vi</strong>, <strong>sh</strong>, and other fold out reference cards, and Unix instruction and consulting.  At some point, I offered to turn their <strong>sh</strong> card into one for <strong>ksh88</strong> (and later also for <strong>ksh93</strong>).  This worked out, and I started getting some money from them.  This was really my first venture into getting paid for writing.</span></p><p>In the mid-90s, "real" publishers wouldn't touch a book with a "free to copy" license like the <strong>gawk</strong> manual had (I had tried with O'Reilly and Pearson).  Howewver, late in 1995, I got Phil to read the book and he agreed that it was worth publishing. It came out in January of 1996 as <em>Effective AWK Programming</em>.  We published a second edition, this time with an included AWK reference card, in 1997.  I continue to update the <strong>troff</strong> source for the card; it's part of the <strong>gawk</strong> distribution.</p><p><span>It also helped the relationship with SSC that they were in Seattle, where my wife is from; I was able to visit them in person a few times when visiting family there.  Phil even lent me a Linux laptop one time so that I could do some book work while in Seattle.</span></p><div><p><span>For comparison, my work with O'Reilly started around 1996; the update of <em>sed &amp; awk</em> came out in the spring of 1997.</span></p><p><span>SSC then started to switch its focus to Linux Journal, and my relationship with O'Reilly continued to ramp up.  In May of 2001 O'Reilly published the third edition of <em>Effective AWK Programming</em>; by then they had a few other free (as in freedom) books and were more open to the idea. A percentage of the royalties went to the FSF, as well.</span></p></div><div><p><span>As I mentioned, in 2005 I went back into the working world, but I continued to maintain <strong>gawk</strong> and its manual. In March of 2015, O'Reilly published the fourth edition of <em>Effective AWK Programming</em>.</span></p></div><p><span>As <strong>gawk</strong> has acquired features, so too the book has grown. I think that both <strong>gawk</strong> and the book are as feature-complete as I can make them, although I do eventually want to publish one more edition of the book, as some of it could use reworking.</span></p><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: Do you think that Unix exists any longer? There are the BSDs, the true descendents of V7, and MacOSX still has FreeBSD embedded in there.  Linux, well, Linux is Unix-like, but like GNU, it's not Unix. And at over 400 system calls and about 25 millions LOC, Linux seems a far ways away from the roots of Unix and the simplicity of the early versions of the OS.</span></p><p><span>AR: This isn't a simple question. Today's computers aren't the PDP-11s and Vaxen of yesteryear, and Linux runs on everything from cell phones to home routers to laptops to desktops to servers to supercomputers with hundreds of cores.</span></p><div><p><span>A guy I know, Dan Forsyth, long ago stated to me: "Elegance is power cloaked in simplicity".</span></p></div><p><span>If we define "Unix" as: "An elegant system that can solve current problems yet be easily understood in its totality", then I'd have to point at Plan 9.</span></p><p>I'm not familiar with any of the BSDs, so I don't know how they stack up in terms of number of system calls and code size.</p><p>I'll also point out that, practically speaking, nobody really wants a V7 PDP-11 as their daily driver. I like having networks, windowing systems, streaming video, and yes, command-line editing in my shell.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>RF: Speaking of Unix philosophy, of keeping things simple and elegant, </span><strong>systemd</strong> is in the news again. Not just for wanting to <a href="https://www.theregister.com/2024/06/13/version_256_systemd/" target="_blank" title="The Reg on run0 and systemd" rel="nofollow">replace <strong>sudo</strong> with its own builtin run0</a>, but with a command that when run <a href="https://www.phoronix.com/news/systemd-tmpfiles-purge-drama" target="_blank" title="systemd tmpfiles purge" rel="nofollow">deletes your home directory</a>. There's a very long <a href="https://www.tuhs.org/pipermail/tuhs/2024-June/030054.html" target="_blank" title="systemd and Unix philosophy" rel="nofollow">thread</a> about this on The Unix Heritage Society's mailing list.</p><p><span>AR: It's clear that current developers aren't being taught "the Unix philosophy" and thus don't appreciate it. It's also clear that modern systems have to deal with many more complicated things than the early Unix systems did.  I'd like to think that there's a happy medium that will be reached one day, but I don't know how to make that happen.</span></p><div><p><span>Personally, I don't like <strong>systemd</strong>. But (as I wrote on TUHS), I also don't care enough to go out and find another system. I've been using Ubuntu at (different) day jobs since Ubuntu 10.04, and at home since at least Ubuntu 12.04, maybe even 10.04.  I've been using Ubuntu Mate for at least eight years.  It "just works", and that's what's most important to me.  I still have a day job, kids living at home, Free Software to maintain, books to write, etc.. I don't want to waste time creating "Ubuntu Mate minus systemd", since I don't have that time available in the first place.</span></p><p><span>If I were running a bunch of big servers, would I feel differently?  Probably. Fortunately, I'm not in that situation.</span></p></div><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>RF: Anything else?</p><p>Just "thank you again" to USENIX for the Flame award, and thanks to you for the interview. I enjoyed it.</p></div></div></div>  </div> </div> </div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Programming</li>
                                                    <li class="category">Culture</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/understanding-and-improving-web-application-fingerprinting-wasabo"
                    >Understanding and Improving Web Application Fingerprinting with WASABO</a>
                </h2>

                                    <time datetime="2024-06-27 00:00:00">
                        2024-06-27 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Nick Nikiforakis</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We all know the importance of keeping software up-to-date in defending against attacks. Some of the most catastrophic security incidents (such as, the 2017 Equifax hack affecting approximately 150 million users <a href="#reference-1" rel="nofollow">[1]</a>) were the result of unpatched vulnerabilities. Similarly, our own past research has demonstrated that, just by existing, web applications receive hundreds of attack probes on a daily basis <a href="#reference-2" rel="nofollow">[2]</a>,<a href="#reference-3" rel="nofollow">[3]</a>. This need to keep software up to date, begs the following question: how can we tell the version of a piece of software?<br /><br />When we consider a single machine, the answer is straightforward: log-in to that machine and check the version of the software in question. What happens, however, when we need to answer that question, not for a single machine for which we have access to, but for potentially tens of thousands of machines of a large organization? To make things more interesting, these machines are not conveniently situated in one place but typically scattered across multiple different departments and administrative domains, without a clear understanding of who is responsible for what machine.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Why fingerprint?</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>"Fingerprinting" is an overloaded term in computer security, which can refer to fingerprinting browsers, servers, Tor connections, and anything in between. In the context of web applications, fingerprinting refers to being able to establish the type and version of a web application running on a remote server, without having any special access to that server. That is, using web-application fingerprinting, one could discover that a specific web application deployed on one’s network is a 2021 version of WordPress and therefore one that is highly outdated and most likely vulnerable to attacks.<br /><br />In the context of computer security, web application fingerprinting enables the following constructive capabilities:</p><ul><li><strong>Identifying Vulnerabilities:</strong> By knowing the specific version of a web application, administrators and security professionals can determine if it has any known vulnerabilities. This allows organizations to patch these vulnerabilities before they can be exploited by attackers.</li><li><strong>Compliance and Auditing:</strong> Some regulatory frameworks require organizations to maintain an up-to-date inventory of the software running on their systems. Fingerprinting helps automate this process, ensuring ongoing compliance across departments. </li><li><strong>Identifying shadow IT infrastructure:</strong> Information technology resources (software, hardware, devices, and services) can be used within an organization without the knowledge of that organization. Web-application fingerprinting can help uncover these resources which are typically forgotten and therefore often outdated.</li></ul></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">You shall know them by their fruits</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Web application fingerprinting tools analyze the content and behavior of a website to determine which application and what version is being used. These tools generally rely on two main techniques: fingerprinting static content and fingerprinting dynamic content.</p><h4>Fingerprinting Static Content</h4><p>Static content refers to files that do not change in response to user interactions. Examples include JavaScript files, CSS files, image files, and documentation files (e.g., README, Changelog).<br /><br />Fingerprinting tools that focus on static content (such as BlindElephant) typically calculate hashes (e.g. MD5 or SHA256) of these files. By comparing the hashes of files on a target website with a database of known hashes from different versions of web applications, these tools can often identify the application and its version.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/static_fingerprinting_hash.png?itok=0ZlW8b-5" width="919" height="491" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: Change in file wp-includes/js/media-models.js between WordPress versions 5.8 and 5.8.1</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>The above code snippets show an example of web-application fingerprinting using static content. The change of a single digit in a JavaScript file produces radically different hashes which can then be associated with different versions. In this way, if a web application fingerprinting tool finds a file with the <em>3086[...]4df7</em> hash on a target website, it will conclude the web application in question is most likely WordPress version 5.8.1. The more positive matches between file hashes and a specific web application version, the more confident the tool can be of its prediction.</p><h4>Fingerprinting Dynamic Content</h4><p>Unlike static-content fingerprinting which is incidental (i.e. the web application is not trying to communicate any version information through its static files), dynamic-content fingerprinting largely relies on explicit type and version information that is already present in a web application, if one knows where to look. This version information can be present in HTML Meta Tags, version artifacts in local URLs, and any other version information present in the body of arbitrary files served over that web application.</p><p>Here we see three different examples of how a web-application  fingerprinting tool can identify that a target web application is  WordPress by just looking for the right strings in the HTML pages  already served by that web application.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/dynamic_fingeprinting_methods.png?itok=5SDRakPT" width="1005" height="351" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: Examples of potential fingerprinting sources in dynamic content generated by WordPress.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Evaluating web application fingerprinting tools with WASABO</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>While web-application fingerprinting appears straightforward, there are many things we do not know about it. Can these tools actually be used to accurately identify the type and version of a web application? Are there enough differences from version to version for these tools to pick up or is there a large chance of version collisions where a tool cannot differentiate between multiple versions of the same web application? What is the performance difference between ideal conditions (scanning off-the-shelf web applications with as little customization as possible) vs. the real world (scanning real web applications in the wild)? Is it possible to improve the performance of these tools without actually changing their source code?</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/wasabo_architecture.png?itok=XVqLBDrT" width="918" height="716" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3: Architecture of WASABO for evaluating the performance of the web-application fingerprinting tool and improving their accuracy.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>In our recently published paper at USENIX Security 2024 <a href="#reference-4" rel="nofollow">[4]</a>, we designed and developed WASABO to answer these exact questions. WASABO (shown in Figure 3) is a container-based web application testbed system allowing us to stage any version of a web application for laboratory testing of each fingerprinting tool, as well as automate large-scale online fingerprinting campaigns. Using WASABO, we were able to evaluate the performance of six popular web application fingerprinting tools (including BlindElephant, WhatWeb, and Wappalyzer) against thousands of versions of popular web applications (including WordPress and Drupal). For example, WASABO includes containers for 558 WordPress versions, from version 3.5.1 to version 6.1.1 which are used to evaluate the accuracy of the evaluated fingerprinting tools.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Key Findings</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4>Accuracy in Controlled Settings</h4><p>In ideal conditions, where the web applications were freshly installed without any modifications, 94.8% of them were correctly identified by at least one fingerprinting tool. However, the tools often failed to provide a single, definitive version of the application, leading not only to confusion but also to the potential hiding of real vulnerabilities in one’s infrastructure.</p><h4>Security impact of version collisions</h4><p>When multiple versions of a web application produce the same fingerprint, we refer to them as version collisions. In our experiments, we discovered that dynamic-content fingerprinting is less susceptible to collisions since if a version string is not present in a target web application, the tool does not attempt to “guess” the right version (as static-content fingerprinting does). The more versions that are included in a version-collision output, the more difficult it is for an operator to draw any conclusions about the up-to-date status of the scanned web application.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Our most extreme example was the WhatWeb’s fingerprinting tool which,  when scanning WordPress v. 3.7.36 produced versions 3.7, 3.7.1, and  3.7.36 which are 7.5 years apart between the earliest and latest  versions.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>To understand the effect of collisions on vulnerability discovery, we  recorded the 10 most severe CVEs for the evaluated web applications and  assessed the extent to which a version collision involved one of the  affected versions. Through this experiment, we discovered 82 instances  where a vulnerable version of a web application was incorrectly labeled  as a non-vulnerable version. For instance, CVE-2020-13664 was a  high-severity vulnerability in Drupal that allowed remote code execution  affecting Drupal version 9.0.0. One of the evaluated tools produced a  version collision when fingerprinting that vulnerable version of Drupal,  with the collision including versions 9.0.0 and 9.0.1 (the first  version where that vulnerability was patched). Trusting the most recent  version from that prediction would lead to ignoring that vulnerable  deployment in one’s organization.</p><h4>In theory, there is no difference between theory and practice; but in practice, there is.</h4><p>Putting  the issue of version-collisions aside, based on the laboratory  experiments of WASABO, one may be tempted to conclude that these  fingerprinting tools work really well. Yet, the real world is not like  the lab. Users of popular web applications tend to customize them before  releasing them by installing themes and plugins, deleting files they do  not require, and even adopting hardening steps to explicitly counter  unwanted fingerprinting attempts. How do these implicit and explicit  customizations affect the performance of fingerprinting tools?</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>When  we tested the same fingerprinting tools on real-world websites,  their  performance dropped significantly—up to 80% in some cases.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Tools were  unable to detect files to hash, could not identify the  right root  directory from which to request files, could not find  version strings in  pages, and sometimes were detected by anti-bot  solutions which  altogether denied them access to a web application. <br /><br />Our  most  unexpected source of trouble were Content Distribution Networks  (CDNs).  CDNs not only cache files closer to users but can apparently  minify  certain types of files, such as JavaScript scripts, to further  improve a  web application’s performance. In this way, a fingerprinting  tool  receives a minified version of a JavaScript library from the CDN  which  produces no matches in its fingerprint database, and therefore  degrades  its overall performance.</p><h4>Making the ink more potent</h4><p>Given   the severe drop in performance of web application fingerprinting tools   in the wild vs. ideal conditions, we wondered whether it would be   possible to improve that performance. Changing their code to account for   the aforementioned issues was possible but not desirable. Any new   version of these tools would not include our patches and any new tools   that may be released in the future could not benefit from our   improvements.<br /><br />As a result, we decided to include a proxy layer in   WASABO turning it into a form of network middleware. The purpose of   this proxy layer is to change the web requests as they leave the tool   and before they are sent to the web application in a way that counters   the most common reasons of why these tools failed when scanning   real-world applications. Specifically, WASABO applies the following   transformations to improve the accuracy of fingerprinting:</p><ul><li><strong>Cache-Breakers:</strong> Adding random query parameters to requests to bypass caching mechanisms   that might alter the content served to the fingerprinting tool.</li><li><strong>Web Path Prediction:</strong> Analyzing the structure of the target site to predict alternative paths for resources that might have been moved or renamed.</li><li><strong>Real-Browser Requests:</strong> Use a real web browser to make requests instead of the HTTP libraries   used by the fingerprinting tools, thereby bypassing some forms of bot   detection.</li></ul><p>The following table shows not only the drop in   accuracy of different tools when comparing ideal conditions and the real   world (Lab Accuracy vs. Default Columns) but also the improvement of   our tool-agnostic WASABO middleware, increasing their fingerprinting   accuracy by as much as 22.9%. The tools that benefited the most from our   middleware were the ones relying on static fingerprinting techniques   and were therefore the most susceptible to content changes (some of   which WASABO was able to undo).</p><p> </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/tool_performance_wasabo.png?itok=HjFcv0YP" width="1097" height="478" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Performance of each web application fingerprinting tool in guessing the web application type of a set of real world websites, both with and without the intervention of our network middleware module.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusion and takeaways</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Knowing the type and version of a remote web application is incredibly powerful in both a defensive as well as an offensive context. Given accurate fingerprinting tools, defenders can find outdated web applications in haystacks of servers and prioritize their patching. Offensively, attackers can confirm that a remote web application is indeed vulnerable before revealing their exploits to possible intrusion detection systems running at the server side. <br /><br />In this work, we explored not just how web application fingerprinting is supposed to work in theory but to what extent these techniques work in the real world. Through our WASABO system,  we discovered that the current generation of fingerprinting tools (particularly the ones that depend on static fingerprinting vectors) are brittle with the smallest of server-side changes being sufficient to throw them off balance. While this is good news in terms of limiting an attacker’s capabilities, it also limits the usefulness of these tools in the aforementioned defensive context. We also demonstrated how a couple of clever, tool-agnostic request changes can significantly improve the fingerprinting performance of the affected tools.</p><p><br />We are making WASABO available <a href="#reference-5" rel="nofollow">[5]</a> to the community to motivate and support additional research in web-application fingerprinting, both in terms of making it better so that defenders can use it, but also detecting it when it is done in an unauthorized manner.<br /><br /><br /></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Acknowledgements</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>This material is based upon work supported by Office of Naval Research (ONR) under grant N00014-24-1-2193 as well as by the National Science Foundation (NSF) under grants CNS-2211575 and CNS-1941617. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the Office of Naval Research or the National Science Foundation.</span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] How Hackers Broke Equifax: Exploiting A Patchable Vulnerability, Thomas Brewster, <a href="https://www.forbes.com/sites/thomasbrewster/2017/09/14/equifax-hack-the-result-of-patched-vulnerability/" target="_blank" rel="nofollow">https://www.forbes.com/sites/thomasbrewster/2017/09/14/equifax-hack-the-result-of-patched-vulnerability/</a></p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] "<a href="https://www.computer.org/csdl/proceedings-article/sp/2021/893400b353/1t0x9eOdd4s" target="_blank" rel="nofollow">Good Bot, Bad Bot: Characterizing Automated Browsing Activity</a>", Xigao Li, Babak Amin Azad, Amir Rahmati, and Nick Nikiforakis.&nbsp; Proceedings of the 42nd IEEE Symposium on Security and Privacy (IEEE S&amp;P), 2021</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] "<a href="https://www.usenix.org/conference/usenixsecurity22/presentation/kondracki" target="_blank">Uninvited Guests: Analyzing the Identity and Behavior of Certificate Transparency Bots</a>",&nbsp; Brian Kondracki, Johnny So, and Nick Nikiforakis. Proceedings of USENIX Security Symposium (USENIX Security), 2022. NSA Best Scientific Cybersecurity Paper Award 2023.</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] "<a href="https://www.usenix.org/conference/usenixsecurity24/presentation/kondracki" target="_blank">Smudged Fingerprints: Characterizing and Improving the Performance of Web Application Fingerprinting</a>", Brian Kondracki and Nick Nikiforakis. Proceedings of the USENIX Security Symposium, 2024</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] WASABO prototype. Brian Kondracki and Nick Nikiforakis. <a href="https://pragseclab.github.io/smudged-fingerprints/" rel="nofollow">https://pragseclab.github.io/smudged-fingerprints/</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Security</li>
                                                    <li class="category">Network</li>
                                                    <li class="category">Sysadmin</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/telescope-profiling-memory-access-patterns-terabyte-scale"
                    >Telescope: Profiling Memory Access Patterns at the Terabyte-scale</a>
                </h2>

                                    <time datetime="2024-06-26 00:00:00">
                        2024-06-26 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Alan Nair</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>The increasing prevalence of applications with memory footprints over terabytes in size, coupled with the rising popularity of tiered and disaggregated memory systems has generated an urgent need for memory access telemetry that scales well with working set size. We observe that telemetry techniques used in prior work have shortcomings that make them unsuitable for terabyte-scale workloads. We present our key insight that exploits the RADIX-tree structure of the page table to enable fast, precise, and accurate telemetry that works even for terabyte-scale applications at low performance overheads. </span></p><p><span>We leverage this insight in Telescope [<a href="#reference-9" rel="nofollow">9</a>], a novel method to profile memory access patterns of applications. We implement Telescope in the Linux kernel. Our evaluation reveals that Telescope consistently delivers over 90% accuracy and coverage at just 0.9% CPU utilization for workloads with a memory footprint of 5TB, while data tiering (placement into memory tiers) guided by Telescope offers 5.6% to 34% extra throughput over other state-of-the-art approaches on workloads with up to 2TB of memory footprint.</span><span> </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/mod_teaser_2-1.png?itok=3am3LCp1" width="1440" height="525" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 1. Telescope vs other state of the art memory access telemetry techniques.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Terabyte-Scale Applications and Systems </div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><p>Datacenter workloads memory requirements have skyrocketed in recent times. This rise has been fueled by many application domains, including Large Language Models, High-Performance Computing, and large databases. Application datasets commonly exceed terabytes in size [<a href="#reference-7" rel="nofollow">7</a>,<a href="#reference-8" rel="nofollow">8</a>]. Furthermore, these applications prefer to keep their working sets in memory to maximize performance. This trend has been enabled by the emergence of tiered and disaggregated memory systems. Various memory technologies are integrated horizontally and/or vertically to get terabytes of physical memory on a single system. On a tiered memory system, memory is populated in various tiers. The <em>hot</em> <span>tiers</span><span> are placed closer to the processor-and-cache </span><span>hierarchy and</span><span> are composed of technologies that offe</span><span>r high </span><span>b</span><span>andwidth and low access latency, such as DDR-attached memory, or High </span><span>B</span><span>andwidth Memory (H</span><span>B</span><span>M). </span><span>The </span><em>cold</em> <span>tiers are farther away from the processor-and-cache hierarchy and are made of technologies t</span><span>hat offer </span><span>less</span><span> </span><span>b</span><span>andwidth and higher latency, such as Persistent Memory</span><span>, and CXL-attached memory.</span><span> </span><span>Overall, tiered memory </span><span>systems promise</span><span> vas</span><span>tl</span><span>y</span><span> high memory </span><span>capacity</span><span> at</span><span> </span><span>low performance overheads.</span> </p></div><div><p><span><span>Ho</span><span>we</span><span>ver, the </span></span><span><span>tiering</span><span> is only as good as the telemetry</span></span><span><span>. </span><span>Telemetry refers to the </span></span><em>active profiling and identification of the memory access patterns</em><span><em> of a target workload. </em><span>On a tiered memory system, data placement must </span><span>b</span><span>e guided </span><span>b</span><span>y </span><span>accurate </span><span>telemetry, so that the </span></span><span><em>hot data</em>, </span><span><span>or the data that is expected to </span><span>b</span><span>e used soon in the future, gets placed in the </span></span><span>hot </span><span><span>memory </span><span>tiers, while the </span></span><span><em>cold data</em>, </span><span><span>or the data that is not expected to </span><span>b</span><span>e used </span><span>in the near future, stays in the </span></span><span>cold </span><span><span>memory </span><span>tiers.</span><span> </span><span>The telemetry technique should </span><span>identify</span><span> the hot data with </span></span><span>precision</span><span><span>, ideally at the granul</span><span>arity of the page size. Further, the technique must </span><span>b</span><span>e </span></span><span>fast </span><span>and </span><span><span>scala</span><span>b</span><span>le </span></span><span><span>to tera</span><span>b</span><span>ytes of memory footprint. </span><span>Las</span><span>tl</span><span>y, the performance overheads associated with the technique must </span><span>b</span><span>e minimal.</span></span></p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-subtitle field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Tiering is only as good as the telemetry</div></div></div><div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Data placement must be guided by accurate telemetry, so that the </span><span>hot data </span><span>gets placed in the </span><span>hot </span><span>memory tiers, and the </span><span>cold data</span><span> stays in the </span><span>cold </span><span>memory tiers.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Prior Work Does Not Scale to Terabytes of Memory </div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><p><span>Telemetry techniques used in prior work fall under 3 categories. </span><span> </span></p></div><div><ul><li><p><span><strong>Linear Scanning of Page Table Entries (PTEs)</strong></span><span><span> is a common technique to track workload access patterns.</span><span> Each </span><span>P</span><span>TE</span><span> </span><span>contains</span><span> the physical frame number of the indexed page, a</span><span>nd some status bits. These status bits include an </span></span><span>ACCESSED </span><span><span>bit.</span><span> On every </span><span>Page Table Walk</span><span>, the hardware page table walker sets the </span></span><span>ACCESSED </span><span><span>bit in the PTE</span><span>. Thus</span><span>, checking this bit in a PTE is enough to </span><span>ascertain</span><span> whether the page was accessed since </span><span>it was mapped</span><span>, or since the last time when the bit was reset</span><span>.</span></span><span><span> </span><br /></span><span><span>In this telemetry, all the mapped PTEs of a workload are scanned periodically</span><span> by a thread</span><span>.</span><span> The thread is awoken every</span><span> few milliseconds to perform a scan, completing which, it goes back to sleep.</span><span> </span><span>During each scan, t</span><span>he </span><span>PTEs’</span><span> </span></span><span>ACCESSED </span><span><span>bits are checked, and then reset, clear</span><span>ed so that they may be set by the page table walker on the next access</span><span>.</span><span> </span><span>Therefore</span><span>, on each scan, the thread </span><span>identifies</span><span> </span><span>the </span><span>pages that were accessed via a pa</span><span>ge walk since the last scan. This telemetry technique is used by various tools in the Linux kernel such as </span></span><span><em>kstaled</em><span> </span></span><span>and </span><span><em>MGLRU (Multi-Generation LRU lists)</em><span> </span></span><span><span>[</span><span><a href="#reference-3" rel="nofollow">3</a></span><span>]</span><span>. </span></span><span><span> </span><br /></span><span><span>Th</span><span>is technique, though simple, does not scale well as the number of PTEs used by a</span><span>n application becomes </span><span>large</span><span>.</span><span> </span><span>We </span><span>find that</span><span> even with </span><span>nearly 50%</span><span> CPU </span><span>utilization</span><span>, over 20 seconds are needed to complete one full linear scan of all the PTEs</span><span> belonging to an application with a memory footprint of 1TB.</span></span><span> </span></p></li></ul></div><div><ul><li><p><span><strong>Region-Based Sampling</strong></span><span><span> is an enhancement over the linear-scanning technique</span><span>, that quickens the convergence time</span><span> </span><span>b</span><span>y reducing the num</span><span>b</span><span>er of PTEs t</span><span>o scan. The mapped address space of a workload is divided into contiguous </span></span><span>regions. </span><span><span>Each region </span><span>maintains</span><span> its own </span></span><span>access counter. </span><span><span>O</span><span>ne PTE </span><span>is </span><span>sampled from each region. Every few milliseconds, the sampled PTEs are checked to see if their </span></span><span>ACCESSED </span><span><span>b</span><span>its are set</span><span>. If so, the </span><span>access counter is updated for the corresponding region. Then a new PTE is sampled from each region for the nex</span><span>t round. A</span><span>b</span><span>out every 100 sampling rounds, </span><span>regions are split or merged, </span><span>b</span><span>ased on their access counts. This</span><span> repeated</span><span> spl</span><span>it-and-merge</span><span> paradigm ensures that over time</span><span> (typically in a few seconds for a giga</span><span>b</span><span>ytes-large working set), the region</span><span> </span><span>b</span><span>oundaries and their corresponding acces</span><span>s </span><span>counts can </span><span>b</span><span>e used to </span><span>classify</span><span> data into </span></span><em>hot </em><span>and </span><em>cold </em><span><span>sets.</span><span> The most </span><span>we</span><span>ll-known example of a tool that uses region-</span><span>b</span><span>ased sampling is DAMON [</span><span><a href="#reference-4" rel="nofollow">4</a></span><span>]</span><span> which is now a part of the Linux kernel.</span></span><span><span> </span><br /></span><span><span>Our experiments reveal that</span><span> DAMON is utterly ineffective when </span><span>the target application’s working set exceeds 100</span><span> </span><span>G</span><span>B</span><span>s of 4</span><span> </span><span>K</span><span>B</span><span> pages.</span><span> This is </span><span>b</span><span>ecause when the num</span><span>b</span><span>er of pages per region is quite high, </span><span>the likelihood that the access pattern of a sampled page accurately reflects that of its entire </span><span>region</span><span> is quite low.</span><span> Increasing the num</span><span>b</span><span>er of regions </span><span>re</span><span>introduces the same </span><span>sluggishness and resource </span><span>utilization</span><span> overheads that afflict techniques </span><span>b</span><span>ased on linearly scanning PTEs.</span></span><span> </span></p></li></ul></div><div><ul><li><p><span><span><strong>Performance Monitoring Unit (PMU)</strong></span> counters</span> are hardware counters present in some architectures that can count events such as Last Level Cache (LLC) misses, Translation Lookaside Buffer (TLB) misses, and so on. When the counter overflows, an interrupt gets triggered which writes the hardware state to a memory buffer. Prior works [<a href="#reference-1" rel="nofollow">1</a>,<a href="#reference-5" rel="nofollow">5</a>,<a href="#reference-6" rel="nofollow">6</a>] have used event samples collected via PMU counters to identify hot and cold data. An example of this is Intel’s Processor Event-Based Sampling (PEBS).<span> </span><br /><span>The main drawback of this approach when used on terabyte-scale applications is the associated performance degradation. </span><span>A</span><span>ccurately pr</span><span>ofil</span><span>ing</span><span> memory access patterns</span><span> </span><span>necessitates</span><span> a high sampling rate, </span><span>and </span><span>consequently</span><span> </span><span>many</span><span> </span><span>interrupts</span><span>. This may result in significant slowdowns in the target application</span><span>.</span> </p></li></ul></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Telescope</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><p>Here we present some key background followed by the insight behind Telescope, our novel memory access telemetry technique. We then discuss its design and implementation details.</p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h3><span>The Radix-Tree Structure of the Page Table</span><span> </span></h3></div><div><p><span><span>Virtual memory is implemented via a data structure called the page ta</span><span>b</span><span>le which must </span><span>b</span><span>e searched (or ‘walked’) to find the physical page </span><span>address given a virtual address. Most architectures implement the page ta</span><span>b</span><span>le as a multi-level radix tree</span><span> of PTEs</span><span>.</span><span> On a 64-</span><span>b</span><span>it x86 machine, the page ta</span><span>b</span><span>le can have 4 or 5 levels</span><span>, with 512 PTEs packed into a page</span><span>.</span></span><span> </span><span> </span></p></div><div><p><span><span>On a </span><span>TL</span><span>B</span><span> miss, the hardware page ta</span><span>b</span><span>le walker reads PTEs from each level of the page ta</span><span>b</span><span>le from the highest to lo</span><span>we</span><span>st level to reach the physical page pointed </span><span>b</span><span>y a virtual address, </span><span>b</span><span>y treating chunks of the virtual address a</span><span>s offsets to index into the next level PTE</span><span>.</span><span> </span><span>This mechan</span><span>ism is depicted in Figure 2. </span><span>For each PTE in higher levels of the page ta</span><span>b</span><span>le, the page ta</span><span>b</span><span>le walker reads the</span><span> </span><span>address of the next-lo</span><span>we</span><span>r PTE, and updates the status </span><span>b</span><span>its</span><span> (including the </span></span><span>ACCESSED </span><span><span>b</span><span>its)</span><span>, and then reads the next-l</span><span>evel PTE.</span></span><span> </span></p></div><div><p><span><span>One corollary of the a</span><span>b</span><span>ove mechanism is that if the </span></span><span>ACCESSED </span><span><span>b</span><span>it is not set in a PTE at the </span><span>higher level, then none of the PTEs in the level</span><span>s</span><span> </span><span>b</span><span>eneath</span><span>,</span><span> </span><span>which</span><span> are indexed </span><span>b</span><span>y </span><span>that PTE,</span><span> will have that </span><span>b</span><span>it set.</span><span> Therefore, </span></span><span><span>on a system which packs 512 PTEs into a page</span><span>, if </span><span>we</span><span> </span><span>check the </span></span><span><span>ACCESSED </span></span><span><span>b</span><span>it at the second level of the page ta</span><span>b</span><span>le, th</span><span>e total num</span><span>b</span><span>er of PTEs to </span><span>b</span><span>e scanned to cover the entire mapped address space reduces</span><span> </span><span>b</span><span>y</span><span> 512x </span><span>relative</span><span> to </span><span>the case where </span><span>the scanning happened at the</span><span> first (or the</span><span> lo</span><span>we</span><span>st</span><span>)</span><span> level</span><span>.</span></span><span><span> </span><span>T</span><span>he spatial granularity at which accesses to data are detected also </span><span>b</span><span>ecomes coarser </span><span>b</span><span>y 512x.</span><span> </span><span>Similarly, at the (n+</span><span>1)</span></span><span><span><sup>th</sup></span></span><span><span> </span><span> level, </span><span>the num</span><span>b</span><span>er of PTEs to </span><span>b</span><span>e scanned is 51</span><span>2</span></span><span><span><sup>n</sup></span></span><span><span> </span><span>times</span><span> less, and the granularity at which accesses to data are detected is </span><span>512</span></span><span><span><sup>n</sup></span></span><span><span> </span><span> times</span><span> more, compared to </span><span>scanning at the lo</span><span>we</span><span>st level of the page ta</span><span>b</span><span>le.</span><span> This is the key insight that drives the design of Telescope.</span></span></p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/radixtree.drawio.png?itok=eEEXcPgE" width="931" height="661" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 2. A Four-level Radix Tree Page Table with 8-bit PTEs and 4 KB base page size can fit 512 entries at each level. The red, blue, and green arrows show the paths taken by the page walks triggered by the virtual addresses VA1, VA2, and VA3, respectively. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h3>Telescope Design </h3></div><div><p>We use the above insight to augment region-based sampling. For a large region, tracking the ACCESSED bits at a higher level of the page table allows quicker convergence and better coverage. For a small region, tracking the bits at a lower level of the page table allows for precise convergence. By dynamically adjusting the level of the page table where the PTE’s ACCESSED bit is tracked (called the ‘profiling level’), our novel approach Telescope, can ‘<em>zoom</em>’ out of and into the address space by profiling at higher and lower levels, respectively. </p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h4>Profiling </h4></div><div><p>For each region, every sampling period (typically a few milliseconds), we sample an address at random. We identify the highest level of the page table where the area covered by the PTE corresponding to this address falls within the bounds of the region. Each time we find that the ACCESSED bit was set, we update the region’s access count. If there are 512 PTEs per page, a set ACCESSED bit at a lower level begets an access counter increment that is 512 times the increment corresponding to the next higher level.  </p></div><div><p>Figure 3 shows an example of how this works. For Sampled Address 1, the corresponding L1 PTE is the highest PTE whose covered area falls within the region bounds. Similarly, for Sampled Address 2, the profiling level is L2. </p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/telescope.drawio.png?itok=63Sle_db" width="672" height="459" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 3. In Telescope (Bounded variant), the profiling level is the highest level at which the area covered by the PTE corresponding to the sampled address falls within the region bounds. </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h4>Region Management </h4></div><div><p>To converge to the correct access pattern, Telescope must ensure that region boundaries get finer over time. </p></div><div><p>Telescope’s region management is inspired by that of DAMON. Initially, the workload’s Virtual Memory Areas (VMAs) are scanned to obtain the initial set of regions. This is done every few seconds to capture new memory allocations. Before every region-update-interval (typically 100 milliseconds), DAMON splits each region into two smaller regions. After the region-update-interval, DAMON merges all adjacent regions with similar access counts. </p></div><div><p>We make the following changes to merging/splitting heuristic. If more than half a region’s size is covered by one PTE (at level n+1), then it must be split into smaller regions each covered by one PTE at level n of the page table. Else, the region must be broken into smaller regions each covered by one PTE at level n+1 of the page table. Similarly, a merge proceeds by applying the above split conditions in reverse order, provided the presence of adjacent smaller regions with similar access counts. </p></div><div><p><span>This algorithm ensures that regions with non-uniform access patterns within will stabilize over time, into smaller sub-regions that align with the boundaries of the actual access patterns. Telescope converges to the right access pattern over time, starting from a coarse granularity (a higher profiling level), and going to finer granularities (lower profiling levels) if needed.</span><span> </span><span> </span></p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-subtitle field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Telescope selects the profiling level dynamically</div></div></div><div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Telescope starts profiling at higher levels with coarse granularity. As regions get smaller, Telescope profiles at lower levels with fine granularity.</span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h4>Bounded and Flexible Variants </h4></div><div><p>The scheme outlined above is the Bounded variant of Telescope. In addition, we present a Flexible variant that sacrifices accuracy for better coverage. In contrast to the Bounded variant, the Flexible variant can pick a PTE at a higher profiling level whose covered address space shoots over the region boundaries. The proportion of area covered by the PTE that falls outside the region boundary must be less than an error threshold. This error threshold can be configured independently at each level of the page table. The Flexible variant would be useful for simple access patterns with contiguous hot sets. </p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h4>MGLRU + Telescope </h4></div><div><p>Multi-Generational Least Recently Used (MGLRU) [<a href="#reference-3" rel="nofollow">3</a>] is an algorithm implemented in the Linux kernel that uses linear-scanning-based telemetry to maintain multiple generation LRU lists instead of the typical ‘active’ and ‘inactive’ lists used in the classical OS implementation of LRU. Each MGLRU scan starts by creating a new generation LRU list. In every scan, frequently accessed or hot pages are moved to newer generations, while cold pages are “aged” to “old generation” LRU lists. Pages in the older generation LRU lists are considered for placement in the cold tier to reclaim space on the hot tier. </p></div><div><p>We augment MGLRU with Telescope’s profiling technique to make it effective for memory reclaim on terabyte-scale workloads. </p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h3>Implementation </h3></div><div><p>We implement Telescope in Linux v6.6.3. We reuse the logic introduced by DAMON, making changes wherever needed. Our patch is in the process of being pushed to the mainline Linux kernel [<a href="#reference-2" rel="nofollow">2</a>].</p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Evaluation</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><p><span><span>We </span><span>evaluate</span><span>d</span><span> </span><span>both the Bounded and Flexible variants of </span><span>Telescope against </span><span>DAMON and PEBS</span><span>.</span><span> </span><span>We </span><span>adjust</span><span>ed</span><span> </span><span>DAMON’s </span><span>sampling intervals</span><span> to 1ms and 5ms</span><span> respectively</span><span>, and PEBS’ event sampling frequency</span><span> to 5kHz and 10kHz</span><span> respectively</span><span>,</span><span> </span><span>to create </span></span><span>aggressive </span><span><span>(</span><span>more resource-intensive</span><span>)</span><span> and </span></span><span>moderate </span><span><span>(less resource</span><span>-intensive</span><span>)</span><span> variants</span><span> of both.</span><span> </span><span>We </span><span>also evaluate</span><span>d</span><span> </span><span>MGLRU+Telescope</span><span> against vanilla MGLRU.</span></span></p></div><div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h3>Setup and Benchmarks </h3></div><div><p>We used a tiered memory system with an Intel Xeon Gold 6238M CPU having 4 sockets, 22 cores per socket, and 2-Way HT for a total of 176 cores. It has a DRAM-based hot memory tier with 768 GB capacity and a cold memory tier with Intel’s Optane DC Persistent Memory Modules configured in flat mode (as volatile main memory) with 6 TB capacity for a total of 6.76 TB physical memory. The server runs Fedora 30 on Linux v5.18.19 with 4 KB pages. We used the Memcached and Redis key-value stores as benchmarks. On both, we ran two different load patterns, generated from Memtier and YCSB, respectively. The details of these are outlined in Table 1.</p></div><div><p>The workloads’ initial memory footprint was initialized in the Optane NVM cold tier using interleaved memory allocation policy. DAMON and Telescope output a list of regions and their access counts every 200ms which is also the region update interval. From PEBS, we collected samples of retired loads and stores every 200ms and converted them into a list of 2MB regions (2MB aligned), with access counts proportional to the number of samples that generate this address. We used 2MB as the region size as this has been used by prior work that utilizes PEBS [<a href="#reference-1" rel="nofollow">1</a>]. We considered regions with 5 or more accesses in the last 120 secs as HOT. Hot regions with size 4GB or less were migrated from Optane to DRAM in descending order of access counts. Up to 10GB of data may be migrated in one round.</p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table>     <tr>         <th>Parameter</th>         <th>Memtier</th>         <th>YCSB</th>     </tr>     <tr>         <td>Memory Footprint</td>         <td>1 TB</td>         <td>2 TB</td>     </tr>     <tr>         <td>Number of Keys</td>         <td>200,000</td>         <td>1,000,000</td>     </tr>     <tr>         <td>Value Size</td>         <td>5 MB</td>         <td>2 MB</td>     </tr>     <tr>         <td>Number of Threads</td>         <td>170</td>         <td>170</td>     </tr>     <tr>         <td>Execution Time</td>         <td>40 minutes (150 s warmup)</td>         <td>40 minutes (150 s warmup)</td>     </tr>     <tr>         <td>Hot Data Distribution</td>         <td>Gaussian with Standard Deviation 100</td>         <td>Hotspot (99% ops on 1% hot data)</td>     </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1. Workload Configuration </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h3>Results </h3></div><div><p>Figures 4-7 show throughput in ops/sec and the amount of data migrated to DRAM over time. Not only did DAMON fail to identify even a single hot data page, but the profiling overheads resulted in decreased throughput compared to the baseline (no telemetry). With PEBS, only a few gigabytes of hot data could be identified, resulting in marginal throughput improvements in some cases. We depict only one variant each of DAMON and PEBS because we fail to see any major difference in the results of the aggressive and moderate configurations.  </p></div><div><p>We quantify the impact of the telemetry on the application’s performance by the 95th percentile latency among all requests. The results are shown in Table 2. We see that with Telescope, the tail latency is lower than with DAMON or with PMU counters. </p></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/legend.png?itok=ewm4xZxT" width="1031" height="101" alt="" /></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/memcachedycsb.png?itok=0VdoIcC-" width="1247" height="533" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 4. Memcached + YCSB. Throughput (left) and data migrated to hot tier (right) with time. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/memcachedmemtier.png?itok=C5asKb_M" width="1249" height="522" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 5. Memcached + Memtier. Throughput (left) and data migrated to hot tier (right). </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/redisycsb.png?itok=mi_xYMFn" width="1249" height="547" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 6. Redis + YCSB. Throughput (left) and data migrated to hot tier (right) with time. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/redismemtier.png?itok=rxcwP52q" width="1249" height="526" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 7. Redis + Memtier. Throughput (left) and data migrated to hot tier (right) with time. </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table data-table="" data-tablelook="1696">  <tr> <td colspan="1" rowspan="2" data-celllook="0"> Application </td> <td colspan="1" rowspan="2" data-celllook="0"> Telemetry </td> <td colspan="2" rowspan="1" data-celllook="0"> 95th Percentile Latency (ms) </td> </tr> <tr> <td data-celllook="0"> YCSB </td> <td data-celllook="0"> Memtier </td> </tr> <tr> <td colspan="1" rowspan="4" data-celllook="0"> Memcached </td> <td data-celllook="0"> DAMON - Moderate </td> <td data-celllook="0"> 881 </td> <td data-celllook="0"> 11.2 </td> </tr> <tr> <td data-celllook="0"> PEBS - Aggressive </td> <td data-celllook="0"> 976 </td> <td data-celllook="0"> 11.3 </td> </tr> <tr> <td data-celllook="0"> Telescope - Bounded </td> <td data-celllook="0"> 867 </td> <td data-celllook="0"> 10.8 </td> </tr> <tr> <td data-celllook="0"> Telescope - Flexible </td> <td data-celllook="0"> 824 </td> <td data-celllook="0"> 10.5 </td> </tr> <tr> <td colspan="1" rowspan="4" data-celllook="0"> Redis </td> <td data-celllook="0"> DAMON - Moderate </td> <td data-celllook="0"> 850 </td> <td data-celllook="0"> 59.13 </td> </tr> <tr> <td data-celllook="0"> PEBS - Aggressive </td> <td data-celllook="0"> 757 </td> <td data-celllook="0"> 57.50 </td> </tr> <tr> <td data-celllook="0"> Telescope - Bounded </td> <td data-celllook="0"> 696 </td> <td data-celllook="0"> 54.01 </td> </tr> <tr> <td data-celllook="0"> Telescope - Flexible </td> <td data-celllook="0"> 741 </td> <td data-celllook="0"> 55.55 </td> </tr>  </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 2. Tail Latency with different telemetry techniques.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div><h3>MGLRU + Telescope </h3></div><div><p>We evaluated classical MGLRU against our MGLRU+Telescope on a 2 socket Intel Xeon Gold 6354 with 72 cores and 1TB local (DDR-attached) DRAM, running Linux v6.5.0. We ran Memcached with Memtier load generator. Initially 976GB of data was initialized in DRAM. We ran MGLRU in parallel, and let it reclaim memory into a compressed in-memory zswap [<a href="#reference-10" rel="nofollow">10</a>] pool, later repeating the experiment with MGLRU+Telescope. </p></div><div><p>Figure 8 shows how the Resident Set Size (RSS) of the workload changes with time in either case. Table 3 shows the overheads of both variants of MGLRU in terms of CPU cycles consumed, time taken to complete one full scan, and the impact on the throughput of Memcached. In every metric MGLRU+Telescope outperforms standalone MGLRU. </p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/mglrutelescope.png?itok=Rn_egi4v" width="866" height="531" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Fig 8. RSS (Resident Set Size) of Memcached with proactive reclaim to zswap. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table>     <tr>         <th>Metric</th>         <th>MGLRU Standalone</th>         <th>MGLRU + Telescope</th>     </tr>     <tr>         <td>Scan Time (secs)</td>         <td>14.57</td>         <td>12.77</td>     </tr>     <tr>         <td>CPU cycles (billions)</td>         <td>53.15</td>         <td>46.85</td>     </tr>     <tr>         <td>Memcached ops/sec</td>         <td>1 (normalized)</td>         <td>1.08</td>     </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 3. Summary of overheads for MGLRU </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusion</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><span>The effectiveness of a tera</span><span>b</span><span>yte-scale tiered memory system depends on precise and </span><span>timely</span><span> telemetry data to </span><span>identify</span><span> hot/cold pages. Telescope future-proofs telemetry for tiered memory systems with memory </span><span>capacity</span><span> up to and </span><span>b</span><span>eyond the tera</span><span>b</span><span>yte scale with a novel page ta</span><span>b</span><span>le profiling technique.</span></span><span> </span></p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Raybuck, Amanda, et al. "Hemem: Scalable tiered memory management for big data applications and real nvm."&nbsp;Proceedings of the ACM SIGOPS 28th Symposium on Operating Systems Principles. 2021.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] mm/damon. Profiling Enhancements for the Linux kernel. <a href="https://lore.kernel.org/linux-mm/MW5PR11MB5907791BEAA13D89C8B3948DF290A@MW5PR11MB5907.namprd11.prod.outlook.com/T/" target="_blank" rel="nofollow">https://lore.kernel.org/linux-mm/MW5PR11MB5907791BEAA13D89C8B3948DF290A@MW5PR11MB5907.namprd11.prod.outlook.com/T/</a>&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] Multi-Gen LRU. Linux Kernel Documentation. <a href="https://docs.kernel.org/admin-guide/mm/multigen_lru.html" target="_blank" rel="nofollow">https://docs.kernel.org/admin-guide/mm/multigen_lru.html</a>&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] DAMON: Data Access Monitor. Linux Kernel Documentation. <a href="https://www.kernel.org/doc/html/v5.18/vm/damon/index.html" target="_blank" rel="nofollow">https://www.kernel.org/doc/html/v5.18/vm/damon/index.html</a>&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Lee, Taehyung, et al. "MEMTIS: Efficient Memory Tiering with Dynamic Page Classification and Page Size Determination."&nbsp;Proceedings of the 29th Symposium on Operating Systems Principles. 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Maruf, Hasan Al, et al. "TPP: Transparent page placement for CXL-enabled tiered-memory."&nbsp;Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 3. 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Borthakur, Dhruba. "Petabyte scale databases and storage systems at facebook."&nbsp;Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data. 2013.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8] Li, Mu, et al. "Scaling distributed machine learning with the parameter server."&nbsp;11th USENIX Symposium on operating systems design and implementation (OSDI 14). 2014.&nbsp;<a href="https://www.usenix.org/conference/osdi14/technical-sessions/presentation/li_mu" target="_blank" title="Scaling distributed machine learning with the parameter server">https://www.usenix.org/conference/osdi14/technical-sessions/presentation/li_mu</a></p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] Nair, Alan et al. “Telescope: Profiling Memory Access Patterns at the Terabyte-scale.” 2024 USENIX Annual Technical Conference (USENIX ATC 24). 2024.&nbsp;<a href="https://www.usenix.org/conference/atc24/presentation/nair" target="_blank" title="Telescope paper presentation">https://www.usenix.org/conference/atc24/presentation/nair</a></p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10] Zswap. Linux Kernel Documentation. <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/zswap.html" target="_blank" rel="nofollow">https://www.kernel.org/doc/html/latest/admin-guide/mm/zswap.html</a>&nbsp;</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Operating Systems</li>
                                                    <li class="category">Linux</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/anvil-building-formally-verified-kubernetes-controllers"
                    >Anvil: Building Kubernetes Controllers That Do Not Break</a>
                </h2>

                                    <time datetime="2024-06-17 00:00:00">
                        2024-06-17 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Xudong Sun</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Today’s cluster managers, like Kubernetes, keep the beating heart of datacenters running. These managers are architected as a collection of loosely-coupled <em>controllers</em> and follow the <em>state-reconciliation principle</em>: each controller’s job is to monitor the actual cluster state and its input desired state, then modify the cluster state until it is reconciled with the desired state; a controller builds on top of underlying controllers by modifying their input desired states.</p><div><p><span>The Kubernetes ecosystem has thousands of such controllers available. Each </span>Kubernetes deployment comprises an appropriate subset of controllers, a flexible modularity enabled by the loosely-coupled architecture.</p><div><div><div><p><span>Cluster management is challenging because of so many independently-authored controllers interacting asynchronously and concurrently. Even more challenging is that failures may interrupt a controller’s operations. In principle, each controller should wake up from failure, observe that the current state does not match the desired state, and proceed to reconcile. In practice, a very common bug pattern is for a controller’s correct operation to depend on its internal state (stack frame or program counter); if a failure occurs, that state is lost, and the controller logic is unable to recognize that it has left its task incomplete. </span></p> <p><span>This kind of failure is called a “liveness” bug: the controller does not do anything immediately apparent as </span><em>wrong </em><span>(which would be a safety violation), but it never gets around to doing the expected </span><em>right </em><span>thing. We studied controller failures and found that this form of failure is dominant in the controller ecosystem. Recent testing techniques [</span><span><a href="#reference-3" rel="nofollow">3</a></span><span>, </span><span><a href="#reference-10" rel="nofollow">10</a></span><span>] can reveal such bugs using automatically generated tests and fault injections, but testing cannot confirm a controller’s correctness.</span></p> <p><span>Our goal is to confirm statically, at compile time, that a controller always gets around to doing the right thing, even in the presence of asynchrony, concurrency and failures. To this end, we present Anvil, a framework for developing controllers and proving their correctness. We have used Anvil to implement and verify three practical Kubernetes controllers that can readily be deployed on real-world Kubernetes platforms. Anvil and the verified controllers are available at </span><a href="https://github.com/vmware-research/verifiable-controllers" target="_blank" title="Anvil verified controllers" rel="nofollow"><span>https://github.com/vmware-research/verifiable-controllers</span><span>.</span></a></p></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">How controllers work and why they break</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Modern cluster managers like Kubernetes follow the <em>state-reconciliation</em> pattern, where controllers repeatedly attempt to reconcile between the current cluster state and some desired state [<a href="#reference-2" rel="nofollow">2</a>]. We use Kubernetes as a representative example to present the basics of state reconciliation. In Kubernetes, the cluster state is represented as data objects, and all cluster management logic is implemented in a fleet of controllers, running as microservices. Figure 1 illustrates Kubernetes’ architecture. Kubernetes’ core comprises an ensemble of <em>API servers</em> and a highly available, strongly consistent data store (e.g., etcd) that houses the <em>cluster state</em>. The cluster state is represented by a collection of <em>objects</em>. Every entity in the cluster has a corresponding object in the cluster state, including pods, volumes, nodes, and groups of applications. All controllers in Kubernetes interact with the cluster state via API servers.</p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/control-plane-2-1.png?itok=duyWAhOD" width="1440" height="759" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1: An overview of Kubernetes’ architecture.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><div>Each Kubernetes controller runs a control loop that continuously reconciles the cluster’s current state to the desired state. At each loop iteration, a reconciliation procedure checks whether the current cluster state matches the desired state; if not, it performs corrective operations to move the cluster towards the desired state (e.g., launching new replicas in an ensemble of servers when existing replicas fail). The operations query or update the cluster state objects via API servers. The desired cluster state is described declaratively, represented as an object, and can be dynamically updated during the lifecycle of a running controller. The reconciliation procedure is typically implemented in a <code>reconcile()</code> function, which is invoked whenever the desired state description (or its relevant cluster states) is changed.</div><div><p><span>This design enables Kubernetes to be highly extensible: supporting a new application or feature is a matter of adding a new controller and a corresponding custom object type to describe the desired state; it does not require changes to API servers or existing state objects. Kubernetes’ extensibility has led to the emergence of a thriving ecosystem of thousands of custom controllers that have been developed by commercial vendors and open-source communities.</span></p> <div><div><div><div><p><span>Figure </span><span>2 </span><span>exemplifies the reconciliation process of a Kubernetes controller for managing ZooKeeper. To create a ZooKeeper cluster, the controller takes three steps to create:</span> (1) a networked service (a Kubernetes service object), (2) a ZooKeeper configuration (a config map object), and (3) a stateful application (a stateful set object) with three replicas. Each step is performed by creating a new state object of the corresponding resources via the API server, which then triggers Kubernetes built-in controllers, e.g., the StatefulSet controller will create three sets of pods and volumes to run containerized ZooKeeper nodes. In the end, the cluster state matches the desired state. Later, if the desired state changes (e.g., its number of replicas is increased), the ZooKeeper controller will start a new iteration of reconciliation that updates the stateful set object to scale up the ZooKeeper cluster.</p></div></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/reconcile-1.png?itok=5ReG0CFB" width="1440" height="695" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2: An example of state reconciliation of an unverified ZooKeeper controller. A liveness bug is triggered by a crash during reconciliation. The bug pattern is common in real-world Kubernetes controllers (known as intermediate-state bugs [10]).</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-callout view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--callout">   <div class="content">     <div class="field field-name-field-callout-subtitle field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Controller correctness is challenging</div></div></div><div class="field field-name-field-callout-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>A bug in a controller’s reconciliation can result in the controller <em>never</em> being able to match the desired state, even when <code>reconcile()</code> is called repeatedly—a <em>liveness</em> violation. Controllers are expected to be level-triggered [<a href="#reference-5" rel="nofollow">5</a>]: <code>reconcile()</code> can be called from any current cluster state to match any given desired state, with no guarantee that the controller has seen the entire history of cluster state changes [<a href="#reference-12" rel="nofollow">12</a>]. In addition, controllers run within dynamic and complex environments and thus must tolerate unexpected failures, network interruptions and concurrency and asynchrony issues while running <code>reconcile()</code>.</p><div><div><div><div><div><p>Figure 2 shows one of many bug patterns of controllers [<a href="#reference-3" rel="nofollow">3</a>, <a href="#reference-8" rel="nofollow">8</a>, <a href="#reference-9" rel="nofollow">9</a>, <a href="#reference-10" rel="nofollow">10</a>]. If the controller crashes between steps (1) and (2) during an execution of <code>reconcile()</code>, Kubernetes will reboot the controller. The freshly invoked <code>reconcile()</code> call now faces the intermediate state created by the previous failed execution (step (1)). However, in this case, the controller would <em>never </em>perform step (2) due to a buggy predicate, which only checks whether the networked service exists, but not whether the config map also exists.</p> <p><span>The enormity of cluster state space and the complexity of failure events lead to a state-space explosion problem, making it prohibitively expensive (if not impossible) to test a controller’s behavior under </span><em>all </em><span>possible scenarios. In particular, liveness violations are notoriously hard to detect because a testing tool, by observing a controller’s external behavior, cannot decide whether the controller will never realize the desired state or is just running slow.</span></p></div></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Anvil’s Approach</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Anvil is a framework that allows developers to confirm statically, at compile time, that a controller performs state reconciliation correctly. Anvil uses formal verification—an approach that confirms the correctness of a program by proving that the program always adheres a correctness specification.</p><div><p><span>With Anvil, developers implement the controller’s state-reconciliation logic in Rust, write a specification and a proof to show that the controller correctly implements the specification; the proof is mechanically checked to ensure that the proof itself is correct.</span></p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h3>Implementing Controllers</h3><div><div><div><div><div><p><span>In Anvil, developers implement a controller using a state machine to enable formal verification. Figure </span><span>3 </span><span>shows a snippet of the Anvil Controller API specified using a Rust trait: it involves defining the initial state and the transitions of a state machine. </span></p> <p><span>Anvil’s </span><span><code>reconcile()</code> </span><span>uses the state machine: it starts from the initial state and invokes </span><span><code>step()</code> </span><span>iteratively until all steps are done or if any step encounters an error. Each iteration of </span><span><code>step()</code> </span><span>returns the next state in the state machine, together with an external request. The external request is typically a REST call to Kubernetes API servers, but can also be extended to non-Kubernetes APIs. The response to the external request is passed as an argument to the next iteration of </span><span><code>step()</code></span><span>. Note that the API enforces no more than one external request per </span><span><code>step()</code></span><span>, making the state-machine transition atomic with respect to cluster-state changes. Anvil’s </span><span><code>reconcile()</code> </span><span>interfaces a trusted Kubernetes client library (kube-rs [</span><span><a href="#reference-1" rel="nofollow">1</a></span><span>]) which invokes </span><span><code>reconcile()</code> </span><span>upon changes, handles its output, and requeues the next invocation.</span></p></div></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd">pub trait Controller {     type D; // desired cluster state description     type S; // local state in the state machine      // Returns the initial local state (in the state     // machine) of every reconcile()     fn initial_state() -> S;      // Returns S: next local state in state machine     // Req: external request (e.g. to Kubernetes)     // # Arguments     // * d: the desired cluster-state description     // * r: response to the request from last step     // * s: current local state in state machine     fn step(d: &D, r: Resp, s: S) -> (S, Req);      // Returns true if all steps are done     fn done(s: &S) -> bool;      // Returns true for error states     fn error(s: &S) -> bool; }</div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3: Anvil’s basic Controller API. To implement a controller, developers implement the Controller trait.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Figure </span><span>4 </span><span>shows the </span><span><code>step()</code> </span><span>implementation of a ZooKeeper controller (Figure </span><span>2</span><span>). The state machine starts from the </span><span><code>CheckService</code> </span><span>state, where it returns a request to read the service object from the API server (</span><span><code>service_get_req</code></span><span>) and the next state to transition to </span><span><code>ReconcileService</code></span><span>. The </span><span><code>reconcile()</code> </span><span>method fetches the service object by calling the API server, and moves on to the next iteration of </span><span><code>step()</code></span><span>, bringing the state machine to the </span><span><code>ReconcileService</code> </span><span>branch. The controller proceeds to create or update the service based on</span><span> </span><span>the response of </span><span><code>service_get_req</code></span><span>. In this way, the controller progressively reconciles each cluster-state object and eventually matches the desired state declared by </span><span><code>ZKD</code></span><span>.</span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd">fn step(d: &ZKD, r: Resp, s: ZKS) -> (ZKS, Req) {     match s {         CheckService => { // if the service exists             let service_get_req = KubeGet { ... }             return (ReconcileService, service_get_req);         }         ReconcileService => {             // create/update the service based on response r             if r.is_ok() {                 let service_update_req = ...;                 return (CheckConfigMap, service_update_req);             } else if r.is_not_found() {                 let service_create_req = ...;                 return (CheckConfigMap, service_create_req);             } else {                  return (Error, Noop); // restart reconcile()             }         }         CheckConfigMap => { ... }         ReconcileConfigMap => { ... }         CheckStatefulSet => { ... }         ReconcileStatefulSet => { ... }         ...     } // more step branches are omitted }</div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4: A simplified implementation of step() using Anvil for creating a ZooKeeper cluster.</div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>To verify the controller, developers need to first write a correctness specification that they want the controller to implement. However, controllers, unlike some other systems (e.g., consensus systems or storage systems), do not have well-known protocols or properties that formally define their correctness. How do we formally specify controller correctness?</span></p><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h3>Specifying Controller Correctness</h3><div><div><div><div><p><span>We formalize controller correctness as </span><em>eventually stable reconciliation (ESR)</em><span>, a specification that captures key properties of state reconciliation. We follow the principle that the spec</span><span>ification must be: (1) powerful enough to preclude a broad range of bugs, (2) generally applicable to diverse controllers, and (3) concise enough for manual inspection.</span></p> <div><div><div><p><span>ESR captures two key properties of any controller’s state reconciliation behavior: (1) </span><em>progress</em><span>: given a desired state description, the controller must eventually make the cluster state match that desired state (unless the desired state changes), and (2) </span><em>stability</em><span>: if the controller successfully brought the cluster to the desired state, it must keep the cluster in that state (unless the desired state changes). </span></p></div></div></div><p><span>We formalize ESR as a TLA (temporal logic of actions [</span><span><a href="#reference-6" rel="nofollow">6</a></span><span>]) formula. In TLA, the behavior of the state machine is captured by its set of traces, infinite sequences of system states. The ESR formula should hold for </span><span>all </span><span>traces of the controllers’s execution under all possibilities for asynchrony, concurrency, and failures. We use </span><strong>d </strong><span>to denote a state description, </span><span><code>desire</code></span><span>(</span><span>d</span><span>) </span><span>to denote whether </span><strong>d </strong><span>is the current description of the desired state (the controller’s input), </span><span><code>match</code></span><span>(</span><span>d</span><span>) </span><span>to denote whether the current cluster state matches the description </span><span>d</span><span>. Our definition of ESR is given by the following formula:</span></p></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/screenshot_2024-06-19_at_3.37.08_pm.png?itok=AeHmNtIh" width="1010" height="112" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Equation 1: The ESR property formalized in TLA.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Informally, ESR asserts that if at some point the desired state stops changing, then the cluster will eventually reach a state that matches it, and stay that way forever. The universal quantifier ∀ (for-all) is used to assert on all possible state descriptions. For example, ∀d.P(d) holds if and only if P(d) holds for all possible d. The temporal operators ↝ (leads-to) and ☐(always) are used in temporal logics to reason about the future of an execution trace. If predicates P and Q talk about the current state, then ☐P says that P holds in the current state and all future states, while P ↝ Q says that if P holds at some state then Q holds in the same state or some future state. Temporal logics such as TLA also allow nesting of temporal operators; for example, P ↝ ☐Q means that if P holds then eventually we get to a point such that from that point onwards, Q always holds.</p><div><p>The formalization of ESR captures the key correctness properties shared by virtually all controllers: progress and stability. We elaborate on this with a detailed dissection of Equation 1. The innermost conclusion of the formula is ☐<code>match</code>(d) after ↝, which states that eventually the controller matches the desired state (progress), and from then on, it always keeps the cluster state at the desired state (stability). Before ↝, ☐<code>desire</code>(d) is a realistic and necessary premise for the controller to match the desired state—if the desired state description keeps changing forever, the controller will keep chasing a moving target forever, and nothing can be guaranteed as we do not wish to assume a bound on how long state reconciliation takes. Finally, the ∀d states that the controller reconciles all desired state descriptions.</p><p>ESR precludes <em>any</em> bug that prevents the controller from eventually making the cluster state match the desired state stably. Figure 5 illustrates the ESR definition in some examples that violate or satisfy ESR: (a) violates progress because the cluster state never matches d, (b) violates stability because the cluster state first matches d but then deviates from d, (c) satisfies ESR because the cluster state eventually matches and always matches d<sub>2</sub>, and (d) vacuously satisfies ESR because the desired state never stops changing, so ☐<code>desire</code>(d) does not hold for any fixed d.</p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/esr-1.png?itok=-dp5mq2e" width="1440" height="879" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 5: Executions that violate or satisfy ESR.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>The verification goal for each controller is to prove that the controller satisfies ESR—<em>all</em> possible executions of the controller satisfy ESR. We use <code>model</code> to describe all possible executions of the controller that runs in an environment with asynchrony, concurrency and faults. Then the statement that the controller satisfies ESR is formalized as:</p><div><div></div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/screenshot_2024-06-19_at_4.04.06_pm.png?itok=a6364wvX" width="1006" height="116" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Equation 2: The theorem that the controller satisfies the ESR property.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>The ⊨ <span>symbol in this context means that any execution that </span><span>the controller might produce satisfies ESR.</span></p><div><div><div><p><span>Strictly speaking, ESR </span><span>only guarantees one successful state reconciliation—the one that happens after the desired state stops changing forever. However, in practice the controller has no way of knowing if the desired state will change in the future or not. Therefore, we can expect that a controller that satisfies ESR will bring the cluster to match the desired state (and keep it like that) for any desired state that remains unchanged for </span><em>long enough</em><span>.</span></p> <p><span>Anvil provides a TLA library that makes writing TLA formulas similar to writing code, inspired by previous work [</span><span><a href="#reference-4" rel="nofollow">4</a></span><span>]. Figure </span><span>6 </span><span>presents the ESR theorem written using Anvil. The definition of </span><span><code>match</code> </span><span>varies across controllers; e.g., the </span><span><code>match(d)</code></span><span>for the ZooKeeper controller in Figure </span><span>4 </span><span>checks if the service, config map and stateful set exist in the data store and match the desired state description </span><span><code>d</code></span><span>. Note that Anvil is not limited to ESR; developers can specify and prove other controller properties using Anvil.</span></p></div></div></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd">model.entails(forall(|d| always(desire(d)).leads_to(always(match(d)))))</div></div></div><div class="field field-name-field-code-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 6: The ESR theorem written using Anvil’s TLA library.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>With the controller implementation and specification ready, developers need to write a proof to show that the controller correctly implements the specification. To ensure the correctness of the proof itself, the proof is mechanically checked by the Verus verifier [<a href="#reference-7" rel="nofollow">7</a>].</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h3><span>Proving Controller Correctness</span></h3><div><div><div><div><div><p><span>Proving that a controller implements ESR requires reasoning about how the controller makes progress towards the desired state and then keeps the cluster state at the desired state stably. </span></p></div></div></div> <p>To reason about the controller’s progress, most of the proof involves demonstrating that if condition P holds then eventually Q holds (i.e., P ↝ Q). For example, if the controller sends a request, then eventually the request is received and handled by the API server. Proving P ↝ Q is typically done by <span>applying the WF1 proof rule [</span><span><a href="#reference-6" rel="nofollow">6</a></span><span>] (WF stands for “weak fairness”) that informally states that “Action </span><span>A </span><span>makes </span><span>P </span><span>lead to </span><span>Q</span><span>” with the following requirements: (1) running </span><span>A </span><span>in a state satisfying </span><span>P </span><span>makes </span><span>Q </span><span>hold in the next state, (2) </span><span>P </span><span>holds until </span><span>A </span><span>runs, and (3) if </span><span>A </span><span>remains enabled (</span><span>A </span><span>can possibly occur), then </span><span>A </span><span>eventually occurs; this condition is referred to as weak fairness.</span></p><p>Proving that the controller keeps the cluster state at the desired state stably is done by induction: if the cluster state currently matches the desired state, then no matter what action happens next, the cluster state will still match the desired state.</p></div><div><div><div><div><p><span>To reduce the developers’ burden on proof, Anvil provides many proof utilities including a model of the controller environment, a set of reasonable assumptions on the environment (e.g., weak fairness), and reusable lemmas encoding temporal proof rules (e.g., WF1) that can be directly assembled into developers’ ESR proofs. In addition, Anvil comes with a general ESR proof strategy. The proof strategy structures the proof by dividing the proof goal into several more approachable lemmas. We refer readers interested in more details about writing proofs to our OSDI’24 paper [</span><span><a href="#reference-11" rel="nofollow">11</a></span><span>].</span></p></div></div></div></div></div></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Our Experience with Anvil</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We have used Anvil to build three verified Kubernetes controllers for managing different applications and services (ZooKeeper, RabbitMQ, and FluentBit). For each controller, we use a mature, widely used controller as a reference (either the official Kubernetes controller of the applications or from companies that offer related products).</p><div><p><span>We aim to implement verified controllers that are feature rich with production quality. For the ZooKeeper and RabbitMQ controllers, we implement key features offered by the reference controllers including scaling, version upgrading, resource allocation, pod placement, and configurations, as well as network and storage management. For the FluentBit controller, we implement </span><span>all </span><span>the features offered by the reference controller. All the verified controllers can readily be deployed in real-world Kubernetes platforms and manage their respective applications.</span></p> <div><div><div><p><span>For verification, we spent around two person-months on verifying ESR for the ZooKeeper controller, during which we developed the proof strategy. We took much less time (around two person-weeks) to verify the other two controllers using the same proof strategy and similar invariants. We find Anvil’s ability to formally verify a controller’s implementation invaluable; we discovered four deep bugs via verification. Some of the bugs also exist in the reference controllers but were not detected by testing [</span><span><a href="#reference-3" rel="nofollow">3</a></span><span>, </span><span><a href="#reference-10" rel="nofollow">10</a></span><span>]. </span></p></div></div></div><p><span>Table </span><span>1 </span><span>shows the efforts to implement and verify each controller using Anvil. We also measured the controllers’ state-reconciliation time and the verified controllers achieve competitive performance compared to the unverified references.</span></p></div></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table>   <tr>     <th>Controller</th>     <th>Trusted (LoC)</th>     <th>Verified Impl (LoC)</th>     <th>Proof (LoC)</th>   </tr>   <tr>     <td>ZooKeeper</td>     <td>950</td>     <td>1134</td>     <td>8352</td>   </tr>   <tr>     <td>RabbitMQ</td>     <td>548</td>     <td>1598</td>     <td>7228</td>   </tr>   <tr>     <td>FluentBit</td>     <td>828</td>     <td>1208</td>     <td>8395</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1: Code sizes of the controllers verified using Anvil. Trusted includes the (verified) theorems, trusted assumptions and unverified implementation.</div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We are continuously improving Anvil and building more verified controllers using Anvil. Currently, we are building verified Kubernetes built-in controllers, including ReplicaSet, Deployment and StatefulSet controllers. In future work, we aim to gradually replace existing (unverified) controllers with verified controllers using Anvil, including both custom and built-in ones.</p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Concluding Remarks</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Kubernetes controllers are getting increasingly important but their correctness is challenging. Anvil is a framework for developing Kubernetes controllers and confirming their correctness using formal verification. Our work shows that it is not only feasible but also pragmatic to implement, verify, and maintain practical Kubernetes controllers. We hope that Anvil leads to a practical path towards provably correct cloud infrastructures.</p><div><p>More details are available in the <a href="https://marshtompsxd.github.io/pub/anvil.pdf" target="_blank" title="Full Anvil Paper" rel="nofollow">full Anvil paper</a> and <a href="https://github.com/vmware-research/verifiable-controllers/blob/main/README.md" target="_blank" title="Anvil's documentation" rel="nofollow">Anvil's documentation</a>.</p></div></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1]&nbsp;kube-rs/kube: Rust Kubernetes client and controller runtime.&nbsp;<a href="https://github.com/kube-rs/kube" target="_blank" rel="nofollow">https://github.com/kube-rs/kube</a>, 2023.</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2]&nbsp;Burns, B., Grant, B., Oppenheimer, D., Brewer, E. and Wilkes, J.&nbsp;Borg, Omega, and Kubernetes. Communications of the ACM 59, 5 (May 2016), 50–57.</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3]&nbsp;Gu, J.T., Sun, X., Zhang, W., Jiang, Y., Wang, C., Vaziri, M., Legunsen, O. and Xu, T.&nbsp;Acto: Automatic End-to-End Testing for Operation Correctness of Cloud System Management. In Proceedings of the 29th ACM Symposium on Operating Systems Principles (SOSP’23) (Oct. 2023).</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4]&nbsp;Hawblitzel, C., Howell, J., Kapritsos, M., Lorch, J.R., Parno, B., Roberts, M.L., Setty, S. and Zill, B.&nbsp;IronFleet: Proving Practical Distributed Systems Correct. In Proceedings of the 25th ACM Symposium on Operating Systems Principles (SOSP’15) (Oct. 2015).&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Hockin, T. Kubernetes: Edge vs. Level Triggered Logic. <a href="https://speakerdeck.com/thockin/edge-vs-level-triggered-logic" target="_blank" title="Edge vs level triggered logic" rel="nofollow">https://speakerdeck.com/thockin/edge-vs-level-triggered-logic</a>, June 2017.</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Lamport, L. The Temporal Logic of Actions. ACM Transactions on Programming Languages and Systems 16, 3 (May 1994), 872–923.</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7]&nbsp;Lattuada, A., Hance, T., Cho, C., Brun, M., Subasinghe, I., Zhou, Y., Howell, J., Parno, B. and Hawblitzel, C.&nbsp;Verus: Verifying Rust Programs Using Linear Ghost Types. In Proceedings of 2023 ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA’23) (Apr. 2023).</p> </div><div class="field-item even"><a class="anchor" name="reference-8"></a><p>[8]&nbsp;Liu, B., Kheradmand, A., Caesar, M. and Godfrey, P.B.&nbsp;Towards Verified Self-Driving Infrastructure. In Proceedings of the 19th ACM Workshop on Hot Topics in Networks (HotNets’20) (Nov. 2020).</p> </div><div class="field-item odd"><a class="anchor" name="reference-9"></a><p>[9] Liu, B., Lim, G., Beckett, R., and Godfrey, P. B. Kivi: Verification for Cluster Management. In Proceedings of the 2024 USENIX Annual Technical Conference (ATC’24) (July 2024).</p> </div><div class="field-item even"><a class="anchor" name="reference-10"></a><p>[10]&nbsp;Sun, X., Luo, W., Gu, J.T., Ganesan, A., Alagappan, R., Gasch, M., Suresh, L. and Xu, T. Automatic Reliability Testing for Cluster Management Controllers. In Proceedings of the 16th USENIX Symposium on Operating Systems Design and Implementation (OSDI’22) (July 2022).</p> </div><div class="field-item odd"><a class="anchor" name="reference-11"></a><p>[11] Sun, X., Ma, W., Gu, J. T., Ma, Z., Chajed, T., Howell, J., Lattuada, A., Padon, O., Suresh, L.,&nbsp;Szekeres, A., and Xu, T. Anvil: Verifying Liveness of Cluster Management Controllers. In Proceedings of the 18th USENIX Symposium on Operating Systems Design and Implementation (OSDI’24) (July 2024).</p> </div><div class="field-item even"><a class="anchor" name="reference-12"></a><p>[12]&nbsp;Sun, X., Suresh, L., Ganesan, A., Alagappan, R., Gasch, M., Tang, L. and Xu, T. Reasoning about modern datacenter infrastructures using partial histories. In Proceedings of the 18th Workshop on Hot Topics in Operating Systems (HotOS-XVIII) (May 2021).</p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">SRE</li>
                                                    <li class="category">Distributed systems</li>
                                                    <li class="category">Cloud</li>
                                            </div>
                            </section>
                    <section class="feeditem">
                <h2>
                    <a
                        class="itemtitle"
                        href="https://www.usenix.org/publications/loginonline/sieve-cache-eviction-can-be-simple-effective-and-scalable"
                    >SIEVE: Cache eviction can be simple, effective, and scalable</a>
                </h2>

                                    <time datetime="2024-06-16 00:00:00">
                        2024-06-16 00:00:00                    </time>
                    <p></p>
                
                                    <p class="author">by: Juncheng Yang</p>
                
                <!-- Intentionally not escaping for html context -->
                   <div class="field field-name-field-lv2-body field-type-paragraphs field-label-hidden"><div class="field-items"><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text paragraphs-first-text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Caching bolsters the performance of virtually every computer system today by speeding up data access and reducing data movement. By storing frequently accessed objects on a small but comparatively fast storage device, future requests for that cached data can be processed rapidly. When the capacity of a cache is much smaller than the complete dataset, choosing what objects to store in the cache, and which to evict, becomes an important, hard, and fascinating problem.</span></p><p><span>In this article, we present a new cache eviction algorithm called SIEVE that is simpler than the state-of-the-art algorithms while achieving superior efficiency and thread scalability. </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Caching and eviction algorithms</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>Caching is a vital tool for optimizing the performance of slow backends. A good cache should (1) serve as many requests as possible from the cache, and (2) serve as many requests as possible in a time interval. The former is often measured by </span><span>miss ratio</span><span> — the fraction of requests that cannot be served from the cache; while the latter is often measured by </span><span>throughput</span><span> — the number of requests the cache can serve per second. </span></p><p><span>When the cache fills up, writing new data requires discarding some old data. The algorithm that decides which data to evict is called a cache eviction algorithm. Least-recently-used (LRU) is the most common eviction algorithm used in production systems. An LRU implementation often uses a doubly linked list to maintain the last-access ordering between objects. Upon each cache read, the requested object is moved to the head of the list. To insert an object when the cache is full, the object at the tail of the list is evicted. LRU is simple and effective because data access often exhibits temporal locality — recently accessed data are more likely to be accessed again soon. </span></p><p>While it is the most common eviction algorithm, LRU leaves a lot of efficiency on the table compared to an offline optimal caching algorithm. Over the past sixty years, many new cache eviction methods have been designed with the goal of achieving a lower miss ratio. Many of these algorithms descend from LRU — often using one or more LRU lists. For example, <a href="#reference-1" target="_blank" rel="nofollow">ARC</a> internally employs four LRU lists, two of which store recently and frequently accessed data, and two of which track recently evicted data. </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/complexity.png?itok=CoE2e4xj" width="1440" height="698" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 1. Eviction algorithms have become increasingly complex over time. The darkness of color indicates the complexity of the algorithm. </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span>While a range of algorithms have been proposed to improve efficiency, they have become increasingly complex over time. As a result, these algorithms are difficult for systems builders to implement and debug, and most of them have never been adopted in real systems. </span></p><p><span>Moreover, LRU and LRU-based algorithms suffer from a scalability problem. Because each cache read modifies the head of a doubly linked list, which is guarded by a lock, an LRU cache cannot exploit the many cores in modern CPUs</span></p><p><span>Can we yearn, then, for a cache algorithm that is not just efficient and scalable, but also simple enough to be practical? History suggests the pursuit is unlikely to bear fruit, and a richer trove of data than researchers have previously had available lends us hope. </span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Modern web cache workloads</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>While the very mention of caching may conjure images of traditional block and page caches, the web cache deployments that power our online life have grown meteorically over the past decade. In the data center, for instance, key-value caches are widely deployed at scale (for example, petabytes at <a href="#reference-2" rel="nofollow">Google</a>) to temporarily store computed results, such as SQL query results and machine learning predictions. On the edge of the Internet, Content Delivery Networks (CDNs) deliver images and videos to end-users quickly and cheaply. </p><p>The data access patterns of these web caches, specifically in key-value and CDN workloads, differ markedly from traditional page cache workloads. For instance, whereas <a href="#reference-3" rel="nofollow">loops and scans of address ranges are common access patterns in block cache workloads</a>, they are very rare in web cache workloads. Instead, the objects in web cache workloads invariably exhibit skewed and long-tailed popularity distributions that follow a <a href="#reference-4" rel="nofollow">power-law distribution</a>. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/onehit.png?itok=a2GYInEM" width="1440" height="124" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 2. A toy example illustrating that shorter request sequences have higher one-hit-wonder ratios. There are seventeen requests for five objects, one of which (E) is a one-hit wonder. In a shorter request sequence, e.g., from the first to the eighth request, there are four objects, two of which (C and D) are one-hit wonders. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Our recent study found that <a href="#reference-5" rel="nofollow">most objects in web cache workloads are never reused before being evicted</a>. Following an industry convention, we call these objects one-hit wonders. The metric one-hit-wonder ratio measures the fraction of objects being one-hit wonders in a request sequence. We found that shorter request sequences often show higher one-hit-wonder ratios. The figure above shows an example request sequence, where the full sequence has seventeen requests for five objects. There is only one one-hit wonder in the sequence and the one-hit-wonder ratio is 20%. However, if we consider only the window of requests between one and eight then there are four objects being requested and the one-hit-wonder ratio is 50%. </p><p><span>Why do we care about short request sequences? The reason is simple — a cache has limited capacity, so it will not observe the full request sequence before it begins to evict objects. The implication of this observation is that most of the objects in the cache are not reused before eviction. Therefore, we should not keep these objects around in the cache for a long time. But how do we know what items are worth keeping? </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">How to design more efficient yet simple eviction algorithms </div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We view a cache as a list logically ordered by eviction preference — <a href="#reference-6" rel="nofollow">items would be evicted in that preference order</a>. Promotion and demotion are two internal operations used to maintain the object ordering in a cache. Traditional LRU-based algorithms use eager promotion, which moves an object to the head of the list upon each request. Meanwhile, they rely on passive demotion to move objects down the list. </p><p><span>However, the LRU approach has two drawbacks. First, eager promotion requires taking a lock on each cache hit, which limits the throughput and scalability of the cache. Second, as we have shown, many objects in the cache are one-hit wonders, yet passive demotion allows them to stay in the cache for a long time and waste precious space better used by others. The problem gets amplified in the big data era where a huge volume of data is being generated while most data are rarely accessed again. </span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/lpqd.png?itok=ma1iKiqm" width="1440" height="569" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 3. Traditional LRU-based eviction algorithms focus on eager promotion and passive demotion. We argue that quick demotion and lazy promotion should be used. </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>We argue that an efficient cache eviction algorithm should use <a href="#reference-6" rel="nofollow">lazy promotion and quick demotion</a>. Lazy promotion decides whether to promote cached objects or not only at eviction time, aiming to retain popular objects with minimal effort. An example of lazy promotion is adding reinsertion to FIFO (First-in-first-out). Lazy promotion can improve (1) throughput due to less computation and lock contention and (2) efficiency due to more information about an object at eviction.  </p><p>Quick demotion removes most objects quickly after they are inserted. This is critical because most objects are not reused before eviction. Our previous work leverages this idea and designed S3-FIFO, <a href="#reference-4" rel="nofollow">a cache eviction algorithm that only uses FIFO</a>. S3-FIFO is an efficient cache algorithm that scales better than state-of-the-art eviction algorithms, but, while simple, is still more intricate than the litmus test of algorithms like LRU. Below, we introduce SIEVE, the simplest approach we have found to effectively achieve both lazy promotion and quick demotion for cache replacement. </p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">A new cache eviction algorithm: SIEVE</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><span>SIEVE Design </span></h4><p><span><strong>Data structure</strong>.</span><span> SIEVE requires only one FIFO list and one pointer called a “hand”. The list maintains the insertion order between objects. Each object in the list uses one bit to track the visited status. The hand points to the next eviction candidate in the cache and moves from the tail to the head of the list. Note that unlike some existing algorithms, e.g., LRU, FIFO, and CLOCK, in which the eviction candidate is always the tail object, the eviction candidate in SIEVE is an object that can be in the middle of the list. </span></p><p><span><strong>SIEVE operations</strong>.</span><span> A cache hit in SIEVE sets the visited bit of the accessed object to true. For a popular object whose visited bit is already set, cache hits do not perform any metadata update. During a cache miss, SIEVE examines the object pointed by the hand. If it has been visited, the visited bit is reset, and the hand moves to the next position (the retained object stays in the original position of the list). It continues this process until it encounters an object that has not been visited, and it evicts the object. After the eviction, the hand points to the previous object in the list. While an evicted object is in the middle of the queue most of the time, a new object is always inserted into the head of the queue. In other words, the new objects and the retained objects are not mixed together. We illustrate SIEVE operations in Figures 3 and 4. </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/sieve_illustration_0.png?itok=goZjH8ue" width="1440" height="536" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 4. A comparison of SIEVE and FIFO-Reinsertion.The left shows the insertion strategy, while the right shows the difference between object ages between FIFO-reinsertion and SIEVE. Both algorithms use one bit to track object popularity. However, FIFO-Reinsertion reinserts retained objects to the head, mixing with new objects, while SIEVE keeps retained objects at the original position, separating old and new objects. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>At a glance, SIEVE looks similar to FIFO-Reinsertion, also known as CLOCK and Second Chance, which also uses a bit to track popularity. However, SIEVE differs in where a retained object is kept. SIEVE keeps the object in the original, old position. FIFO-Reinsertion, in contrast, inserts the object at the head, together with newly inserted objects, as depicted in Figure 4. The moving hand permits SIEVE to perform quick demotions. When the hand moves to the head, new objects that have not been revisited are quickly evicted. We describe the algorithm in more detail below. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-code-excerpt view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--code_excerpt">   <div class="content">     <div class="field field-name-field-code-excerpt field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd">def cache_hit(obj):     obj.visited = true  def next_hand(hand):      hand = hand.prev      if hand is None:          hand = tail      return hand  def cache_evict():      # find the first object that has not been visited      while hand.visited:          hand.visited = false          hand = next_hand(hand)       obj_to_evict = hand         hand = next_hand(hand)          # evict the object       obj_to_evict.prev.next = obj_to_evict.next      obj_to_evict.next.prev = obj_to_evict.prev      remove_from_hash_table(obj_to_evict)  </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h4><span>Evaluation </span></h4><p>You may wonder how much a simple algorithm like SIEVE can outperform LRU. We used open-source traces from Twitter, Meta, Wikimedia, Tencent, and two proprietary CDN datasets to evaluate the algorithms. We list the dataset information in Table 1. It consists of 1559 traces that together contain 247,017 million requests to 14,852 million objects. We implemented SIEVE and state-of-the-art eviction algorithms in <a href="https://libcachesim.com" rel="nofollow">libCacheSim</a> to compare their efficiency. We have also implemented SIEVE in Meta <a href="https://cachelib.org" rel="nofollow">Cachelib</a> to compare its throughput and scalability with optimized LRU. We replayed the traces as a closed system with instant on-demand fill. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table class="tg">   <tr>     <th class="tg-fymr">trace collection</th>     <th class="tg-6ic8">collection time</th>     <th class="tg-6ic8"># traces</th>     <th class="tg-6ic8">cache type</th>     <th class="tg-6ic8"># request (million)</th>     <th class="tg-l2oz"># object (million)</th>   </tr>     <tr>     <td class="tg-0pky">CDN1</td>     <td class="tg-dvpl">2021</td>     <td class="tg-dvpl">1273</td>     <td class="tg-dvpl">object</td>     <td class="tg-dvpl">37,460</td>     <td class="tg-lqy6">2,652</td>   </tr>   <tr>     <td class="tg-0pky">CDN2</td>     <td class="tg-dvpl">2018</td>     <td class="tg-dvpl">219</td>     <td class="tg-dvpl">object</td>     <td class="tg-dvpl">3,728</td>     <td class="tg-lqy6">298</td>   </tr>   <tr>     <td class="tg-0pky">Tencent Photo</td>     <td class="tg-dvpl">2018</td>     <td class="tg-dvpl">2</td>     <td class="tg-dvpl">object</td>     <td class="tg-dvpl">5,650</td>     <td class="tg-lqy6">1,038</td>   </tr>   <tr>     <td class="tg-0lax">Wiki CDN</td>     <td class="tg-lqy6">2019</td>     <td class="tg-lqy6">3</td>     <td class="tg-lqy6">object</td>     <td class="tg-lqy6">2,863</td>     <td class="tg-lqy6">56</td>   </tr>   <tr>     <td class="tg-0lax">Twitter KV</td>     <td class="tg-lqy6">2020</td>     <td class="tg-lqy6">54</td>     <td class="tg-lqy6">KV</td>     <td class="tg-lqy6">195,441</td>     <td class="tg-lqy6">10,560</td>   </tr>   <tr>     <td class="tg-0lax">Meta KV</td>     <td class="tg-lqy6">2022</td>     <td class="tg-lqy6">5</td>     <td class="tg-lqy6">KV</td>     <td class="tg-lqy6">1,644</td>     <td class="tg-lqy6">82</td>   </tr>   <tr>     <td class="tg-0lax">Meta CDN</td>     <td class="tg-lqy6">2023</td>     <td class="tg-lqy6">3</td>     <td class="tg-lqy6">object</td>     <td class="tg-lqy6">231</td>     <td class="tg-lqy6">76</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 1. Datasets used in the evaluation. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>Miss ratio serves as a key performance indicator when evaluating the efficiency of a cache system. However, when analyzing different traces (even within the same dataset), the miss ratios can vary significantly, making direct comparisons and visualizations infeasible. Therefore, we calculate the miss ratio reduction relative to FIFO. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/mr_cf_large_p90.png?itok=qGIrsBuf" width="1181" height="789" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 5. The boxplot shows the miss ratio reduction from FIFO over all traces in the CDN1 dataset. The box shows P25 and P75, the whiskers show P10 and P90, and the triangle shows the mean. SIEVE achieves similar or better miss ratio reduction compared to state-of-the-art algorithms. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong>Efficiency</strong>. Figure 5 shows the miss ratio reduction (from FIFO) of different algorithms across traces. SIEVE demonstrates the most significant reductions across nearly all percentiles. For example, SIEVE reduces FIFO’s miss ratio by more than 42% on 10% of the traces (top whisker) with a mean of 21%. As a comparison, all other algorithms have similar or smaller reductions on this dataset. For example, CLOCK/FIFO-Reinsertion, which is conceptually similar to SIEVE, can only reduce FIFO’s miss ratio by 15% on average. Compared to advanced algorithms, e.g., ARC, SIEVE reduces ARC miss ratio by up to 63.2% with a mean of 1.5%. Note that, more than 1000 traces were used in the evaluation, so a small move of the box (e.g., the mean value) is non-trivial. We refer interested readers to investigate further figures in our <a href="https://www.usenix.org/conference/nsdi24/presentation/zhang-yazhuo" target="_blank">NSDI'24 paper</a>. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/metakv_scalability_linear_0.png?itok=U_nKnPdJ" width="809" height="572" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 6. SIEVE achieves better thread scalability than optimized LRU.  </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><span><strong>Scalability</strong>.</span><span> Besides efficiency, throughput is the other important metric for caching systems. Figure 6 shows how throughput grows with the number of trace replay threads using a production trace from Meta. </span><span>Because scalability is important for production systems, Meta engineers spent a significant amount of effort to improve the scalability of LRU-based algorithms. For example, objects that were promoted to the head of the queue in the last 60 seconds are not promoted again. Moreover, Cachelib uses a lock combining technique to elide expensive coherence and synchronization operations to boost throughput. Therefore, the optimized LRU and TwoQ show impressive scalability results compared to strict LRU. Compared to these LRU-based algorithms, SIEVE does not require “promotion” at each cache hit. Therefore, it is faster and more scalable. At a single thread, SIEVE is 16% faster than the optimized LRU. At 16 threads, SIEVE shows more than 2× higher throughput than the optimized LRU and TwoQ on the Meta trace. </span></p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-html-table view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--html_table">   <div class="content">     <div class="field field-name-field-table-contents field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><table class="tg">   <tr>     <th class="tg-amwm">Cache library</th>     <th class="tg-amwm">Language</th>     <th class="tg-amwm">Lines of change</th>   </tr>    <tr>     <td class="tg-baqh">groupcache</td>     <td class="tg-baqh">Golang</td>     <td class="tg-baqh">21</td>   </tr>   <tr>     <td class="tg-baqh">mnemonist</td>     <td class="tg-baqh">Javascript</td>     <td class="tg-baqh">12</td>   </tr>   <tr>     <td class="tg-baqh">lru-rs</td>     <td class="tg-baqh">Rust</td>     <td class="tg-baqh">16</td>   </tr>   <tr>     <td class="tg-baqh">lru-dict</td>     <td class="tg-baqh">Python + C</td>     <td class="tg-baqh">21</td>   </tr> </table></div></div></div><div class="field field-name-field-table-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Table 2. SIEVE is easy to implement in production-level cache libraries. </div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p><strong>Simplicity</strong>. SIEVE not only achieves better efficiency, higher throughput, and better scalability, but it is also very simple. We chose the most popular cache libraries/systems from five different languages: C++, Go, JavaScript, Python, and Rust, and replaced LRU with SIEVE. Although different libraries/systems have different implementations of LRU, e.g., most use doubly-linked lists, and some use arrays, we find that switching from LRU to SIEVE is very easy. Table 2 shows the number of lines (not including the tests) needed to replace LRU — all implementations require no more than 21 lines of code changes. </p></div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><h3><span>Why does SIEVE work? </span></h3><p><span>You may wonder why this algorithm is called SIEVE. The reason is that the “hand” in SIEVE functions as a sieve: it sifts through the cache to filter out unpopular objects and retain the popular ones. We illustrate this process in Figure 7. Each column represents a snapshot of the cached objects over time from left to right. As the hand moves from the tail (the oldest object) to the head (the newest object), objects that have not been visited are evicted. For example, after the first round of sifting, objects at least as popular as A remain in the cache while others are evicted. The newly admitted objects are placed at the head of the queue. During the subsequent rounds of sifting, if objects that survived previous rounds remain popular, they will stay in the cache. In such a case, since most old objects are not evicted, the eviction hand quickly moves past the old popular objects to the queue positions close to the head. This allows newly inserted objects to be quickly assessed and evicted, putting greater eviction pressure on unpopular items (such as “one-hit wonders”) than LRU-based eviction algorithms. </span></p></div></div></div>  </div> </div> </div><div class="field-item odd"> <div class="entity entity-paragraphs-item paragraphs-item-article-image view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--article_image">   <div class="content">     <div class="field field-name-field-article-image field-type-image field-label-hidden"><div class="field-items"><div class="field-item odd"><img src="https://www.usenix.org/sites/default/files/styles/article_embedded/public/sieve_sifting_0.png?itok=T7F_q-3F" width="771" height="284" alt="" /></div></div></div><div class="field field-name-field-article-image-caption field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Figure 7. An illustration of why SIEVE works. The density of colors indicates inherent object popularity (blue: newly inserted objects; red: old objects in each round), and the letters represent object IDs. The first queue captures the state at the start of the first round, and the second queue captures the state at the end of the first round. </div></div></div>  </div> </div> </div><div class="field-item even"> <div class="entity entity-paragraphs-item paragraphs-item-single-column-text view-mode-full view-mode-full--paragraphs_item view-mode-full--paragraphs_item--single_column_text">   <div class="content">     <div class="field field-name-field-single-column-sub field-type-text field-label-hidden"><div class="field-items"><div class="field-item odd">Conclusion</div></div></div><div class="field field-name-field-single-column-text field-type-text-long field-label-hidden"><div class="field-items"><div class="field-item odd"><p>In this article, we discuss the skewed access pattern in web cache workloads and how to design new cache eviction algorithms. We illustrate two properties of efficient cache eviction algorithms: lazy promotion and quick demotion. SIEVE is a new cache eviction algorithm that leverages these two ideas, while maintaining simplicity and scalability. It uses a FIFO queue with a moving hand to retain popular objects in place and remove unpopular objects quickly. </p></div></div></div>  </div> </div> </div></div></div><legend><span class="fieldset-legend">Appendix</span></legend><div class="fieldset-wrapper"><div class="field field-name-field-lvl2-appendix-refs field-type-text field-label-above"><div class="field-label">References:&nbsp;</div><div class="field-items"><div class="field-item odd"><a class="anchor" name="reference-1"></a><p>[1] Megiddo, Nimrod, and Dharmendra S. Modha. "{ARC}: A {Self-Tuning}, low overhead replacement cache."&nbsp;2nd USENIX Conference on File and Storage Technologies (FAST 03). 2003.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-2"></a><p>[2] Singhvi, Arjun, et al. "Cliquemap: Productionizing a rma-based distributed caching system."&nbsp;Proceedings of the 2021 ACM SIGCOMM 2021 Conference. 2021.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-3"></a><p>[3] Rodriguez, Liana V., et al. "Learning cache replacement with {CACHEUS}."&nbsp;19th USENIX Conference on File and Storage Technologies (FAST 21). 2021.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-4"></a><p>[4] Yang, Juncheng,et al. "A large-scale analysis of hundreds of in-memory cache clusters at Twitter."&nbsp;14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20). 2020.</p> </div><div class="field-item odd"><a class="anchor" name="reference-5"></a><p>[5] Yang, Juncheng, et al. "FIFO queues are all you need for cache eviction."&nbsp;Proceedings of the 29th Symposium on Operating Systems Principles. 2023.&nbsp;</p> </div><div class="field-item even"><a class="anchor" name="reference-6"></a><p>[6] Yang, Juncheng, et al. "FIFO can be Better than LRU: the Power of Lazy Promotion and Quick Demotion."&nbsp;Proceedings of the 19th Workshop on Hot Topics in Operating Systems. 2023.&nbsp;</p> </div><div class="field-item odd"><a class="anchor" name="reference-7"></a><p>[7] Zhang, Yazhuo, et al. "Sieve is simpler than lru: an efficient turn-key eviction algorithm for web caches."&nbsp;21st USENIX Symposium on Networked Systems Design and Implementation (NSDI 24). USENIX Association. 2024.&nbsp;<a href="https://www.usenix.org/conference/nsdi24/presentation/zhang-yazhuo">https://www.usenix.org/conference/nsdi24/presentation/zhang-yazhuo</a></p> </div></div></div></div>
                
                                    <div class="categories">
                        <p>Categories:</p>
                                                    <li class="category">Distributed systems</li>
                                                    <li class="category">Filesystem/storage</li>
                                            </div>
                            </section>
        
    </div>
 </body>
</html>
